 3/1: print('I love you')
 3/2: 3+7
 3/3:
def v(x, y):
    return x + y
 3/4: v(10,2)
 3/5:
x = 'test'
type(x)
 3/6:
word = input('Insert a word')
print(word + 'bla')
 3/7:
x = input()
print(int(x*int(x))**2)
 3/8:
x = input()
print(int(x*int(x))**2)
 3/9: result = "Ваше имя: %s. Ваш возраст: %i." % (name, age)
3/10:
name = input("Введите Ваше имя: ")
age = int(input("Введите Ваш возраст: ")) 
result = "Ваше имя: %s. Ваш возраст: %i." % (name, age)
3/11:
name = input("Введите Ваше имя: ")
age = int(input("Введите Ваш возраст: ")) 
result = "Ваше имя: %s. Ваш возраст: %i." % (name, age)
print(result)
 9/1:
# ваше решение здесь
student = ('Иван Питонов', 2001, [8, 7, 7, 9, 6], True)

fullNameList = student[0].split()
name, surname = fullNameList


print("Студент: {surname}, {name}")
 9/2:
# ваше решение здесь
student = ('Иван Питонов', 2001, [8, 7, 7, 9, 6], True)

fullNameList = student[0].split()
name, surname = fullNameList


print(f"Студент: {surname}, {name}")
 9/3:
# ваше решение здесь
student = ('Иван Питонов', 2001, [8, 7, 7, 9, 6], True)

fullNameList = student[0].split()
name, surname = fullNameList
print(f"Студент: {surname}, {name}")

import datetime
now = datetime.datetime.now()
currentYear = now.year

if year == 2021
    print(f"Возраст студента {student[2]}")
 9/4:
# ваше решение здесь
student = ('Иван Питонов', 2001, [8, 7, 7, 9, 6], True)

fullNameList = student[0].split()
name, surname = fullNameList
print(f"Студент: {surname}, {name}")

import datetime
now = datetime.datetime.now()
currentYear = now.year

if currentYear == 2021
    print(f"Возраст студента {student[2]}")
 9/5:
# ваше решение здесь
student = ('Иван Питонов', 2001, [8, 7, 7, 9, 6], True)

fullNameList = student[0].split()
name, surname = fullNameList
print(f"Студент: {surname}, {name}")

import datetime
now = datetime.datetime.now()
currentYear = now.year

if currentYear == 2021
    print(f"Возраст студента {student[1]}")
 9/6:
# ваше решение здесь
student = ('Иван Питонов', 2001, [8, 7, 7, 9, 6], True)

fullNameList = student[0].split()
name, surname = fullNameList
print(f"Студент: {surname}, {name}")

import datetime
now = datetime.datetime.now()
currentYear = now.year

if currentYear == 2021:
    print(f"Возраст студента {student[1]}")
 9/7:
# ваше решение здесь
student = ('Иван Питонов', 2001, [8, 7, 7, 9, 6], True)

fullNameList = student[0].split()
name, surname = fullNameList
print(f"Студент: {surname}, {name}")

import datetime
now = datetime.datetime.now()
currentYear = now.year

if currentYear == 2021:
    print(f"Возраст студента {currentYear - student[1]}")
 9/8:
# ваше решение здесь
student = ('Иван Питонов', 2001, [8, 7, 7, 9, 6], True)

fullNameList = student[0].split()
name, surname = fullNameList
print(f"Студент: {surname}, {name}")

import datetime
now = datetime.datetime.now()
currentYear = now.year

if currentYear == 2021:
    print(f"Возраст студента {currentYear - student[1]} лет")
 9/9:
# ваше решение здесь
student = ('Иван Питонов', 2001, [8, 7, 7, 9, 6], True)

fullNameList = student[0].split()
name, surname = fullNameList
print(f"Студент: {surname}, {name}")

import datetime
now = datetime.datetime.now()
currentYear = now.year

if currentYear == 2020:
    print(f"Возраст студента {currentYear - student[1]} лет")

marks = student[2]
print(''.join(map(str, marks)))
9/10:
# ваше решение здесь
student = ('Иван Питонов', 2001, [8, 7, 7, 9, 6], True)

fullNameList = student[0].split()
name, surname = fullNameList
print(f"Студент: {surname}, {name}")

import datetime
now = datetime.datetime.now()
currentYear = now.year

if currentYear == 2020:
    print(f"Возраст студента {currentYear - student[1]} лет")

marks = student[2]
for e in marks:
   print e,
9/11:
# ваше решение здесь
student = ('Иван Питонов', 2001, [8, 7, 7, 9, 6], True)

fullNameList = student[0].split()
name, surname = fullNameList
print(f"Студент: {surname}, {name}")

import datetime
now = datetime.datetime.now()
currentYear = now.year

if currentYear == 2020:
    print(f"Возраст студента {currentYear - student[1]} лет")

marks = student[2]
for e in marks:
   print(e,)
9/12:
# ваше решение здесь
student = ('Иван Питонов', 2001, [8, 7, 7, 9, 6], True)

fullNameList = student[0].split()
name, surname = fullNameList
print(f"Студент: {surname}, {name}")

import datetime
now = datetime.datetime.now()
currentYear = now.year

if currentYear == 2020:
    print(f"Возраст студента {currentYear - student[1]} лет")

marks = student[2]
print(','.join(map(str, marks)))
9/13:
# ваше решение здесь
student = ('Иван Питонов', 2001, [8, 7, 7, 9, 6], True)

fullNameList = student[0].split()
name, surname = fullNameList
print(f"Студент: {surname}, {name}")

import datetime
now = datetime.datetime.now()
currentYear = now.year

if currentYear == 2020:
    print(f"Возраст студента {currentYear - student[1]} лет")

marks = student[2]
print(', '.join(map(str, marks)))
9/14:
# ваше решение здесь
student = ('Иван Питонов', 2001, [8, 7, 7, 9, 6], True)

fullNameList = student[0].split()
name, surname = fullNameList
print(f"Студент: {surname}, {name}")

import datetime
now = datetime.datetime.now()
currentYear = now.year

if currentYear == 2020:
    print(f"Возраст студента {currentYear - student[1]} лет")

marks = student[2]
print(', '.join(map(str, marks)))        

if type(marks) is list:
    average = sum(marks) / len(marks)
    print(f{"Средний балл студента: {average}"})
9/15:
# ваше решение здесь
student = ('Иван Питонов', 2001, [8, 7, 7, 9, 6], True)

fullNameList = student[0].split()
name, surname = fullNameList
print(f"Студент: {surname}, {name}")

import datetime
now = datetime.datetime.now()
currentYear = now.year

if currentYear == 2020:
    print(f"Возраст студента {currentYear - student[1]} лет")

marks = student[2]
print(', '.join(map(str, marks)))        

if type(marks) is list:
    average = sum(marks) / len(marks)
    print(f"Средний балл студента: {average}")
9/16:
# ваше решение здесь
student = ('Иван Питонов', 2001, [8, 7, 7, 9, 6], True)

fullNameList = student[0].split()
name, surname = fullNameList
print(f"Студент: {surname}, {name}")

import datetime
now = datetime.datetime.now()
currentYear = now.year

if currentYear == 2020:
    print(f"Возраст студента {currentYear - student[1]} лет")

marks = student[2]
print(', '.join(map(str, marks)))        

if type(marks) is list:
    average = sum(marks) / len(marks)
    print(f"Средний балл студента: {average}")
    
if average >= 8:
    print(True)
else:
    print(False)
9/17:
# ваше решение здесь
numbers = [1, 1000, 1002124, 25, 10, 20, 351]

numbers_int_sorted = sorted(numbers);
numbers_str = map(str, numbers)

print(numbers_str)
9/18:
# ваше решение здесь
numbers = [1, 1000, 1002124, 25, 10, 20, 351]

numbers_int_sorted = sorted(numbers)
numbers_str = list(map(str, numbers))

print(numbers_str)
9/19:
# ваше решение здесь
numbers = [1, 1000, 1002124, 25, 10, 20, 351]

numbers_int_sorted = sorted(numbers)
numbers_str = list(map(str, numbers))
numbers_str_sorted = sorted(numbers_str)

print(numbers_str)
print(numbers_str_sorted)
9/20:
# ваше решение здесь
student = ('Иван Питонов', 2001, [8, 7, 7, 9, 6], True)

fullNameList = student[0].split()
name, surname = fullNameList
print(f"Студент: {surname}, {name}")

import datetime
now = datetime.datetime.now()
currentYear = now.year

if currentYear == 2020:
    print(f"Возраст студента {currentYear - student[1]} лет")

marks = student[2]
print(*marks, sep=', ')     

if type(marks) is list:
    average = sum(marks) / len(marks)
    print(f"Средний балл студента: {average}")
    
if average >= 8:
    print(True)
else:
    print(False)
9/21:
# ваше решение здесь
numbers = [1, 1000, 1002124, 25, 10, 20, 351]

numbers_int_sorted = sorted(numbers)
numbers_str = list(map(str, numbers))
numbers_str_sorted = sorted(numbers_str)
numbers_str_key_sorted = sorted(numbers_str, key=int)

print(numbers_str)
print(numbers_str_sorted)
print(numbers_str_key_sorted)
9/22:
# ваше решение здесь
numbers = [1, 1000, 1002124, 25, 10, 20, 351]

numbers_int_sorted = sorted(numbers)
numbers_str = list(map(str, numbers))
numbers_str_sorted = sorted(numbers_str)
numbers_str_key_sorted = sorted(numbers_str, key=int)

print(numbers_int_sorted)
print(numbers_str_sorted)
print(numbers_str_key_sorted)
9/23:
# ваше решение здесь
numbers = [1, 1000, 1002124, 25, 10, 20, 351]

numbers_int_sorted = sorted(numbers)
numbers_str = list(map(str, numbers))
numbers_str_sorted = sorted(numbers_str)
numbers_str_key_sorted = sorted(numbers_str, key=int)

print(numbers_int_sorted)
print(numbers_str_sorted)
print(numbers_str_key_sorted)

# элементы первого и третьего списка отсортированы аналогично, тк сортировка проходит по целым числам Во втором случае список сортируется
# в порядке расположения символов в кодировке
9/24:
# ваше решение здесь

testList = [1, 2, 3, 4, 5, 1, 2, 1, 2, 7, 3]

setFromList = set(testList)

print(setFromList)
9/25:
# ваше решение здесь

testList = [1, 2, 3, 4, 5, 1, 2, 1, 2, 7, 3]

setFromList = set(testList)

print(len(setFromList))
9/26:
# ваше решение здесь

students = ['John', 'Mary', 'Ben']
studies = ['английский', 'немецкий', 'право', 'математика', 'сольфеджио']

set1 = set(map(str, input('Введите через запятую от 1 до 3 факультативов').split(',')))
set2 = set(map(str, input('Введите через запятую от 1 до 3 факультативов').split(',')))
set3 = set(map(str, input('Введите через запятую от 1 до 3 факультативов').split(',')))
9/27:
# ваше решение здесь

studies = ['английский', 'немецкий', 'право', 'математика', 'сольфеджио']

set1 = set(map(str, input('Студент1, введите через запятую от 1 до 3 факультативов ').split(',')))
set2 = set(map(str, input('Студент2, введите через запятую от 1 до 3 факультативов ').split(',')))
set3 = set(map(str, input('Студент3, введите через запятую от 1 до 3 факультативов ').split(',')))

print(set1.intersection.set2)
9/28:
# ваше решение здесь

studies = ['английский', 'немецкий', 'право', 'математика', 'сольфеджио']

set1 = set(map(str, input('Студент1, введите через запятую от 1 до 3 факультативов ').split(',')))
set2 = set(map(str, input('Студент2, введите через запятую от 1 до 3 факультативов ').split(',')))
set3 = set(map(str, input('Студент3, введите через запятую от 1 до 3 факультативов ').split(',')))

print(set1.intersection(set2))
9/29:
# ваше решение здесь

studies = ['английский', 'немецкий', 'право', 'математика', 'сольфеджио']

set1 = set(map(str, input('Студент1, введите через запятую от 1 до 3 факультативов ').split(',')))
set2 = set(map(str, input('Студент2, введите через запятую от 1 до 3 факультативов ').split(',')))
set3 = set(map(str, input('Студент3, введите через запятую от 1 до 3 факультативов ').split(',')))

intersection1 = set1.intersection(set2)
intersection2 = intersection.intersection(set3)

print(f'Rоличество факультативов, которые откроются {intersection2}')
9/30:
# ваше решение здесь

studies = ['английский', 'немецкий', 'право', 'математика', 'сольфеджио']

set1 = set(map(str, input('Студент1, введите через запятую от 1 до 3 факультативов ').split(',')))
set2 = set(map(str, input('Студент2, введите через запятую от 1 до 3 факультативов ').split(',')))
set3 = set(map(str, input('Студент3, введите через запятую от 1 до 3 факультативов ').split(',')))

firstIntersection = set1.intersection(set2)
finalIntersection = firstIntersection.intersection(set3)

print(f'Rоличество факультативов, которые откроются {finalIntersection}')
9/31:
# ваше решение здесь

studies = ['английский', 'немецкий', 'право', 'математика', 'сольфеджио']

set1 = set(map(str, input('Студент1, введите через запятую от 1 до 3 факультативов ').split(',')))
set2 = set(map(str, input('Студент2, введите через запятую от 1 до 3 факультативов ').split(',')))
set3 = set(map(str, input('Студент3, введите через запятую от 1 до 3 факультативов ').split(',')))

firstIntersection = set1.intersection(set2)
finalIntersection = firstIntersection.intersection(set3)

print(f'Rоличество факультативов, которые откроются {len(finalIntersection)}')
14/1:
set1 = set(map(int,input().split()))
set2 = set(map(int,input().split()))
set1.intersection(set2)
9/32:
# ваше решение здесь

studies = ['английский', 'немецкий', 'право', 'математика', 'сольфеджио']

set1 = set(map(str, input('Студент1, введите через пробел от 1 до 3 факультативов ').split()))
set2 = set(map(str, input('Студент2, введите через пробел от 1 до 3 факультативов ').split()))
set3 = set(map(str, input('Студент3, введите через пробел от 1 до 3 факультативов ').split()))

firstIntersection = set1.intersection(set2)
finalIntersection = firstIntersection.intersection(set3)

print(f'Rоличество факультативов, которые откроются {len(finalIntersection)}')
9/33:
# ваше решение здесь

studies = ['английский', 'немецкий', 'право', 'математика', 'сольфеджио']

set1 = set(map(str, input('Студент1, введите через пробел от 1 до 3 факультативов ').split()))
set2 = set(map(str, input('Студент2, введите через пробел от 1 до 3 факультативов ').split()))
set3 = set(map(str, input('Студент3, введите через пробел от 1 до 3 факультативов ').split()))

firstIntersection = set1.intersection(set2)
finalIntersection = firstIntersection.intersection(set3)

print(f'Rоличество факультативов, которые откроются {len(finalIntersection)}')
9/34:
# ваше решение здесь

studies = ['английский', 'немецкий', 'право', 'математика', 'сольфеджио']

set1 = set(map(str, input('Студент1, введите через пробел от 1 до 3 факультативов ').split()))
set2 = set(map(str, input('Студент2, введите через пробел от 1 до 3 факультативов ').split()))
set3 = set(map(str, input('Студент3, введите через пробел от 1 до 3 факультативов ').split()))

firstIntersection = set1.intersection(set2)
finalIntersection = firstIntersection.intersection(set3)

print(f'Rоличество факультативов, которые откроются {len(finalIntersection)}')
9/35:
# ваше решение здесь

studies = ['английский', 'немецкий', 'право', 'математика', 'сольфеджио']

set1 = set(map(str, input('Студент1, введите через пробел от 1 до 3 факультативов ').split()))
set2 = set(map(str, input('Студент2, введите через пробел от 1 до 3 факультативов ').split()))
set3 = set(map(str, input('Студент3, введите через пробел от 1 до 3 факультативов ').split()))

firstIntersection = set1.intersection(set2)
finalIntersection = firstIntersection.intersection(set3)

print(f'Rоличество факультативов, которые откроются {len(finalIntersection)}')
9/36:
# ваше решение здесь

set1 = set(map(str, input('Студент1, введите через пробел от 1 до 3 факультативов ').split()))
set2 = set(map(str, input('Студент2, введите через пробел от 1 до 3 факультативов ').split()))

studiesToBeOpened = set1.union(set2)
studiesToBeOpened.discard(1)

print(studiesToBeOpened)
9/37:
# ваше решение здесь

set1 = set(map(str, input('Студент1, введите через пробел от 1 до 3 факультативов ').split()))
set2 = set(map(str, input('Студент2, введите через пробел от 1 до 3 факультативов ').split()))

studiesToBeOpened = set1.union(set2)
studiesToBeOpened.remove(1)

print(studiesToBeOpened)
9/38:
# ваше решение здесь

set1 = set(map(str, input('Студент1, введите через пробел от 1 до 3 факультативов ').split()))
set2 = set(map(str, input('Студент2, введите через пробел от 1 до 3 факультативов ').split()))

studiesToBeOpened = set1.union(set2)
studiesToBeOpened.remove('право')

print(studiesToBeOpened)
16/1:
# ваше решение здесь

set1 = set(map(str, input('Студент1, введите через пробел от 1 до 3 факультативов ').split()))
set2 = set(map(str, input('Студент2, введите через пробел от 1 до 3 факультативов ').split()))

studiesToBeOpened = set1.union(set2)
studiesToBeOpened.discard('право')

print(studiesToBeOpened)
16/2:
set1 = set(map(str, input('Студент1, введите через пробел от 1 до 3 факультативов ').split()))
set2 = set(map(str, input('Студент2, введите через пробел от 1 до 3 факультативов ').split()))
set3 = set(map(str, input('Студент3, введите через пробел от 1 до 3 факультативов ').split()))

firstIntersection = set1.intersection(set2)
finalIntersection = firstIntersection.intersection(set2)

print(len(finalIntersection))
16/3:
dict_of_lists = {'Список1': [{'Python': 'язык программирования'}, {'R':'язык программирования', 'LaTEX' : 'язык верстки' }], 
                 'Список2' : [{'Windows' : ['операционная система', 'разработчик'], 'UNIX' : 'операционная система'},
                              {'IBM': ['компания-производитель', 'разработчик'], 'IPv6' : 'интернет-протокол' }]}

# ваше решение здесь
print(dict_of_lists['Список2'][Windows][1])
16/4:
dict_of_lists = {'Список1': [{'Python': 'язык программирования'}, {'R':'язык программирования', 'LaTEX' : 'язык верстки' }], 
                 'Список2' : [{'Windows' : ['операционная система', 'разработчик'], 'UNIX' : 'операционная система'},
                              {'IBM': ['компания-производитель', 'разработчик'], 'IPv6' : 'интернет-протокол' }]}

# ваше решение здесь
print(dict_of_lists['Список2']['Windows'][1])
16/5:
dict_of_lists = {'Список1': [{'Python': 'язык программирования'}, {'R':'язык программирования', 'LaTEX' : 'язык верстки' }], 
                 'Список2' : [{'Windows' : ['операционная система', 'разработчик'], 'UNIX' : 'операционная система'},
                              {'IBM': ['компания-производитель', 'разработчик'], 'IPv6' : 'интернет-протокол' }]}

# ваше решение здесь
print(dict_of_lists['Список2']['Windows'])
16/6:
dict_of_lists = {'Список1': [{'Python': 'язык программирования'}, {'R':'язык программирования', 'LaTEX' : 'язык верстки' }], 
                 'Список2' : [{'Windows' : ['операционная система', 'разработчик'], 'UNIX' : 'операционная система'},
                              {'IBM': ['компания-производитель', 'разработчик'], 'IPv6' : 'интернет-протокол' }]}

# ваше решение здесь
print(dict_of_lists['Список2'][0]['Windows'][1])
18/1:
# ваше решение здесь

s = str(input())
18/2:
# ваше решение здесь

s = str(input())

print(s[2])
18/3:
# ваше решение здесь

s = str(input())

1. #пусть n нумерация символов и n=1
n=3
print(s[n-1])
25/1:
def summ(a =2 , b=2):
    summ = a + b
#     return summ # вернёт сумму

c = summ(4, 3) # переменная c будет равна возвращаемому значению


print(c)
print(summ()) # можно передать значения в аргументы другой функции
25/2: type(summarize)
25/3: type(summarize())
25/4:
summ()
type(summ())
25/5:
summ()
type(summ
25/6: summ()
25/7:
summ()
type(summ)
18/4:
# ваше решение здесь

set1 = list(map(int, input('Введите до 100000 чисел через пробел').split()))

setFromList = set(testList)

print(len(setFromList))
18/5:
# ваше решение здесь

myList = list(map(int, input('Введите до 100000 чисел через пробел').split()))

setFromList = set(myList)

print(len(setFromList))
18/6:
# ваше решение здесь

myList = list(map(int, input('Введите до 100000 чисел через пробел ').split()))
print(myList)
setFromList = set(myList)

print(len(setFromList))
18/7:
# ваше решение здесь

myList = list(map(int, input('Введите до 100000 чисел через пробел ').split()))
print(myList)
setFromList = set(myList)

print(len(setFromList))
18/8:
# ваше решение здесь

s = str(input())

1. #пусть n нумерация символов и n=1
n=3
print(s[n-1])

2. #предпоследний 
print(s[-2])
25/8:
def f():
    global s
    print(s)
    s = "Only in spring, but London is great as well!"
    print(s)


s = "I am looking for a course in Paris!" 
f()
print(s)
25/9:
def f():
#     global s
    print(s)
    s = "Only in spring, but London is great as well!"
    print(s)


s = "I am looking for a course in Paris!" 
f()
print(s)
25/10:
def f():
    global s
    print(s)
    s = "Only in spring, but London is great as well!"
    print(s)


s = "I am looking for a course in Paris!" 
f()
print(s)
25/11:
a = [(1,3),(4,6)]
def to_str(x):
    return sum(x)
list(map(to_str, a))
25/12: integrate(to_integrate,0,2,10000)
25/13:
def integrate(function,a,b,N):
#     step = (b-a)/N
    function_values = [function(i) for i in split_interval(a,b,N)]
    trapeze = []
    for i in range(1, N+1):
        trapeze.append((function_values[i]+function_values[i-1])*step/2)
    return sum(trapeze)
25/14: integrate(to_integrate,0,2,10000)
25/15: integrate(to_integrate,0,2,10000)
25/16:
def integral(x):
    return 28*x**4/4 -7*x**2/2 + sin(x)
25/17: 'asdf'.upper()
25/18:
def Имя(аргументы):
    '''Документация
    '''
    Тело (инструкции)
    return [значение]
25/19:
def summarize(a, b):
    summ = a + b
    print(summ)
    return # вернёт None (Для любителей С++ это +- то же самое, что return 0)
25/20: x = summarize(1, 2)
25/21: x
25/22: type(summarize())
25/23:
list1 = [0,1,2]
print([3,4,list1]) # тут элементом стал сам список
print([3,4,*list1]) # а тут мы элементы списка распаковали
25/24:
def adder(x, y, z):
    print("sum:",x + y + z)

adder(10, 12, 13)
25/25: print(1,2,3)
25/26: # a,b,c,d,e = [1,2,3,4,5]
25/27:
def adder(*nums):
    summ = 0
    for n in nums:
        summ += n

    print("Sum: ", summ)

adder(3, 5)
adder(4, 5, 6, 7)
adder(1, 2, 3, 5, 6)
25/28:
def intro(**data):
    print("\nData type of argument: ",type(data))

    for key, value in data.items():
        print("{} is {}".format(key, value))

intro(Firstname="Yoko", Lastname="Ono", Age=87, Phone=1234567890)
intro(Firstname="John", Lastname="Lennon", Email="johnlennon@nomail.com", Country="UK", Age=40, Phone=9876543210)
25/29:
def f(x):
    output = x+1
    output2 = output + 1
    return output2

print(f(4))
print(output)
25/30:
a = [1,3,4,6]
list(map(lambda x: x if x % 3 == 0 else 0, a))
25/31:
numbers = [1,2,3,4,5]
numbers_under_4 = []
for number in numbers:
    if number < 4:
        numbers_under_4.append(number)
numbers_under_4
25/32:
numbers = [1,2,3,4,5]
numbers_under_4 = [number for number in numbers if number < 4]
numbers_under_4
25/33:
numbers = [1,2,3,4,5]
numbers_under_4 = list(filter(lambda x: x < 4, numbers))
numbers_under_4
25/34:
def factorial(N):
#Ваше решение
25/35:
import time
@memo
def fib(n):
    if n < 2:
        return n
    return fib(n-2) + fib(n-1)

# Какое число мы хотим посчитать
x = 40

t1 = time.perf_counter()
print(f'fib({x}) =', fib(x))
print(time.perf_counter() - t1)
25/36:
import time
@memo
def fib(n):
    if n < 2:
        return n
    return fib(n-2) + fib(n-1)

# Какое число мы хотим посчитать
x = 40

t1 = time.perf_counter()
print(f'fib({x}) =', fib(x))
print(time.perf_counter() - t1)
18/9:
# ваше решение здесь

s = str(input())

# 1. пусть n нумерация символов и n=1
n=3
print(s[n-1])

# 2. предпоследний 
print(s[-2])

# 3. первые пять символов этой строки.
print(s[0:5])
18/10:
# ваше решение здесь

s = str(input())

# 1. пусть n нумерация символов и n=1
n=3
print(s[n-1])

# 2. предпоследний 
print(s[-2])

# 3. первые пять символов этой строки.
print(s[0:5])

# 4. В четвертой строке выведите всю строку, кроме последних двух символов.
print(s[0:2])
18/11:
# ваше решение здесь

s = str(input())

# 1. пусть n нумерация символов и n=1
n=3
print(s[n-1])

# 2. предпоследний 
print(s[-2])

# 3. первые пять символов этой строки.
print(s[0:5])

# 4. В четвертой строке выведите всю строку, кроме последних двух символов.
print(s[:2])
18/12:
# ваше решение здесь

s = str(input())

# 1. пусть n нумерация символов и n=1
n=3
print(s[n-1])

# 2. предпоследний 
print(s[-2])

# 3. первые пять символов этой строки.
print(s[0:5])

# 4. В четвертой строке выведите всю строку, кроме последних двух символов.
print(s[:-2])
26/1: 'asdf'.upper()
26/2:
def Имя(аргументы):
    '''Документация
    '''
    Тело (инструкции)
    return [значение]
26/3:
def summarize(a, b):
    summ = a + b
    print(summ)
    return # вернёт None (Для любителей С++ это +- то же самое, что return 0)
26/4: x = summarize(1, 2)
26/5: x
26/6: type(summarize())
26/7:
import re
s = ' ФГОС и ПГУ и НОУ ЦКН РК'
x = re.findall(r'[А-Я\s]+', s)
[i.strip() for i in x]
26/8:
# Список
a = [1,2,3,4,6,34,6,335,777,876]

# Функция, которая возвращает число, цифры которого разделены символом _ и превращены в строку
import re

def to_str(x):
    return '_'.join(re.findall(r'\d',str(x)))

list(map(to_str,a))
26/9:
a = [1,3,4,6]
list(map(lambda x: x if x % 3 == 0 else 0, a))
26/10:
numbers = [1,2,3,4,5]
numbers_under_4 = []
for number in numbers:
    if number < 4:
        numbers_under_4.append(number)
numbers_under_4
26/11:
numbers = [1,2,3,4,5]
numbers_under_4 = [number for number in numbers if number < 4]
numbers_under_4
26/12:
numbers = [1,2,3,4,5]
numbers_under_4 = list(filter(lambda x: x < 4, numbers))
numbers_under_4
26/13:
def factorial(N):
#Ваше решение
26/14:
def factorial(n):
    if n != 0:
        return n * factorial(n-1)
    else:
        return 1

# В этой реализации есть некоторые проблемы, но мы поговорим об этом потом :)
26/15: factorial(5)
26/16:
def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n-1)

print(factorial(3000))
26/17:
def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n-1)

print(factorial(3000))
26/18: fibonacci(10)
26/19:
def fibonacci(n):
    if n in (1, 2):
        return 1
    f1 = 1
    f2 = 1
    for i in range(1, n-1):
        f3 = f1 + f2 
        f1 = f2
        f2 = f3
    return f3
26/20: fibonacci(10)
26/21:
def IsPalindrome(S):
    if len(S) <= 1:
        return True
    else:
        return S[0] == S[-1] and IsPalindrome(S[1:-1])
26/22: IsPalindrome('ололо')
26/23:
def summe(n):
    if n == 0:
        return 0
    return n + summe(n - 1)
26/24: summe(10)
26/25:
def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n-1)

print(factorial(3000))
26/26:
def factorial(n):
    if n != 0:
        return n * factorial(n-1)
    else:
        return 1

# В этой реализации есть некоторые проблемы, но мы поговорим об этом потом :)
26/27: factorial(5)
26/28:
def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n-1)

print(factorial(3000))
26/29:
def fibonacci(n):
    if n in (1, 2):
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)
26/30:
def fibonacci(n):
    if n in (1, 2):
        return 1
    f1 = 1
    f2 = 1
    for i in range(1, n-1):
        f3 = f1 + f2 
        f1 = f2
        f2 = f3
    return f3
26/31:
def power(a, n):
    if n == 0:
        return 1
    elif n % 2 == 1:
        return power(a, n - 1) * a
    else:
        return power(a, n // 2) ** 2
26/32:


power(2,20)
26/33:
def createGenerator():
    mylist = range(3)
    for i in mylist:
        yield i*i
26/34: createGenerator()
26/35:
mygenerator = createGenerator()
print(type(mygenerator))
for i in mygenerator:
     print(i)
26/36:
mygenerator = createGenerator()
print(next(mygenerator))
print(next(mygenerator))
print(next(mygenerator))
print(next(mygenerator))
26/37:
def infinite_sequence():
    num = 0
    while True:
        yield num
        num += 1
26/38:
gen = infinite_sequence()

print(next(gen))
print(next(gen))
print(next(gen))
print(next(gen))
26/39:
def fib(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b
26/40:
a = 2 
b = 3
26/41: a,b = b,a
26/42:
a = fib(10)
print(next(a))
print(next(a))
print(next(a))
print(next(a))
print(next(a))
print(next(a))
26/43: 5+5
26/44:
# Ожидаемо это 10
_
26/45:
# а еще с ним можно производить стандартные операции
_+1
26/46:
# А тут в _ уже перезаписалось 11
_
26/47:
# А еще можно присвоить это значение новой переменной!
x = _
x
26/48:
def my_shiny_new_decorator(function_to_decorate):
    # Внутри себя декоратор определяет функцию-"обёртку". Она будет обёрнута вокруг декорируемой,
    # получая возможность исполнять произвольный код до и после неё.
    def the_wrapper_around_the_original_function():
        print("Я - код, который отработает до вызова функции")
        function_to_decorate() # Сама функция
        print("А я - код, срабатывающий после")
    # Вернём эту функцию
    return the_wrapper_around_the_original_function
26/49:
def stand_alone_function():
    print("Я простая одинокая функция, ты ведь не посмеешь меня изменять?")

stand_alone_function()
26/50:
# Однако, чтобы изменить её поведение, мы можем декорировать её, то есть просто передать декоратору,
# который обернет исходную функцию в любой код, который нам потребуется, и вернёт новую,
# готовую к использованию функцию:
stand_alone_function_decorated = my_shiny_new_decorator(stand_alone_function)
stand_alone_function_decorated()
26/51:
import time
time.perf_counter()
26/52:
# Декоратор 1
def benchmark(func):
    """
    Декоратор, выводящий время, которое заняло
    выполнение декорируемой функции.
    """
    import time
    def wrapper(*args, **kwargs):
        t = time.perf_counter() # Засекли время начала выполнения
        res = func(*args, **kwargs) # Запустили
        print(func.__name__, time.perf_counter() - t) # Засекли время окончания исполнения и вывели время конца- время начала
        return res
    return wrapper

# Декоратор 2
def logging(func):
    """
    Декоратор, который выводит вызовы функции.
    """
    def wrapper(*args, **kwargs):
        res = func(*args, **kwargs)
        print(func.__name__, args, kwargs)
        return res
    return wrapper

# Декоратор 3
def counter(func):
    """
    Декоратор, считающий и выводящий количество вызовов
    декорируемой функции.
    """
    def wrapper(*args, **kwargs):
        wrapper.count += 1
        res = func(*args, **kwargs)
        print ("{0} была вызвана: {1}x".format(func.__name__, wrapper.count))
        return res
    wrapper.count = 0
    return wrapper
26/53:
@benchmark 
@logging
@counter
def reverse_string(string):
    return ''.join(reversed(string))
26/54: print(reverse_string("А роза упала на лапу Азора"))
26/55:
import requests
import re
from random import randint
@benchmark
@logging
@counter
def get_random_idiot_word_count(word):
    the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'

    # Отправляем запрос в библиотеку Gutenberg и забираем текст
    raw = requests.get(the_idiot_url).text
    #Заменим в тексте все небуквенные символы на пробелы
    processed_book = re.sub('[\W]+' , ' ', raw).lower()
    return len(re.findall(word.lower(),processed_book))

get_random_idiot_word_count('whole')
26/56:
### Решение 1
def factorial(n):
    f = 1
    for i in range(2, n+1):
        f = f * i
    return f
factorial(1)
26/57:
import requests
import re
from random import randint
@benchmark
@logging
@counter
def get_random_idiot_word_count(word):
    the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'

    # Отправляем запрос в библиотеку Gutenberg и забираем текст
    raw = requests.get(the_idiot_url).text
    #Заменим в тексте все небуквенные символы на пробелы
    processed_book = re.sub('[\W]+' , ' ', raw).lower()
    return len(re.findall(word.lower(),processed_book))

get_random_idiot_word_count('whole')
26/58:
import requests
import re
from random import randint
@benchmark
@logging
@counter
def get_random_idiot_word_count(word):
    the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'

    # Отправляем запрос в библиотеку Gutenberg и забираем текст
    raw = requests.get(the_idiot_url).text
    #Заменим в тексте все небуквенные символы на пробелы
    processed_book = re.sub('[\W]+' , ' ', raw).lower()
    return len(re.findall(word.lower(),processed_book))

get_random_idiot_word_count('whole')
26/59:
import requests
import re
from random import randint
@benchmark
@logging
@counter
def get_random_idiot_word_count(word):
    the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'

    # Отправляем запрос в библиотеку Gutenberg и забираем текст
    raw = requests.get(the_idiot_url).text
    #Заменим в тексте все небуквенные символы на пробелы
    processed_book = re.sub('[\W]+' , ' ', raw).lower()
    return len(re.findall(word.lower(),processed_book))

get_random_idiot_word_count('whole')
26/60:
### Решение 1
def factorial(n):
    f = 1
    for i in range(2, n+1):
        f = f * i
    return f
factorial(1)
26/61:
### Решение 1
def factorial(n):
    f = 1
    for i in range(2, n+1):
        f = f * i
    return f
factorial(1)
26/62:
def my_shiny_new_decorator(function_to_decorate):
    # Внутри себя декоратор определяет функцию-"обёртку". Она будет обёрнута вокруг декорируемой,
    # получая возможность исполнять произвольный код до и после неё.
    def the_wrapper_around_the_original_function():
        print("Я - код, который отработает до вызова функции")
        function_to_decorate() # Сама функция
        print("А я - код, срабатывающий после")
    # Вернём эту функцию
    return the_wrapper_around_the_original_function
26/63:
def my_shiny_new_decorator(function_to_decorate):
    # Внутри себя декоратор определяет функцию-"обёртку". Она будет обёрнута вокруг декорируемой,
    # получая возможность исполнять произвольный код до и после неё.
    def the_wrapper_around_the_original_function():
        print("Я - код, который отработает до вызова функции")
        function_to_decorate() # Сама функция
        print("А я - код, срабатывающий после")
    # Вернём эту функцию
    return the_wrapper_around_the_original_function
26/64:
def my_shiny_new_decorator(function_to_decorate):
    # Внутри себя декоратор определяет функцию-"обёртку". Она будет обёрнута вокруг декорируемой,
    # получая возможность исполнять произвольный код до и после неё.
    def the_wrapper_around_the_original_function():
        print("Я - код, который отработает до вызова функции")
        function_to_decorate() # Сама функция
        print("А я - код, срабатывающий после")
    # Вернём эту функцию
    return the_wrapper_around_the_original_function
26/65:
def stand_alone_function():
    print("Я простая одинокая функция, ты ведь не посмеешь меня изменять?")

stand_alone_function()
26/66:
# Однако, чтобы изменить её поведение, мы можем декорировать её, то есть просто передать декоратору,
# который обернет исходную функцию в любой код, который нам потребуется, и вернёт новую,
# готовую к использованию функцию:
stand_alone_function_decorated = my_shiny_new_decorator(stand_alone_function)
stand_alone_function_decorated()
26/67:
import time
# @memo
def fib(n):
    if n < 2:
        return n
    return fib(n-2) + fib(n-1)

# Какое число мы хотим посчитать
x = 40

t1 = time.perf_counter()
print(f'fib({x}) =', fib(x))
print(time.perf_counter() - t1)
26/68:
import time
@memo
def fib(n):
    if n < 2:
        return n
    return fib(n-2) + fib(n-1)

# Какое число мы хотим посчитать
x = 40

t1 = time.perf_counter()
print(f'fib({x}) =', fib(x))
print(time.perf_counter() - t1)
26/69:
import time
@memo
def fib(n):
    if n < 2:
        return n
    return fib(n-2) + fib(n-1)

# Какое число мы хотим посчитать
x = 40

t1 = time.perf_counter()
print(f'fib({x}) =', fib(x))
print(time.perf_counter() - t1)
26/70:
import time
@memo
def fib(n):
    if n < 2:
        return n
    return fib(n-2) + fib(n-1)

# Какое число мы хотим посчитать
x = 40

t1 = time.perf_counter()
print(f'fib({x}) =', fib(x))
print(time.perf_counter() - t1)
26/71:
def memo(f):
    "Запомнить результаты исполнения функции f, чьи аргументы args должны быть хешируемыми."
    cache = {}
    def fmemo(*args):
        if args not in cache:
            cache[args] = f(*args)
        return cache[args]
    fmemo.cache = cache
    return fmemo
26/72:
import time
@memo
def fib(n):
    if n < 2:
        return n
    return fib(n-2) + fib(n-1)

# Какое число мы хотим посчитать
x = 40

t1 = time.perf_counter()
print(f'fib({x}) =', fib(x))
print(time.perf_counter() - t1)
28/1:
# ваше решение здесь

s = str(input())

# 1. пусть n нумерация символов и n=1
n=3
print(s[n-1])

# 2. предпоследний 
print(s[-2])

# 3. первые пять символов этой строки.
print(s[0:5])

# 4. В четвертой строке выведите всю строку, кроме последних двух символов.
print(s[:-2])

# 5. В пятой строке выведите все символы с четными индексами (считая, что индексация начинается с 0).
for symbol in s:
    if s % 2 == 0:
        print(s)
28/2:
# ваше решение здесь

s = str(input())

# 1. пусть n нумерация символов и n=1
n=3
print(s[n-1])

# 2. предпоследний 
print(s[-2])

# 3. первые пять символов этой строки.
print(s[0:5])

# 4. В четвертой строке выведите всю строку, кроме последних двух символов.
print(s[:-2])

# 5. В пятой строке выведите все символы с четными индексами (считая, что индексация начинается с 0).
for i in range( len(s)):
    if i % 2 == 0:
        print(s[i])
28/3:
# ваше решение здесь

s = str(input())

# 1. пусть n нумерация символов и n=1
n=3
print(s[n-1])

# 2. предпоследний 
print(s[-2])

# 3. первые пять символов этой строки.
print(s[0:5])

# 4. В четвертой строке выведите всю строку, кроме последних двух символов.
print(s[:-2])

# 5. В пятой строке выведите все символы с четными индексами (считая, что индексация начинается с 0).
for i in range( len(s)):
    if i % 2 == 0:
        print(s[i], end='')
28/4:
# ваше решение здесь

s = str(input())

# 1. пусть n нумерация символов и n=1
n=3
print(s[n-1])

# 2. предпоследний 
print(s[-2])

# 3. первые пять символов этой строки.
print(s[0:5])

# 4. В четвертой строке выведите всю строку, кроме последних двух символов.
print(s[:-2])

# 5. В пятой строке выведите все символы с четными индексами (считая, что индексация начинается с 0).
for i in range( len(s)):
    if i % 2 == 0:
        print(s[i], end='')
# 6. В шестой строке выведите все символы с нечетными индексами (считая, что индексация начинается с 0).
for i in range( len(s)):
    if i % 2 == 1:
        print(s[i], end='')
# 7. В седьмой строке выведите все символы в обратном порядке.
# 8. В восьмой строке выведите все символы строки через один в обратном порядке, начиная с последнего.
# 9. В девятой строке выведите длину данной строки.
28/5:
# ваше решение здесь

s = str(input())

# 1. пусть n нумерация символов и n=1
n=3
print(s[n-1])

# 2. предпоследний 
print(s[-2])

# 3. первые пять символов этой строки.
print(s[0:5])

# 4. В четвертой строке выведите всю строку, кроме последних двух символов.
print(s[:-2])

# 5. В пятой строке выведите все символы с четными индексами (считая, что индексация начинается с 0).
for i in range( len(s)):
    if i % 2 == 0:
        print(s[i], end='')
# 6. В шестой строке выведите все символы с нечетными индексами (считая, что индексация начинается с 0).
for j in range( len(s)):
    if j % 2 == 1:
        print(s[i], end='')
# 7. В седьмой строке выведите все символы в обратном порядке.
# 8. В восьмой строке выведите все символы строки через один в обратном порядке, начиная с последнего.
# 9. В девятой строке выведите длину данной строки.
32/1:
# ваше решение здесь
student = ('Иван Питонов', 2001, [8, 7, 7, 9, 6], True)

fullNameList = student[0].split()
name, surname = fullNameList
print(f"Студент: {surname}, {name}")

import datetime
now = datetime.datetime.now()
currentYear = now.year

if currentYear == 2020:
    print(f"Возраст студента {currentYear - student[1]} лет")

marks = student[2]
print(*marks, sep=', ')     

if type(marks) is list:
    average = sum(marks) / len(marks)
    print(f"Средний балл студента: {average}")
    
if average >= 8:
    print(True)
else:
    print(False)
32/2:
# ваше решение здесь
numbers = [1, 1000, 1002124, 25, 10, 20, 351]

numbers_int_sorted = sorted(numbers)
numbers_str = list(map(str, numbers))
numbers_str_sorted = sorted(numbers_str)
numbers_str_key_sorted = sorted(numbers_str, key=int)

print(numbers_int_sorted)
print(numbers_str_sorted)
print(numbers_str_key_sorted)

# элементы первого и третьего списка отсортированы аналогично, тк сортировка проходит по целым числам. Но в них лежат разные типы данных 
# Во втором случае список сортируется в порядке расположения символов в кодировке
32/3:
# ваше решение здесь

myList = list(map(int, input('Введите до 100000 чисел через пробел ').split()))

setFromList = set(myList)

print(len(setFromList))
32/4:
# ваше решение здесь

s = str(input())

# 1. пусть n нумерация символов и n=1
n=3
print(s[n-1])

# 2. предпоследний 
print(s[-2])

# 3. первые пять символов этой строки.
print(s[0:5])

# 4. В четвертой строке выведите всю строку, кроме последних двух символов.
print(s[:-2])

# 5. В пятой строке выведите все символы с четными индексами (считая, что индексация начинается с 0).
for i in range( len(s)):
    if i % 2 == 0:
        print(s[i], end='')
# 6. В шестой строке выведите все символы с нечетными индексами (считая, что индексация начинается с 0).
for j in range( len(s)):
    if j % 2 == 1:
        print(s[j], end='')
# 7. В седьмой строке выведите все символы в обратном порядке.
# 8. В восьмой строке выведите все символы строки через один в обратном порядке, начиная с последнего.
# 9. В девятой строке выведите длину данной строки.
32/5:
# ваше решение здесь

s = str(input())

# 1. пусть n нумерация символов и n=1
n=3
print(s[n-1])

# 2. предпоследний 
print(s[-2])

# 3. первые пять символов этой строки.
print(s[0:5])

# 4. В четвертой строке выведите всю строку, кроме последних двух символов.
print(s[:-2])

# 5. В пятой строке выведите все символы с четными индексами (считая, что индексация начинается с 0).
for i in range( len(s)):
    if i % 2 == 0:
        print(s[i], sep='')
# 6. В шестой строке выведите все символы с нечетными индексами (считая, что индексация начинается с 0).
for j in range( len(s)):
    if j % 2 == 1:
        print(s[j], sep='')
# 7. В седьмой строке выведите все символы в обратном порядке.
# 8. В восьмой строке выведите все символы строки через один в обратном порядке, начиная с последнего.
# 9. В девятой строке выведите длину данной строки.
32/6:
# ваше решение здесь

s = str(input())

# 1. пусть n нумерация символов и n=1
n=3
print(s[n-1])

# 2. предпоследний 
print(s[-2])

# 3. первые пять символов этой строки.
print(s[0:5])

# 4. В четвертой строке выведите всю строку, кроме последних двух символов.
print(s[:-2])

# 5. В пятой строке выведите все символы с четными индексами (считая, что индексация начинается с 0).
for i in range( len(s)):
    if i % 2 == 0:
        print(s[i], sep='', end='')
# 6. В шестой строке выведите все символы с нечетными индексами (считая, что индексация начинается с 0).
for j in range( len(s)):
    if j % 2 == 1:
        print(s[j], sep='', end='')
# 7. В седьмой строке выведите все символы в обратном порядке.
# 8. В восьмой строке выведите все символы строки через один в обратном порядке, начиная с последнего.
# 9. В девятой строке выведите длину данной строки.
32/7:
# ваше решение здесь

s = str(input())

# 1. пусть n нумерация символов и n=1
n=3
print(s[n-1])

# 2. предпоследний 
print(s[-2])

# 3. первые пять символов этой строки.
print(s[0:5])

# 4. В четвертой строке выведите всю строку, кроме последних двух символов.
print(s[:-2])

# 5. В пятой строке выведите все символы с четными индексами (считая, что индексация начинается с 0).
for i in range( len(s)):
    if i % 2 == 0:
        print(s[i], end='')
print('\n')
# 6. В шестой строке выведите все символы с нечетными индексами (считая, что индексация начинается с 0).
for j in range( len(s)):
    if j % 2 == 1:
        print(s[j], end='')
        
print('\n')
# 7. В седьмой строке выведите все символы в обратном порядке.
# 8. В восьмой строке выведите все символы строки через один в обратном порядке, начиная с последнего.
# 9. В девятой строке выведите длину данной строки.
32/8:
# ваше решение здесь

s = str(input())

# 1. пусть n нумерация символов и n=1
n=3
print(s[n-1])

# 2. предпоследний 
print(s[-2])

# 3. первые пять символов этой строки.
print(s[0:5])

# 4. В четвертой строке выведите всю строку, кроме последних двух символов.
print(s[:-2])

# 5. В пятой строке выведите все символы с четными индексами (считая, что индексация начинается с 0).
for i in range( len(s)):
    if i % 2 == 0:
        print(s[i], end='')
print('\n')
# 6. В шестой строке выведите все символы с нечетными индексами (считая, что индексация начинается с 0).
for j in range( len(s)):
    if j % 2 == 1:
        print(s[j], end='')
print('\n')
# 7. В седьмой строке выведите все символы в обратном порядке.
# 8. В восьмой строке выведите все символы строки через один в обратном порядке, начиная с последнего.
# 9. В девятой строке выведите длину данной строки.
32/9:
# ваше решение здесь

s = str(input())

# 1. пусть n нумерация символов и n=1
n=3
print(s[n-1])

# 2. предпоследний 
print(s[-2])

# 3. первые пять символов этой строки.
print(s[0:5])

# 4. В четвертой строке выведите всю строку, кроме последних двух символов.
print(s[:-2])

# 5. В пятой строке выведите все символы с четными индексами (считая, что индексация начинается с 0).
for i in range( len(s)):
    if i % 2 == 0:
        print(s[i], end='')
print('\n')
# 6. В шестой строке выведите все символы с нечетными индексами (считая, что индексация начинается с 0).
for j in range( len(s)):
    if j % 2 == 1:
        print(s[j], end='')
print('\n')
# 7. В седьмой строке выведите все символы в обратном порядке.
print(s[::-1])
# 8. В восьмой строке выведите все символы строки через один в обратном порядке, начиная с последнего.
# 9. В девятой строке выведите длину данной строки.
32/10:
# ваше решение здесь

s = str(input())

# 1. пусть n нумерация символов и n=1
n=3
print(s[n-1])

# 2. предпоследний 
print(s[-2])

# 3. первые пять символов этой строки.
print(s[0:5])

# 4. В четвертой строке выведите всю строку, кроме последних двух символов.
print(s[:-2])

# 5. В пятой строке выведите все символы с четными индексами (считая, что индексация начинается с 0).
for i in range( len(s)):
    if i % 2 == 0:
        print(s[i], end='')
print('\n')
# 6. В шестой строке выведите все символы с нечетными индексами (считая, что индексация начинается с 0).
for j in range( len(s)):
    if j % 2 == 1:
        print(s[j], end='')
print('\n')
# 7. В седьмой строке выведите все символы в обратном порядке.
print(s[::-1])
# 8. В восьмой строке выведите все символы строки через один в обратном порядке, начиная с последнего.
reverseStr = s[::-1]
for k in range( len(reverseStr)):
    if k % 2 == 0:
        print(reverseStr[k], end='')
print('\n')
# 9. В девятой строке выведите длину данной строки.
32/11:
# ваше решение здесь

s = str(input())

# 1. пусть n нумерация символов и n=1
n=3
print(s[n-1])

# 2. предпоследний 
print(s[-2])

# 3. первые пять символов этой строки.
print(s[0:5])

# 4. В четвертой строке выведите всю строку, кроме последних двух символов.
print(s[:-2])

# 5. В пятой строке выведите все символы с четными индексами (считая, что индексация начинается с 0).
for i in range( len(s)):
    if i % 2 == 0:
        print(s[i], end='')
print('\n')
# 6. В шестой строке выведите все символы с нечетными индексами (считая, что индексация начинается с 0).
for j in range( len(s)):
    if j % 2 == 1:
        print(s[j], end='')
print('\n')
# 7. В седьмой строке выведите все символы в обратном порядке.
print(s[::-1])
# 8. В восьмой строке выведите все символы строки через один в обратном порядке, начиная с последнего.
reverseStr = s[::-1]
for k in range( len(reverseStr)):
    if k % 2 == 0:
        print(reverseStr[k], end='')
print('\n')
# 9. В девятой строке выведите длину данной строки.
print(len(s))
32/12:
dwarves = ["Балин", "Двалин", "Бифур", "Бофур", 
         "Бомбур", "Оин", "Глоин", "Дори", "Нори",
         "Ори", "Фили", "Кили", "Торин"]

# решение здесь
print(dwarves[1:4])
32/13:
dwarves = ["Балин", "Двалин", "Бифур", "Бофур", 
         "Бомбур", "Оин", "Глоин", "Дори", "Нори",
         "Ори", "Фили", "Кили", "Торин"]

# решение здесь
print(dwarves[1:4])
print(dwarves[1::2])
32/14:
dwarves = ["Балин", "Двалин", "Бифур", "Бофур", 
         "Бомбур", "Оин", "Глоин", "Дори", "Нори",
         "Ори", "Фили", "Кили", "Торин"]

# решение здесь
print(dwarves[1:4])
print(dwarves[::2])
32/15:
dwarves = ["Балин", "Двалин", "Бифур", "Бофур", 
         "Бомбур", "Оин", "Глоин", "Дори", "Нори",
         "Ори", "Фили", "Кили", "Торин"]

# решение здесь
print(dwarves[1:4])
print(dwarves[::2])
print(dwarves[5::2])
32/16:
dwarves = ["Балин", "Двалин", "Бифур", "Бофур", 
         "Бомбур", "Оин", "Глоин", "Дори", "Нори",
         "Ори", "Фили", "Кили", "Торин"]

# решение здесь
print(dwarves[1:4])
print(dwarves[::2])
print(dwarves[5::2])
print(dwarves[-1:-8:2])
32/17:
dwarves = ["Балин", "Двалин", "Бифур", "Бофур", 
         "Бомбур", "Оин", "Глоин", "Дори", "Нори",
         "Ори", "Фили", "Кили", "Торин"]

# решение здесь
print(dwarves[1:4])
print(dwarves[::2])
print(dwarves[5::2])
print(dwarves[6::2])
32/18:
dwarves = ["Балин", "Двалин", "Бифур", "Бофур", 
         "Бомбур", "Оин", "Глоин", "Дори", "Нори",
         "Ори", "Фили", "Кили", "Торин"]

# решение здесь
print(dwarves[1:4])
print(dwarves[::2])
print(dwarves[5::2])
print(dwarves[6::2][::-1])
32/19:
number1 = int(input())
number2 = int(input())
numbe3 = int(input())
32/20:
number1 = int(input())
number2 = int(input())
number3 = int(input())
mySet = {number1, number2, number3}

if len(mySet) == 1:
    print(3)
else if len(mySet) == 2:
    print(2)
else:
    print(0)
32/21:
number1 = int(input())
number2 = int(input())
number3 = int(input())
mySet = {number1, number2, number3}

if len(mySet) == 1:
    print(3)
elif len(mySet) == 2:
    print(2)
else:
    print(0)
32/22:
number1 = int(input())
number2 = int(input())
number3 = int(input())
mySet = {number1, number2, number3}

if len(mySet) == 1:
    print(3)
elif len(mySet) == 2:
    print(2)
else:
    print(0)
32/23:
number1 = int(input())
number2 = int(input())
number3 = int(input())
mySet = {number1, number2, number3}

if len(mySet) == 1:
    print(3)
elif len(mySet) == 2:
    print(2)
else:
    print(0)
32/24:
# ваше решение здесь

num = int(input())

i = 2
while num%i != 0:
    i += 1
print(i)
32/25:
# ваше решение здесь

num = int(input())

i = 2
while num%i != 0:
    i += 1
print(i)
32/26:
# ваше решение здесь

num = int(input())

i = 2
while num%i != 0:
    i += 1
print(i)
32/27:
# ваше решение здесь

num = int(input())

i = 2
print(num%i)
while num%i != 0:
    i += 1
print(i)
32/28:
# ваше решение здесь

num = int(input())

i = 2
print(10%2)
while num%i != 0:
    i += 1
print(i)
32/29:
# ваше решение здесь

num = int(input())

i = 2
print(11%2)
while num%i != 0:
    i += 1
print(i)
32/30:
# ваше решение здесь

num = int(input())

i = 2
while num%i != 0:
    i += 1
print(i)
32/31:
# ваше решение здесь

num = int(input())

i = 2
while num%i != 0:
    i += 1
print(i)
32/32:
# ваше решение здесь

num = int(input())

i = 2
while num%i != 0:
    i += 1
print(i)
32/33:
# ваше решение здесь

num = int(input())

i = 2
while num%i != 0:
    i += 1
print(i)
32/34:
# ваше решение здесь

num = int(input())

i = 2
while num%i != 0:
    i += 1
print(i)
32/35:
# ваше решение здесь

num = int(input())

i = 2
while num%i != 0:
    i += 1
print(i)
32/36:
import re
# Ваше решение
s = 'Это курс информатики соответствует ФГОС и ПООП, это подтверждено ФГУ ФНЦ НИИСИ РАН'


re.findall(r'[А-ЯЁ]{2,}',s)
32/37:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.split(r'[А-ЯЁ]{2,}',v)
32/38:
import re
# Ваше решение
s = 'Это курс информатики соответствует ФГОС и ПООП, это подтверждено ФГУ ФНЦ НИИСИ РАН'


re.findall(r'[А-ЯЁ][A-Z]{2,}',s)
32/39:
import re
# Ваше решение
s = 'Это курс информатики соответствует ФГОС и ПООП, это подтверждено ФГУ ФНЦ НИИСИ РАН'


re.findall(r'[А-ЯЁ]|[A-Z]{2,}',s)
32/40:
import re
# Ваше решение
s = 'Это курс информатики соответствует ФГОС и ПООП, это подтверждено ФГУ ФНЦ НИИСИ РАН'


re.findall(r'[А-ЯЁ]{2,}',s)
32/41:
import re
# Ваше решение
s = 'Это курс информатики соответствует ФГОС и ПООП, это подтверждено ФГУ ФНЦ НИИСИ РАН'


re.findall(r'[А-ЯЁA-Z]{2,}',s)
32/42:
import re
# Ваше решение
s = 'Это курс информатики соответствует ФГОС и ПООП, это подтверждено ФГУ ФНЦ НИИСИ РАН'


re.findall(r'[А-ЯЁA-Z]{2,}',s)
32/43:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.split(r'[А-ЯЁA-Z]',v)
32/44:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.finall(r'[А-ЯЁA-Z]',v)
32/45:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[А-ЯЁA-Z]',v)
32/46:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[А-ЯЁA-Z]',v)
32/47:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[А-ЯЁA-Z]',v)
32/48:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'*?[А-ЯЁA-Z]',v)
32/49:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'?<=[А-ЯЁA-Z]',v)
32/50:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[А-ЯЁA-Z]',v)
32/51:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'*[А-ЯЁA-Z]',v)
32/52:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[А-ЯЁA-Z]+',v)
32/53:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[А-ЯЁA-Z]*',v)
32/54:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[А-ЯЁA-Z]*?',v)
32/55:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[А-ЯЁA-Z]?',v)
32/56:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[А-ЯЁA-Z]',v)
32/57:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'?<=[А-ЯЁA-Z]\s+',v)
32/58:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'?<[А-ЯЁA-Z]\s+',v)
32/59:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'?[А-ЯЁA-Z]\s+',v)
32/60:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[А-ЯЁA-Z]\s+',v)
32/61:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[А-ЯЁA-Z]\s',v)
32/62:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[А-ЯЁA-Z]',v)
32/63:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'(?!^)([A-Z]+)',v)
32/64:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'([A-Z]+)',v)
32/65:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'(?<!^)(?=[A-Z])',v)
32/66:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[A-Z][a-z]+',v)
32/67:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'(.)[A-Z][a-z]+',v)
32/68:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[A-Z][a-z]+',v)
32/69:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[a-z][A-Z][a-z]+',v)
32/70:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[a-z]+',v)
32/71:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'\b/[a-z]+',v)
32/72:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'\b[a-z]+',v)
32/73:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'\b[a-zA-z]+',v)
32/74:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'\b[a-zA-Z]+',v)
32/75:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'\b[a-z][A-Z]+',v)
32/76:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'\b[a-z]|[A-Z]+',v)
32/77:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[a-z]|[A-Z]+',v)
32/78:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[a-z]|[A-Z]+\b',v)
32/79:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[a-z]\b[A-Z]+',v)
32/80:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[a-z]|[A-Z]+',v)
32/81:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[a-z][A-Z]+',v)
32/82:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[a-z]\b[A-Z]+',v)
32/83:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'\b[a-z][A-Z]+',v)
32/84:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'\b[A-Z]+',v)
32/85:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'\b[a-z][A-Z]+',v)
32/86:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'\b[a-z][A-Z]+',v)
32/87:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[a-z]|[A-Z]+',v)
32/88:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'[a-z][A-Z]+',v)
32/89:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'\b[a-z]|[A-Z]+',v)
32/90:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'\b[a-z]+|[A-Z]+',v)
32/91:
#Camel case to snake case
v = 'camelCaseVar'
import re

re.findall(r'\b[a-z]+|[A-Z][a-z]+',v)
32/92:
#Camel case to snake case
v = 'camelCaseVar'
import re

splittedList = re.findall(r'\b[a-z]+|[A-Z][a-z]+',v)
'_'.join(map(str.lower, splittedList))
32/93:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b[Aa]|[Ee][a-z]+',text)
re.findall(r'\b[Aa]|[Ee][a-z]+',text2)
32/94:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b[Aa]|[Ee][a-z]+',text)
# re.findall(r'\b[Aa]|[Ee][a-z]+',text2)
32/95:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b^[Aa]|[Ee][a-z]+',text)
# re.findall(r'\b[Aa]|[Ee][a-z]+',text2)
32/96:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b^[Aa][Ee][a-z]+',text)
# re.findall(r'\b[Aa]|[Ee][a-z]+',text2)
32/97:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b^[Aa][a-z]+|[Ee][a-z]+',text)
# re.findall(r'\b[Aa]|[Ee][a-z]+',text2)
32/98:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'[Aa][a-z]+|[Ee][a-z]+',text)
# re.findall(r'\b[Aa]|[Ee][a-z]+',text2)
32/99:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'^[Aa][a-z]+|[Ee][a-z]+',text)
# re.findall(r'\b[Aa]|[Ee][a-z]+',text2)
32/100:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b[Aa][a-z]+|[Ee][a-z]+',text)
# re.findall(r'\b[Aa]|[Ee][a-z]+',text2)
32/101:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b[Aa][a-z]+\s|[Ee][a-z]+\s',text)
# re.findall(r'\b[Aa]|[Ee][a-z]+',text2)
32/102:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b[AaEe][a-z]+\s',text)
# re.findall(r'\b[Aa]|[Ee][a-z]+',text2)
32/103:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b[AaEe][A-Za-z]+\s',text)
# re.findall(r'\b[Aa]|[Ee][a-z]+',text2)
32/104:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b[AaEe][A-Za-z]+\s',text)
# re.findall(r'\b[Aa]|[Ee][a-z]+',text2)
32/105:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b[AaEe][A-Za-z]+\s',text)
# re.findall(r'\b[Aa]|[Ee][a-z]+',text2)
32/106:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b[AaEe][A-Za-z]+\s',text)
# re.findall(r'\b[Aa]|[Ee][a-z]+',text2)
32/107:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'[AaEe][A-Za-z]+\s',text)
# re.findall(r'\b[Aa]|[Ee][a-z]+',text2)
32/108:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b[AaEe][A-Za-z]\s',text)
# re.findall(r'\b[Aa]|[Ee][a-z]+',text2)
32/109:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b[AaEe][A-Za-z]+\s',text)
# re.findall(r'\b[Aa]|[Ee][a-z]+',text2)
32/110:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b[AaEe][A-Za-z]+\s',text)
re.findall(r'\b[Aa]|[Ee][a-z]+',text2)
32/111:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b[AaEe][A-Za-z]+\s',text)
re.findall(r'\b[AaEe][A-Za-z]+\s',text2)
32/112:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

# re.findall(r'\b[AaEe][A-Za-z]+\s',text)
re.findall(r'\b[AaEe][A-Za-z]+\s',text2)
32/113:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

# re.findall(r'\b[AaEe][A-Za-z]+\s',text)
re.findall(r'\b[AaEe][A-Za-z]+\s',text2)
32/114:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b[AaEe][A-Za-z]+\s',text)
# re.findall(r'\b[AaEe][A-Za-z]+\s',text2)
32/115:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b[AaEe]\w+\s',text)
# re.findall(r'\b[AaEe][A-Za-z]+\s',text2)
32/116:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b[AaEe]\w+',text)
# re.findall(r'\b[AaEe][A-Za-z]+\s',text2)
32/117:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

# re.findall(r'\b[AaEe]\w+',text)
# re.findall(r'\b[AaEe][A-Za-z]+\s',text2)
32/118:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

# re.findall(r'\b[AaEe]\w+',text)
# re.findall(r'\b[AaEe][A-Za-z]+\s',text2)
re.findall(r'\b[AaEe]\w+',text2)
32/119:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b[AaEe]\w+',text)
re.findall(r'\b[AaEe]\w+',text2)
32/120:
import re
# Input.
text = "The following example creates an ArrayList with a capacity of 50 elements.\
        Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly."

text2 = '''
        Ihr naht euch wieder, schwankende Gestalten,
        Die früh sich einst dem trüben Blick gezeigt.
        Versuch’ ich wohl, euch diesmal festzuhalten?
        Fühl’ ich mein Herz noch jenem Wahn geneigt?
        '''

re.findall(r'\b[AaEe]\w+',text)
# re.findall(r'\b[AaEe]\w+',text2)
36/1:
# ваше решение здесь

myList = list(map(int, input('Введите до 100000 чисел через пробел ').split()))

setFromList = set(myList)

print(len(setFromList))
36/2:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall("\d+\s[а-я]+\s\d{4}", text) # осталось прочитать регулярку по слогам :)
36/3:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall("r\d+\s[а-я]+\s\d{4}", text) # осталось прочитать регулярку по слогам :)
36/4:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall("r\d+\s[а-я]+\s|[\W]", text) # осталось прочитать регулярку по слогам :)
36/5:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall("r\[а-я]+\s|[\W]", text) # осталось прочитать регулярку по слогам :)
36/6:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall("r\[А-ЯЁа-яё]+\s|[\W]", text) # осталось прочитать регулярку по слогам :)
36/7:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall("r\[А-ЯЁа-яё]+", text) # осталось прочитать регулярку по слогам :)
36/8:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall("r\[А-ЯЁа-яё]", text) # осталось прочитать регулярку по слогам :)
36/9:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall("r\[А-ЯЁа-яё]+", text) # осталось прочитать регулярку по слогам :)
36/10:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall(r'\[А-ЯЁа-яё]+'', text) # осталось прочитать регулярку по слогам :)
36/11:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall(r'\[А-ЯЁа-яё]+', text) # осталось прочитать регулярку по слогам :)
36/12:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall(r'\[А-ЯЁа-яё]+\s|[\W]', text) # осталось прочитать регулярку по слогам :)
36/13:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall(r'\[А-ЯЁа-яё]+\s', text) # осталось прочитать регулярку по слогам :)
36/14:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall(r'\b\[А-ЯЁа-яё]\w+', text) # осталось прочитать регулярку по слогам :)
36/15:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall(r'\b[А-ЯЁа-яё]\w+', text) # осталось прочитать регулярку по слогам :)
36/16:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall(r'\b[А-ЯЁа-яё]\w', text) # осталось прочитать регулярку по слогам :)
36/17:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall(r'\b[А-ЯЁа-яё]\w+', text) # осталось прочитать регулярку по слогам :)
36/18:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall(r'\b[А-ЯЁа-яё]|\w+', text) # осталось прочитать регулярку по слогам :)
36/19:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall(r'\b[А-ЯЁа-яё]\w+', text) # осталось прочитать регулярку по слогам :)
36/20:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall(r'\b[А-ЯЁа-яё]+\w+', text) # осталось прочитать регулярку по слогам :)
36/21:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall(r'\b[А-ЯЁа-яё]\w+', text) # осталось прочитать регулярку по слогам :)
36/22:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall(r'\bw+', text) # осталось прочитать регулярку по слогам :)
36/23:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall(r'\b\w+', text) # осталось прочитать регулярку по слогам :)
36/24:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall(r'\b\w+(?:-\w+)+', text) # осталось прочитать регулярку по слогам :)
36/25:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall(r'\b\w+|(?:-\w+)+', text) # осталось прочитать регулярку по слогам :)
36/26:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall(r'\b\w+|\w+(?:-\w+)+', text) # осталось прочитать регулярку по слогам :)
36/27:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
re.findall(r'\b\w+(?:-\w+)+|\w+', text) # осталось прочитать регулярку по слогам :)
36/28:
text = '''
                    - Дельный, что и говорить,
                      Был старик тот самый,
                      Что придумал суп варить
                      На колесах прямо.
                      Суп - во-первых. Во-вторых,
                      Кашу в норме прочной.
                      Нет, старик он был старик
                      Чуткий - это точно.
'''

import re
words = re.findall(r'\b\w+(?:-\w+)+|\w+', text)
len(words)
36/29:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end
36/30:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

print(raw)
36/31:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+(?:\'\w+)', raw)
len(words)
36/32:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+(?:\'\w+)', raw)
print(words)
len(words)
36/33:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+(?:\'\w+)', raw)
print(words)
len(words)

print(raw)
36/34:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+(?:\'\w+)', raw)
print(words)
len(words)

# print(raw)
36/35:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+(?:\'\w+)', raw)
words1 = re.findall(r'\w+\'\w+', raw)
print(words)
len(words)

print(\n)
print(words1)
len(words1)

# print(raw)
36/36:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+(?:\'\w+)', raw)
words1 = re.findall(r'\w+\'\w+', raw)
print(words)
len(words)

print(/n)
print(words1)
len(words1)

# print(raw)
36/37:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+(?:\'\w+)', raw)
words1 = re.findall(r'\w+\'\w+', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/38:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+(?:\'\w+)', raw)
words1 = re.findall(r'\w+'\w+', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/39:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+(?:\'\w+)', raw)
words1 = re.findall(r'\w+\'\w+', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/40:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+(?:\'\w+)', raw)
words1 = re.findall(r'(?=.*\w)^(\w|\')+$', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/41:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+(?:\'\w+)', raw)
words1 = re.findall(r'(/'\w+)|(\w+/'\w+)|(\w+/')|(\w+)', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/42:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w\'\w+|\w\')', raw)
# words1 = re.findall(r'(/'\w+)|(\w+/'\w+)|(\w+/')|(\w+)', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/43:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w\'\w+|\w\')', raw)
# words1 = re.findall(r'(/'\w+)|(\w+/'\w+)|(\w+/')|(\w+)', raw)
print(words)
len(words)

print('\n')
# print(words1)
# len(words1)

# print(raw)
36/44:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\w\'\w+|\w\')', raw)
# words1 = re.findall(r'(/'\w+)|(\w+/'\w+)|(\w+/')|(\w+)', raw)
print(words)
len(words)

print('\n')
# print(words1)
# len(words1)

# print(raw)
36/45:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'(\w\'\w+|\w\')', raw)
# words1 = re.findall(r'(/'\w+)|(\w+/'\w+)|(\w+/')|(\w+)', raw)
print(words)
len(words)

print('\n')
# print(words1)
# len(words1)

# print(raw)
36/46:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+(?:\'\w+)|(\w+')', raw)
# words1 = re.findall(r'/('\w+)|(\w+'\w+)|(\w+')|(\w+)', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/47:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+(?:\'\w+)|(\w+\')', raw)
# words1 = re.findall(r'/('\w+)|(\w+'\w+)|(\w+')|(\w+)', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/48:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+(?:\'\w+)|(\w+\')', raw)
# words1 = re.findall(r'/('\w+)|(\w+'\w+)|(\w+')|(\w+)', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/49:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+(?:\'\w+), raw)
# words1 = re.findall(r'/('\w+)|(\w+'\w+)|(\w+')|(\w+)', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/50:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+(?:\'\w+)'', raw)
# words1 = re.findall(r'/('\w+)|(\w+'\w+)|(\w+')|(\w+)', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/51:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+(?:\'\w+)', raw)
# words1 = re.findall(r'/('\w+)|(\w+'\w+)|(\w+')|(\w+)', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/52:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\w+(?:\'\w+)', raw)
# words1 = re.findall(r'/('\w+)|(\w+'\w+)|(\w+')|(\w+)', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/53:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\w+(?:\'[\w+]}', raw)
# words1 = re.findall(r'/('\w+)|(\w+'\w+)|(\w+')|(\w+)', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/54:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\w+(?:\'\w+}', raw)
# words1 = re.findall(r'/('\w+)|(\w+'\w+)|(\w+')|(\w+)', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/55:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\w+(?:\'\w+}', raw)
# words1 = re.findall(r'/('\w+)|(\w+'\w+)|(\w+')|(\w+)', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/56:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\w+(?:\'\w+', raw)
# words1 = re.findall(r'/('\w+)|(\w+'\w+)|(\w+')|(\w+)', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/57:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\w+(?:\'\w+)', raw)
# words1 = re.findall(r'/('\w+)|(\w+'\w+)|(\w+')|(\w+)', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/58:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\w+(?:\')', raw)
# words1 = re.findall(r'/('\w+)|(\w+'\w+)|(\w+')|(\w+)', raw)
print(words)
len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/59:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
# words = re.findall(r'\w+(?:\'\w+)', raw)
words1 = re.findall(r'\b')', raw)
# print(words)
# len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/60:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
# words = re.findall(r'\w+(?:\'\w+)', raw)
words1 = re.findall(r'\b'', raw)
# print(words)
# len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/61:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
# words = re.findall(r'\w+(?:\'\w+)', raw)
words1 = re.findall(r'\b'', raw)
# print(words)
# len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/62:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
# words = re.findall(r'\w+(?:\'\w+)', raw)
words1 = re.findall(r'\b'\', raw)
# print(words)
# len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/63:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
# words = re.findall(r'\w+(?:\'\w+)', raw)
words1 = re.findall(r'\b\'', raw)
# print(words)
# len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/64:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
# words = re.findall(r'\w+(?:\'\w+)', raw)
words1 = re.findall(r'\b[\'\u2019\u02bc]', raw)
# print(words)
# len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/65:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
# words = re.findall(r'\w+(?:\'\w+)', raw)
words1 = re.findall(r'\b[\'\’\u2019\u02bc]', raw)
# print(words)
# len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/66:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
# words = re.findall(r'\w+(?:\'\w+)', raw)
words1 = re.findall(r'\b[’]', raw)
# print(words)
# len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/67:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
# words = re.findall(r'\w+(?:\'\w+)', raw)
words1 = re.findall(r'\b[\'\’\u2019\u02bc\0027]', raw)
# print(words)
# len(words)

print('\n')
print(words1)
len(words1)

# print(raw)
36/68:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\(\w+[\'\’\u2019\u02b]\w+)', raw)
# words1 = re.findall(r'\b[\'\’\u2019\u02b]', raw)
print(words)
len(words)


# print(raw)
36/69:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\w+[\'\’\u2019\u02b]\w+', raw)
# words1 = re.findall(r'\b[\'\’\u2019\u02b]', raw)
print(words)
len(words)


# print(raw)
36/70:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+[\'\’\u2019\u02b]\w+', raw)
# words1 = re.findall(r'\b[\'\’\u2019\u02b]', raw)
print(words)
len(words)


# print(raw)
36/71:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\b\w+[\'\’\u2019\u02b]\w+', raw)
# words1 = re.findall(r'\b[\'\’\u2019\u02b]', raw)
print(words)
len(words)


# print(raw)
36/72:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'(\w+[\'\’\u2019\u02b]\w+)', raw)
# words1 = re.findall(r'\b[\'\’\u2019\u02b]', raw)
print(words)
len(words)


# print(raw)
36/73:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\w+(?:\[\'\’\u2019\u02b]\w+)', raw)
# words1 = re.findall(r'\b[\'\’\u2019\u02b]', raw)
print(words)
len(words)

print('\n')
# print(words1)
# len(words1)

# print(raw)
36/74:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\w+(?:\'\w+)', raw)
# words1 = re.findall(r'\b[\'\’\u2019\u02b]', raw)
print(words)
len(words)

print('\n')
# print(words1)
# len(words1)

# print(raw)
37/1: re.findall(r'[а-яА-Я]*(?:рыл|Рыл)', "Рыла свинья белорыла, тупорыла; полдвора рылом изрыла, вырыла, подрыла.")
37/2:
import re
re.findall(r'[а-яА-Я]*(?:рыл|Рыл)', "Рыла свинья белорыла, тупорыла; полдвора рылом изрыла, вырыла, подрыла.")
37/3:
import re
re.findall(r'[а-яА-Я]*(рыл|Рыл)', "Рыла свинья белорыла, тупорыла; полдвора рылом изрыла, вырыла, подрыла.")
37/4:
import re
re.findall(r'[а-яА-Я]*(?рыл|Рыл)', "Рыла свинья белорыла, тупорыла; полдвора рылом изрыла, вырыла, подрыла.")
37/5:
import re
re.findall(r'[а-яА-Я]*(?:рыл|Рыл)', "Рыла свинья белорыла, тупорыла; полдвора рылом изрыла, вырыла, подрыла.")
37/6: re.findall(r'[а-яА-Я]*(?:рыл|Рыл)[а-яА-Я]*', "Рыла свинья белорыла, тупорыла; полдвора рылом изрыла, вырыла, подрыла.")
37/7: re.findall(r'[а-яА-Я]*(?:рыл|Рыл)[а-яА-Я]*', "Рыла свинья белорыла, тупорыла; полдвора рылом изрыла, вырыла, подрыла.")
37/8: re.findall(r'[а-яА-Я]*(рыл|Рыл)[а-яА-Я]*', "Рыла свинья белорыла, тупорыла; полдвора рылом изрыла, вырыла, подрыла.")
37/9: re.findall(r'[а-яА-Я]*(?:рыл|Рыл)[а-яА-Я]*', "Рыла свинья белорыла, тупорыла; полдвора рылом изрыла, вырыла, подрыла.")
36/75:
import re
import requests

the_idiot_url = 'https://www.gutenberg.org/files/2638/2638-0.txt'
raw = requests.get(the_idiot_url).text

# Индекс начала первой главы
start = re.search(r'PART I', raw).start()
# Индекс конца первой главы
end = re.search(r'he determined to take a droshky.', raw).end()
start, end

# print(raw)

import re
words = re.findall(r'\w+(?:\'\w+)', raw)
# words1 = re.findall(r'\b[\'\’\u2019\u02b]', raw)
print(words)
len(words)
# print(raw)
38/1:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.findall(r'\d{2}:\d{2}|d{2}:\d{2}:\d{2}', raw)
print(words)
len(words)
38/2:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.findall(r'\d{2}:\d{2}|d{2}:\d{2}:\d{2}', inp)
print(words)
38/3:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.findall(r'd{2}:\d{2}:\d{2}|\d{2}:\d{2}', inp)
print(words)
38/4:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.findall(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', inp)
print(words)
38/5:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.findall(r'\d{2}:\d{2}|[:\d{2}]', inp)
print(words)
38/6:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.findall(r'\d{2}:\d{2}|[?:\d{2}]', inp)
print(words)
38/7:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.findall(r'\d{2}:\d{2}|(?:\d{2})', inp)
print(words)
38/8:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.findall(r'\d{2}:\d{2}[:\d{2}]|\d{2}:\d{2}', inp)
print(words)
38/9:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.findall(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', inp)
print(words)
38/10:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.split(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', inp)
print(words)
38/11:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.findall(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', inp)
print(words)
38/12:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.split(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', inp)
print(words)
38/13:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.split(r'\b\d{2}:\d{2}:\d{2}|\b\d{2}:\d{2}', inp)
print(words)
38/14:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.split(r'\b\d{2}:\d{2}:\d{2}\b|\d{2}:\d{2}', inp)
print(words)
38/15:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.split(r'\d{2}:\d{2}:\d{2}\b|\d{2}:\d{2}', inp)
print(words)
38/16:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.split(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', inp)
print(words)
38/17:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', '(TBD)', inp)
print(words)
38/18:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}',
               lambda m: str(int(m.group(2)) + int(m.group(3))), inp)
#                '(TBD)', inp)
print(words)
38/19:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}',lambda m: str(int(m.group(2)) + int(m.group(3))), inp)
#                '(TBD)', inp)
print(words)
38/20:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', lambda m: str(int(m.group(2)) + int(m.group(3))), inp)
#                '(TBD)', inp)
print(words)
38/21:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', ambda match: "{0} as and {1} bs ".format(
    len(match.group(1)), len(match.group(2))
), inp)
#                '(TBD)', inp)
print(words)
38/22:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', lambda match: "{0} as and {1} bs ".format(
    len(match.group(1)), len(match.group(2))
), inp)
#                '(TBD)', inp)
print(words)
38/23:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', lambda x: x, inp)
#                '(TBD)', inp)
print(words)
38/24:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', lambda x: str(x), inp)
#                '(TBD)', inp)
print(words)
38/25:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', lambda match: str(match.group(0)), inp)
#                '(TBD)', inp)
print(words)
38/26:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', lambda match: str(match.group(1)), inp)
#                '(TBD)', inp)
print(words)
38/27:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', lambda match: str(match.group(0)), inp)
#                '(TBD)', inp)
print(words)
38/28:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', lambda match:
               print(match.group(0)
               str(match.group(0)), inp)
#                '(TBD)', inp)
print(words)
38/29:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', lambda match:
               print(match.group(0))
               str(match.group(0)), inp)
#                '(TBD)', inp)
print(words)
38/30:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', lambda match:
               print(match.group(0)
               str(match.group(0), inp)
#                '(TBD)', inp)
print(words)
38/31:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
mrep = lambda match: str(match.group(0)
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', mrep, inp)
#                '(TBD)', inp)
print(words)
38/32:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def multiply(m):
    # Convert group 0 to an integer.
    v = int(m.group(0))
    # Multiply integer by 2.
    # ... Convert back into string and return it.
    return str(v * 2)
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', multiply, inp)

print(words)
38/33:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def multiply(m):
    # Convert group 0 to an integer.
    v = int(m.group(0))
    # Multiply integer by 2.
    # ... Convert back into string and return it.
    return str(v)
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', multiply, inp)

print(words)
38/34:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def multiply(m):
    # Convert group 0 to an integer.
    v = m.group(0)
    # Multiply integer by 2.
    # ... Convert back into string and return it.
    return str(v)
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', multiply, inp)

print(words)
38/35:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def replaceDate(m):
    parts = m.group(0).split(':')
    print(parts)
    return str(m.group(0))
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', replaceDate, inp)

print(words)
38/36:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def replaceDate(m):
    parts = m.group(0).split(':')
    hour, minute, sec = parts
    print(hour, minute, sec)
#     if(parts)
    return str(m.group(0))
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', replaceDate, inp)

print(words)
38/37:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def replaceDate(m):
    parts = m.group(0).split(':')
    if len(parts === 2):
        hour, minute = parts
    else:
        hour, minute, sec = parts
        print(hour, minute, sec)
#     if(parts)
    return str(m.group(0))
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', replaceDate, inp)

print(words)
38/38:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def replaceDate(m):
    parts = m.group(0).split(':')
    if len(parts) === 2:
        hour, minute = parts
    else:
        hour, minute, sec = parts
        print(hour, minute, sec)
#     if(parts)
    return str(m.group(0))
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', replaceDate, inp)

print(words)
38/39:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def replaceDate(m):
    parts = m.group(0).split(':')
    if len(parts) == 2:
        hour, minute = parts
    else:
        hour, minute, sec = parts
        print(hour, minute, sec)
#     if(parts)
    return str(m.group(0))
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', replaceDate, inp)

print(words)
38/40:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def replaceDate(m):
    parts = map(int, m.group(0).split(':'))
    if len(parts) == 2:
        hour, minute = parts
        if(hour>)
    else:
        hour, minute, sec = parts
        print(hour, minute, sec)
#     if(parts)
    return str(m.group(0))
words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', replaceDate, inp)

print(words)
38/41:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def replaceDate(m):
    parts = map(int, m.group(0).split(':'))
    if len(parts) == 2:
        hour, minute = parts
        if(hour>=0 && minute>=0
          hour<24 && minute<60
          )
        return '(TBD)'
        else:
            return m.group(0)
    else:
        hour, minute, sec = parts
        if(hour>=0 && minute>=0 && sec>=0
          hour<24 && minute<60 && sec<60
          )
        return '(TBD)'
        else:
            return m.group(0)

words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', replaceDate, inp)

print(words)
38/42:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def replaceDate(m):
    parts = map(int, m.group(0).split(':'))
    if len(parts) == 2:
        hour, minute = parts
        if(hour>=0 and minute>=0
          hour<24 and minute<60
          )
        return '(TBD)'
        else:
            return m.group(0)
    else:
        hour, minute, sec = parts
        if(hour>=0 and minute>=0 and sec>=0
          hour<24 and minute<60 and sec<60
          )
        return '(TBD)'
        else:
            return m.group(0)

words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', replaceDate, inp)

print(words)
38/43:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def replaceDate(m):
    parts = map(int, m.group(0).split(':'))
    if len(parts) == 2:
        hour, minute = parts
        if(hour>=0 and minute>=0 and
          hour<24 and minute<60
          )
        return '(TBD)'
        else:
            return m.group(0)
    else:
        hour, minute, sec = parts
        if(hour>=0 and minute>=0 and sec>=0 and
          hour<24 and minute<60 and sec<60
          )
        return '(TBD)'
        else:
            return m.group(0)

words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', replaceDate, inp)

print(words)
38/44:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def replaceDate(m):
    parts = map(int, m.group(0).split(':'))
    if len(parts) == 2:
        hour, minute = parts
        if(hour>=0 and minute>=0 and
          hour<24 and minute<60)
            return '(TBD)'
        else:
            return m.group(0)
    else:
        hour, minute, sec = parts
        if(hour>=0 and minute>=0 and sec>=0 and
          hour<24 and minute<60 and sec<60)
            return '(TBD)'
        else:
            return m.group(0)

words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', replaceDate, inp)

print(words)
38/45:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def replaceDate(m):
    parts = map(int, m.group(0).split(':'))
    if len(parts) == 2:
        hour, minute = parts
        if hour>=0 and minute>=0 and
          hour<24 and minute<60:
            return '(TBD)'
        else:
            return m.group(0)
    else:
        hour, minute, sec = parts
        if hour>=0 and minute>=0 and sec>=0 and
          hour<24 and minute<60 and sec<60:
            return '(TBD)'
        else:
            return m.group(0)

words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', replaceDate, inp)

print(words)
38/46:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def replaceDate(m):
    parts = map(int, m.group(0).split(':'))
    if len(parts) == 2:
        hour, minute = parts
        if hour>=0 and minute>=0 and hour<24 and minute<60:
            return '(TBD)'
        else:
            return m.group(0)
    else:
        hour, minute, sec = parts
        if hour>=0 and minute>=0 and sec>=0 and hour<24 and minute<60 and sec<60:
            return '(TBD)'
        else:
            return m.group(0)

words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', replaceDate, inp)

print(words)
38/47:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def replaceDate(m):
    parts = m.group(0).split(':')
    if len(parts) == 2:
        hour, minute = parts
        if hour>=0 and minute>=0 and hour<24 and minute<60:
            return '(TBD)'
        else:
            return m.group(0)
    else:
        hour, minute, sec = parts
        if hour>=0 and minute>=0 and sec>=0 and hour<24 and minute<60 and sec<60:
            return '(TBD)'
        else:
            return m.group(0)

words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', replaceDate, inp)

print(words)
38/48:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def replaceDate(m):
    parts = m.group(0).split(':')
    if len(parts) == 2:
        hour, minute = map(int, parts)
        if hour>=0 and minute>=0 and hour<24 and minute<60:
            return '(TBD)'
        else:
            return m.group(0)
    else:
        hour, minute, sec = map(int, parts)
        if hour>=0 and minute>=0 and sec>=0 and hour<24 and minute<60 and sec<60:
            return '(TBD)'
        else:
            return m.group(0)

words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', replaceDate, inp)

print(words)
38/49:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def replaceDate(m):
    parts = m.group(0).split(':')
    if len(parts) == 2:
        hour, minute = map(int, parts)
        if hour>=0 and minute>=0
        and hour<24 and minute<60:
            return '(TBD)'
        else:
            return m.group(0)
    else:
        hour, minute, sec = map(int, parts)
        if hour>=0 and minute>=0 and sec>=0 and hour<24 and minute<60 and sec<60:
            return '(TBD)'
        else:
            return m.group(0)

words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', replaceDate, inp)

print(words)
38/50:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def replaceDate(m):
    parts = m.group(0).split(':')
    if len(parts) == 2:
        hour, minute = map(int, parts)
        if hour>=0 and minute>=0
            and hour<24 and minute<60:
            return '(TBD)'
        else:
            return m.group(0)
    else:
        hour, minute, sec = map(int, parts)
        if hour>=0 and minute>=0 and sec>=0 and hour<24 and minute<60 and sec<60:
            return '(TBD)'
        else:
            return m.group(0)

words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', replaceDate, inp)

print(words)
38/51:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def replaceDate(m):
    parts = m.group(0).split(':')
    if len(parts) == 2:
        hour, minute = map(int, parts)
        if hour>=0 and minute>=0 and hour<24 and minute<60:
            return '(TBD)'
        else:
            return m.group(0)
    else:
        hour, minute, sec = map(int, parts)
        if hour>=0 and minute>=0 and sec>=0 and hour<24 and minute<60 and sec<60:
            return '(TBD)'
        else:
            return m.group(0)

words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', replaceDate, inp)

print(words)
38/52:
import re
def confuseNumbers(m):
    parts = m.group(0).split(':')
    if len(parts) == 2:
        hour, minute = map(int, parts)
        if hour>=0 and minute>=0 and hour<24 and minute<60:
            return '(TBD)'
        else:
            return m.group(0)
    else:
        hour, minute, sec = map(int, parts)
        if hour>=0 and minute>=0 and sec>=0 and hour<24 and minute<60 and sec<60:
            return '(TBD)'
        else:
            return m.group(0)

text = str(input())
words = re.sub(r'\d+.\d+|\d', confuseNumbers, text)

print(words)
38/53:
import re
def confuseNumbers(m):
    parts = m.group(0).split(':')
    if len(parts) == 2:
        hour, minute = map(int, parts)
        if hour>=0 and minute>=0 and hour<24 and minute<60:
            return '(TBD)'
        else:
            return m.group(0)
    else:
        hour, minute, sec = map(int, parts)
        if hour>=0 and minute>=0 and sec>=0 and hour<24 and minute<60 and sec<60:
            return '(TBD)'
        else:
            return m.group(0)

text = str(input())
# words = re.sub(r'\d+.\d+|\d+', confuseNumbers, text)
words = re.findall(r'\d+.\d+|\d+', text)
print(words)
38/54:
import re
def confuseNumbers(m):
    parts = m.group(0).split('.')
    if len(parts) == 2:
        whole, decimal = map(int, parts)
        return str(f'{whole**2}.{decimal**2}')
    else:
        whole = map(int, parts)
        return str(f'{whole**2})

text = str(input())
words = re.sub(r'\d+.\d+|\d+', confuseNumbers, text)

print(words)
38/55:
import re
def confuseNumbers(m):
    parts = m.group(0).split('.')
    if len(parts) == 2:
        whole, decimal = map(int, parts)
        return str(f'{whole**2}.{decimal**2}')
    else:
        whole = map(int, parts)
        return str(f'{whole**2}'')

text = str(input())
words = re.sub(r'\d+.\d+|\d+', confuseNumbers, text)

print(words)
38/56:
import re
def confuseNumbers(m):
    parts = m.group(0).split('.')
    if len(parts) == 2:
        whole, decimal = map(int, parts)
        return str(f'{whole**2}.{decimal**2}')
    else:
        whole = map(int, parts)
        return str(f'{whole**2}')

text = str(input())
words = re.sub(r'\d+.\d+|\d+', confuseNumbers, text)

print(words)
38/57:
import re
def confuseNumbers(m):
    parts = m.group(0).split('.')
    if len(parts) == 2:
        whole, decimal = map(int, parts)
        print(whole)
        print(type(whole))
        return 'er'
#         return str(f'{whole**2}.{decimal**2}')
    else:
        whole = map(int, parts)
        return 'sf'
#         return str(f'{whole**2}')

text = str(input())
words = re.sub(r'\d+.\d+|\d+', confuseNumbers, text)

print(words)
38/58:
import re
def confuseNumbers(m):
    parts = m.group(0).split('.')
    if len(parts) == 2:
        whole, decimal = map(int, parts)
        print(whole)
        print(type(whole))
        return 'er'
#         return str(f'{whole**2}.{decimal**2}')
    else:
        whole = map(int, parts)
        return 'sf'
#         return str(f'{whole**2}')

text = str(input())
words = re.sub(r'\d+.\d+|\d+', confuseNumbers, text)

print(words)
38/59:
import re
def confuseNumbers(m):
    parts = m.group(0).split('.')
    if len(parts) == 2:
        whole, decimal = map(int, parts)
        print(whole)
        print(type(whole))
        return str(f'{whole**2}.{decimal**2}')
    else:
        whole = map(int, parts)
        return 'sf'
#         return str(f'{whole**2}')

text = str(input())
words = re.sub(r'\d+.\d+|\d+', confuseNumbers, text)

print(words)
38/60:
import re
def confuseNumbers(m):
    parts = m.group(0).split('.')
    if len(parts) == 2:
        whole, decimal = map(int, parts)
        return str(f'{whole**2}.{decimal**2}')
    else:
        whole = map(int, parts)
        return 'sf'
#         return str(f'{whole**2}')

text = str(input())
words = re.sub(r'\d+.\d+|\d+', confuseNumbers, text)

print(words)
38/61:
import re
def confuseNumbers(m):
    parts = m.group(0).split('.')
    if len(parts) == 2:
        whole, decimal = map(int, parts)
        return str(f'{whole**2}.{decimal**2}')
    else:
        whole = map(int, parts)
        return str(f'{whole**2}')

text = str(input())
words = re.sub(r'\d+.\d+|\d+', confuseNumbers, text)

print(words)
38/62:
import re
def confuseNumbers(m):
    parts = m.group(0).split('.')
    if len(parts) == 2:
        whole, decimal = map(int, parts)
        return str(f'{whole**2}.{decimal**2}')
    else:
        whole = int(parts[0])
        return str(f'{whole**2}')

text = str(input())
words = re.sub(r'\d+.\d+|\d+', confuseNumbers, text)

print(words)
38/63:
import re
def confuseNumbers(m):
    parts = m.group(0).split('.')
    if len(parts) == 2:
        whole, decimal = map(int, parts)
        return str(f'{whole**3}.{decimal**3}')
    else:
        whole = int(parts[0])
        return str(f'{whole**3}')

text = str(input())
words = re.sub(r'\d+.\d+|\d+', confuseNumbers, text)

print(words)
38/64:
inp = """Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!"""

import re
def replaceDate(m):
    parts = m.group(0).split(':')
    if len(parts) == 2:
        hour, minute = map(int, parts)
        if hour>=0 and minute>=0 and hour<24 and minute<60:
            return '(TBD)'
        else:
            return m.group(0)
    else:
        hour, minute, sec = map(int, parts)
        if hour>=0 and minute>=0 and sec>=0 and hour<24 and minute<60 and sec<60:
            return '(TBD)'
        else:
            return m.group(0)

words = re.sub(r'\d{2}:\d{2}:\d{2}|\d{2}:\d{2}', replaceDate, inp)

print(words)
38/65:
import re
def confuseNumbers(m):
    parts = m.group(0).split('.')
    if len(parts) == 2:
        whole, decimal = map(int, parts)
        return str(f'{whole**3}.{decimal**3}')
    else:
        whole = int(parts[0])
        return str(f'{whole**3}')

text = str(input())
words = re.sub(r'\d+.\d+|\d+', confuseNumbers, text)

print(words)
43/1:
text = "Комитет Государственной Безопасности"

#Решение
import re
letters = text.split()
capital_letters = [lt for lt in letters if re.match(r'[А-ЯA-Z]', lt)]

print(capital_letters)
43/2:
text = "Комитет Государственной Безопасности"

#Решение
import re
letters = text.split()
capital_letters = [lt for lt in letters if re.match(r'[А-ЯA-Z]', lt)]
print(letters)
print(capital_letters)
43/3:
text = "Комитет Государственной Безопасности"

#Решение
import re
letters = text.split()
capital_letters = [lt for lt in text if re.match(r'[А-ЯA-Z]', lt)]
print(letters)
print(capital_letters)
43/4:
text = "Комитет Государственной Безопасности"

#Решение
import re
capital_letters = [lt for lt in text if re.match(r'[А-ЯA-Z]', lt)]
s = s.join(capital_letters)
print(s)
43/5:
text = "Комитет Государственной Безопасности"

#Решение
import re
capital_letters = [lt for lt in text if re.match(r'[А-ЯA-Z]', lt)]
s = ''.join(capital_letters)
print(s)
43/6:
numb = int(input())

i = 1
for i in range(10, 0, -1):
    print(i)
43/7:
numb = int(input())

i = 1
for i in range(numb, 0, -1):
    print(i, end =" ")
43/8:
numb = int(input())

i = 1
while i <= numb
    for j in range(i, 0, 1):
        print(i, end =" ")
    i += 1
43/9:
numb = int(input())

i = 1
while i <= numb:
    for j in range(i, 0, 1):
        print(i, end =" ")
    i += 1
43/10:
numb = int(input())

i = 1
while i <= numb:
    for j in range(i, 0, 1):
        print(j, end =" ")
    i += 1
43/11:
numb = int(input())

i = 1
while i <= numb:
    for j in range(i):
        print(j, end =" ")
    i += 1
43/12:
numb = int(input())

i = 1
while i <= numb:
    for j in range(i):
        print(j, end =" ")
    print('\n')
    i += 1
43/13:
numb = int(input())

i = 1
while i <= numb:
    for j in range(1, i):
        print(j, end =" ")
    print('\n')
    i += 1
43/14:
numb = int(input())

i = 1
while i <= numb:
    for j in range(1, i):
        print(j, end =" ")
    print('\n')
    i += 1
43/15:
import re
АБАЖУР, АБАЗИНСКИЙ, АБАЗИНЫ

text_1 = str(input())
43/16:
import re
# АБАЖУР, АБАЗИНСКИЙ, АБАЗИНЫ

text_1 = str(input())
43/17:
import re
# АБАЖУР, АБАЗИНСКИЙ, АБАЗИНЫ

text_1 = str(input())
changed_text = [re.ыги(r'[АаAa]', '#', lt) for lt in text_1]
43/18:
import re
# АБАЖУР, АБАЗИНСКИЙ, АБАЗИНЫ

text_1 = str(input())
changed_text = [re.sub(r'[АаAa]', '#', lt) for lt in text_1]
43/19:
import re
# АБАЖУР, АБАЗИНСКИЙ, АБАЗИНЫ

text_1 = str(input())
changed_text = [re.sub(r'[АаAa]', '#', lt) for lt in text_1]

print(changed_text)
43/20:
import re
# АБАЖУР, АБАЗИНСКИЙ, АБАЗИНЫ

text_1 = str(input())
changed_list = [re.sub(r'[АаAa]', '#', lt) for lt in text_1]
changes_text = ''.join(changed_list)
print(changed_list)
43/21:
import re
# АБАЖУР, АБАЗИНСКИЙ, АБАЗИНЫ

text_1 = str(input())
changed_list = [re.sub(r'[АаAa]', '#', lt) for lt in text_1]
changes_text = ''.join(changed_list)
print(changes_text)
43/22:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
43/23:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())

def fibonaci(n):
    f_list = []
    x, y = 0, 1
    while y < numb:
        x, y = y, x+y
        f_list.append(x)
    print(f_list)
43/24:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())

def fibonaci(n):
    f_list = []
    x, y = 0, 1
    while y < numb:
        x, y = y, x+y
        f_list.append(x)
    print(f_list)

        
fibonaci(numb)
43/25:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())

def fibonaci(n):
    f_list = []
    x, y = 0, 1
    while y < numb:
        x, y = y, x+y
        print(x, y)
        f_list.append(x)
    print(f_list)

        
fibonaci(numb)
43/26:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
    
    if n == 0:
        f_list.append(1)
    elif n == 1:
        f_list.append(1)
    else:
        f_list.append(fibonaci(n-1) + fibonacci(n))
        n -= 1

        
fibonaci(numb)
43/27:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
    if n == 0:
        f_list.append(1)
    elif n == 1:
        f_list.append(1)
    else:
        f_list.append(fibonaci(n-1) + fibonacci(n))
        n -= 1

        
fibonaci(numb)
43/28:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
    if n == 0:
        f_list.append(1)
    elif n == 1:
        f_list.append(1)
    else:
        f_list.append(fibonaci(n-1) + fibonaci(n))
        n -= 1

        
fibonaci(numb)
43/29:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
    if n == 0:
        f_list.append(1)
    elif n == 1:
        f_list.append(1)
    else:
        print(fibonaci(n-1) + fibonaci(n))
        n -= 1

        
fibonaci(numb)
43/30:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
    if n == 0:
        f_list.append(1)
    elif n == 1:
        f_list.append(1)
    else:
        f_list.append(2)
#         print(fibonaci(n-1) + fibonaci(n))
        n -= 1

        
fibonaci(numb)
43/31:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
    if n == 0:
        f_list.append(1)
    elif n == 1:
        f_list.append(1)
    else:
        f_list.append(2)
#         print(fibonaci(n-1) + fibonaci(n))
        n -= 1
    print(f_list)

        
fibonaci(numb)
43/32:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
    if n == 0:
        f_list.append(1)
    elif n == 1:
        f_list.append(1)
    else:
#         f_list.append(2)
        print(fibonaci(n-1) + fibonaci(n))
        n -= 1
    print(f_list)

        
fibonaci(numb)
43/33:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
    if n == 0:
        f_list.append(1)
        return
    elif n == 1:
        f_list.append(1)
        return
    else:
#         f_list.append(2)
        print(fibonaci(n-1) + fibonaci(n))
        n -= 1
    print(f_list)

        
fibonaci(numb)
43/34:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
    if n == 0:
        f_list.append(1)
        return
    elif n == 1:
        f_list.append(1)
        return
    else:
#         f_list.append(2)
        print(fibonaci(n-1) + fibonaci(n))
        n -= 1
        return
    print(f_list)

        
fibonaci(numb)
43/35:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
    if n == 0:
        f_list.append(1)
        return
    elif n == 1:
        f_list.append(1)
        return
    else:
        f_list.append(2)
#         print(fibonaci(n-1) + fibonaci(n))
        n -= 1
        return
    print(f_list)

        
fibonaci(numb)
43/36:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
   if n <= 1:
       return n
   else:
       return(fibonaci(n-1) + fibonaci(n-2))

        
fibonaci(numb)
43/37:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
   if n <= 1:
       f_list.append(n)
#        return n
   else:
        f_list.append(fibonaci(n-1) + fibonaci(n-2))
       return(fibonaci(n-1) + fibonaci(n-2))

        
fibonaci(numb)
43/39:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
   if n <= 1:
       f_list.append(n)
#        return n
   else:
        f_list.append(fibonaci(n-1) + fibonaci(n-2))
#        return(fibonaci(n-1) + fibonaci(n-2))

        
fibonaci(numb)
43/40:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
   if n <= 1:
       return n
   else:
       return(fibonaci(n-1) + fibonaci(n-2))


for _ in range(numb)
    f_list.append(fibonaci(numb))
43/41:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
   if n <= 1:
       return n
   else:
       return(fibonaci(n-1) + fibonaci(n-2))


for _ in range(numb):
    f_list.append(fibonaci(numb))
43/42:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
   if n <= 1:
       return n
   else:
       return(fibonaci(n-1) + fibonaci(n-2))


for _ in range(numb):
    f_list.append(fibonaci(numb))
        
print(f_list)
43/43:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
   if n <= 1:
       return n
   else:
       return(fibonaci(n-1) + fibonaci(n-2))


for _ in range(numb):
    f_list.append(fibonaci(numb))
        
print(f_list)
43/44:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
   if n <= 1:
       return n
   else:
       return(fibonaci(n-1) + fibonaci(n-2))


for i in range(numb):
    f_list.append(fibonaci(i))
        
print(f_list)
43/45:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
   if n <= 1:
       return n
   else:
       return(fibonaci(n-1) + fibonaci(n-2))


for i in range(1б numb):
    f_list.append(fibonaci(i))
        
print(f_list)
43/46:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
   if n <= 1:
       return n
   else:
       return(fibonaci(n-1) + fibonaci(n-2))


for i in range(1, numb):
    f_list.append(fibonaci(i))
        
print(f_list)
43/47:
numb = int(input())

i = 1
while i <= numb:
    for j in range(1, i):
        print(j, end =" ")
    print('\n')
    i += 1
43/48:
numb = int(input())

i = 1
while i <= numb:
    for j in range(i):
        print(j, end =" ")
    print('\n')
    i += 1
43/49:
numb = int(input())

i = 0
while i <= numb:
    for j in range(i):
        print(j, end =" ")
    print('\n')
    i += 1
43/50:
numb = int(input())

i = 1
while i <= numb:
    for j in range(i):
        print(j, end =" ")
    print('\n')
    i += 1
43/51:
numb = int(input())

i = 0
while i <= numb:
    for j in range(i):
        print(j, end =" ")
    print('\n')
    i += 1
46/1:
numb = int(input())

i = 0
while i <= numb + 1:
    for j in range(1, i+1):
        print(j, end =" ")
    print('\n')
    i += 1
46/2:
numb = int(input())

i = 0
while i <= numb + 1:
    for j in range(1, i):
        print(j, end =" ")
    print('\n')
    i += 1
46/3:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
   if n <= 1:
       return n
   else:
       return(fibonaci(n-1) + fibonaci(n-2))


for i in range(1, numb):
    f_list.append(fibonaci(i))
        
print(f_list)
46/4:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
   if n <= 1:
       return n
   else:
       return(fibonaci(n-1) + fibonaci(n-2))


for i in range(1, numb +1):
    f_list.append(fibonaci(i))
        
print(f_list)
46/5:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
   if n <= 1:
       return 1
   else:
       return(fibonaci(n-1) + fibonaci(n-2))


for i in range(1, numb):
    f_list.append(fibonaci(i))
        
print(f_list)
46/6:
# Сколько чисел Фибоначчи нужно сгенерировать? 15
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

print('Сколько чисел Фибоначчи нужно сгенерировать?')
numb = int(input())
f_list = []

def fibonaci(n):
   if n <= 1:
       return 1
   else:
       return(fibonaci(n-1) + fibonaci(n-2))


for i in range(numb):
    f_list.append(fibonaci(i))
        
print(f_list)
49/1:
with open('mbox.txt') as f:
    for line in f:
        if line.startswith('Date: '):
            print(line)
51/1:
s = '[]()[[[[(((())))]]]]{{[()]}}'

def check_seq(s):
    ls = s.split()
    print(ls)

check_seq(s)
51/2:
s = '[]()[[[[(((())))]]]]{{[()]}}'

def check_seq(s):
    ls = s.split('')
    print(ls)

check_seq(s)
51/3:
s = '[]()[[[[(((())))]]]]{{[()]}}'

def check_seq(s):
    ls = s.split()
    print(ls)

check_seq(s)
51/4:
s = '[]()[[[[(((())))]]]]{{[()]}}'

def check_seq(string):
    ls = [lt for lt in string]
    print(ls)

check_seq(s)
51/5:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
ls.append(s[0])
def check_seq(string):
#     ls = [lt for lt in string]
    

print(ls)
    check_seq(s)
51/6:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
ls.append(s[0])
def check_seq(string):
#     ls = [lt for lt in string]
    

print(ls)
check_seq(s)
51/7:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
ls.append(s[0])
# def check_seq(string):
#     ls = [lt for lt in string]
    

print(ls)
check_seq(s)
51/8:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ : :-1]:
    print(element)
    

# print(ls)
check_seq(s)
51/9:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ : :-1]:
        print(element)
    

# print(ls)
check_seq(s)
51/10:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        print(element)
    

# print(ls)
check_seq(s)
51/11:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict[element]:
            print(element)
        else:
            print(11)
    

# print(ls)
check_seq(s)
51/12:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element:
            print(element)
        else:
            print(11)
    

# print(ls)
check_seq(s)
51/13:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element):
            print(element)
        else:
            print(11)
    

# print(ls)
check_seq(s)
51/14:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element):
            ls.pop()
        else:
            ls.append(element)
    

# print(ls)
check_seq(s)
51/15:
s = '[]()'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element):
            ls.pop()
        else:
            ls.append(element)
    

# print(ls)
check_seq(s)
51/16:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element):
            ls.pop()
        elif:
            ls.append(element)
        else:
            print(ls)
    

# print(ls)
check_seq(s)
51/17:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element):
            ls.pop()
        elif:
            ls.append(element)
        else:
            print(ls)
    

# print(ls)
check_seq(s)
51/18:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element):
            ls.pop()
        elif:
            ls.append(element)
        else:
            print(ls)
    

# print(ls)
check_seq(s)
51/19:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element):
            ls.pop()
        elif:
            ls.append(element)
        else:
            print(ls)
    

# print(ls)
check_seq(s)
51/20:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element):
            ls.pop()
        elif len(ls) == 0:
            print(ls)
        else:
             ls.append(element)
    

# print(ls)
check_seq(s)
51/21:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        
        if dict.get(element):
            ls.pop()
        elif len(ls) == 0:
            print(ls)
        else:
             ls.append(element)
    

# print(ls)
check_seq(s)
51/22:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        print(ls)
        if dict.get(element):
            ls.pop()
        elif len(ls) == 0:
            print(ls)
        else:
             ls.append(element)
    

# print(ls)
check_seq(s)
51/23:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        print(ls)
        if dict.get(element) and ls[len(ls) - 1] == element:
            ls.pop()
        elif len(ls) == 0:
            print(ls)
        else:
             ls.append(element)
    

# print(ls)
check_seq(s)
51/24:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element) and ls[len(ls) - 1] == element:
            ls.pop()
        elif len(ls) == 0:
            print(ls)
        else:
             ls.append(element)
    

# print(ls)
check_seq(s)
51/25:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element) and ls[len(ls) - 1] == element:
            ls.pop()
        elif len(ls) == 0:
            print(ls)
        else:
             ls.append(element)

    

 print(ls)
check_seq(s)
51/27:
s = '[]()[[[[(((())))]]]]{{[()]}}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element) and ls[len(ls) - 1] == element:
            ls.pop()
        elif len(ls) == 0:
            print(ls)
        else:
             ls.append(element)

    

print(ls)
check_seq(s)
51/28:
s = '['
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element) and ls[len(ls) - 1] == element:
            ls.pop()
        elif len(ls) == 0:
            print(ls)
        else:
             ls.append(element)

    

print(ls)
check_seq(s)
51/29:
s = '[}'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element) and ls[len(ls) - 1] == element:
            ls.pop()
        elif len(ls) == 0:
            print(ls)
        else:
             ls.append(element)

    

print(ls)
check_seq(s)
51/30:
s = '[]'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element) and ls[len(ls) - 1] == element:
            ls.pop()
        elif len(ls) == 0:
            print(ls)
        else:
             ls.append(element)

    

print(ls)
check_seq(s)
51/31:
s = '[]'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element) and ls[0] == element:
            ls.pop()
        elif len(ls) == 0:
            print(ls)
        else:
             ls.append(element)

    

print(ls)
check_seq(s)
51/32:
s = '[]'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element) and ls[0] == element:
            ls.pop()
        elif len(ls) == 0:
            print('one')
        else:
             ls.append(element)

    

print(ls)
check_seq(s)
51/33:
s = '[]'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element) and ls[-1] == element:
            ls.pop()
        elif len(ls) == 0:
            print('one')
        else:
             ls.append(element)

    

print(ls)
check_seq(s)
51/34:
s = '[]()'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element) and ls[-1] == element:
            ls.pop()
        elif len(ls) == 0:
            print('one')
        else:
             ls.append(element)

    

print(ls)
check_seq(s)
51/35:
s = '[(())]'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element) and ls[-1] == element:
            ls.pop()
        elif len(ls) == 0:
            print('one')
        else:
             ls.append(element)

    

print(ls)
check_seq(s)
51/36: from bs4 import BeautifulSoup  # не спрашивайте, почему BeautifulSoup
51/37: soup = BeautifulSoup(page.text, 'lxml')
51/38: import requests
51/39:
url = 'https://nplus1.ru/' # сохраняем
page = requests.get(url) # загружаем страницу по ссылке
51/40: soup = BeautifulSoup(page.text, 'lxml')
51/41: soup
51/42: print(soup.prettify())
51/43:
for link in soup.find_all('a'):
    print(link.get('href'))
51/44:
urls = []

for link in soup.find_all('a'):
    if '/news' in link.get('href'):
        urls.append(link.get('href'))
urls
51/45:
full_urls = []

for u in urls:
    res = 'https://nplus1.ru' + u
    full_urls.append(res) 

full_urls
51/46:
url0 = full_urls[1]

page0 = requests.get(url0)
soup0 = BeautifulSoup(page0.text, 'lxml')
51/47: soup0.find_all('meta')
51/48: soup0.find_all('meta', {'name' : 'author'}) # например, автор
51/49: soup0.find_all('meta', {'name' : 'author'})[0]
51/50: soup0.find_all('meta', {'name' : 'author'})[0].attrs
51/51:
url0 = full_urls[1]

page0 = requests.get(url0)
soup0 = BeautifulSoup(page0.text, 'lxml')
51/52:
date = soup0.find_all('meta', {'itemprop' : 'datePublished'})[0].attrs['content']
title = soup0.find_all('meta', {'property' : 'og:title'})[0].attrs['content']
description = soup0.find_all('meta', {'name' : 'description'})[0].attrs['content']
51/53: soup0.find_all('p')
51/54:
def GetNews(url0):
    """
    Returns a tuple with url0, date, author, description, title, final_text, rubrics, diff.
    Parameters:
    
    url0 is a link to the news (string)
    """
    page0 = requests.get(url0)
    soup0 = BeautifulSoup(page0.text, 'lxml')
    author = soup0.find_all('meta', {'name' : 'author'})[0].attrs['content']
    date = soup0.find_all('meta', {'itemprop' : 'datePublished'})[0].attrs['content']
    title = soup0.find_all('meta', {'property' : 'og:title'})[0].attrs['content']
    description = soup0.find_all('meta', {'name' : 'description'})[0].attrs['content']
    rubrics = [r.text for r in soup0.find_all('p')[0].find_all('a')]
    diff = soup0.find_all('span', {'class' : 'difficult-value'})[0].text
    text_list = soup0.find_all('p', {'class' : None})
    text = [t.text for t in text_list]
    final_text = ' '.join(text)
    final_text = final_text.replace('\n', ' ')
    
    return url0, date, author, description, title, final_text, rubrics, diff
51/55:
final_text = ' '.join(text)
final_text
51/56: text = [t.text for t in text_list]
51/57:
diff = soup0.find_all('span', {'class' : 'difficult-value'})[0].text
diff
51/58: soup0.find_all('span', {'class' : 'difficult-value'})
51/59: soup0.find_all('p')[0].find_all('a')
51/60:
rubrics = [r.text for r in soup0.find_all('p')[0].find_all('a')]
rubrics
51/61: soup0.find_all('span', {'class' : 'difficult-value'})
51/62:
diff = soup0.find_all('span', {'class' : 'difficult-value'})[0].text
diff
51/63: text_list = soup0.find_all('p', {'class' : None})
51/64: text = [t.text for t in text_list]
51/65: text = [t.text for t in text_list]
51/66:
s = '[(())]'
ls = list()
dict = {
    '[':']',
    '{':'}',
    '(':')'
}
ls.append(s[0])
def check_seq(string):
    for element in string[ 1: :1]:
        if dict.get(element) and ls[-1] == element:
            ls.pop()
        elif len(ls) == 0:
            print('one')
        else:
             ls.append(element)

    

print(ls)
check_seq(s)
51/67: import requests
51/68:
url = 'https://nplus1.ru/' # сохраняем
page = requests.get(url) # загружаем страницу по ссылке
51/69: page  # response 200 - страница загружена
51/70: from bs4 import BeautifulSoup  # не спрашивайте, почему BeautifulSoup
51/71: soup = BeautifulSoup(page.text, 'lxml')
51/72: soup
51/73: print(soup.prettify())
51/74:
for link in soup.find_all('a'):
    print(link.get('href'))
51/75:
urls = []

for link in soup.find_all('a'):
    if '/news' in link.get('href'):
        urls.append(link.get('href'))
urls
51/76:
full_urls = []

for u in urls:
    res = 'https://nplus1.ru' + u
    full_urls.append(res) 

full_urls
51/77:
url0 = full_urls[1]

page0 = requests.get(url0)
soup0 = BeautifulSoup(page0.text, 'lxml')
51/78: soup0.find_all('meta')
51/79: soup0.find_all('meta', {'name' : 'author'}) # например, автор
51/80: soup0.find_all('meta', {'name' : 'author'})[0]
51/81: soup0.find_all('meta', {'name' : 'author'})[0].attrs
51/82:
author = soup0.find_all('meta', {'name' : 'author'})[0].attrs['content']
author
51/83:
date = soup0.find_all('meta', {'itemprop' : 'datePublished'})[0].attrs['content']
title = soup0.find_all('meta', {'property' : 'og:title'})[0].attrs['content']
description = soup0.find_all('meta', {'name' : 'description'})[0].attrs['content']
51/84: soup0.find_all('p')
51/85: soup0.find_all('p')[0].find_all('a')
51/86:
rubrics = [r.text for r in soup0.find_all('p')[0].find_all('a')]
rubrics
51/87: soup0.find_all('span', {'class' : 'difficult-value'})
51/88:
diff = soup0.find_all('span', {'class' : 'difficult-value'})[0].text
diff
51/89: text_list = soup0.find_all('p', {'class' : None})
51/90: text = [t.text for t in text_list]
51/91:
final_text = ' '.join(text)
final_text
51/92: final_text = final_text.replace('\n', ' ')
51/93:
def GetNews(url0):
    """
    Returns a tuple with url0, date, author, description, title, final_text, rubrics, diff.
    Parameters:
    
    url0 is a link to the news (string)
    """
    page0 = requests.get(url0)
    soup0 = BeautifulSoup(page0.text, 'lxml')
    author = soup0.find_all('meta', {'name' : 'author'})[0].attrs['content']
    date = soup0.find_all('meta', {'itemprop' : 'datePublished'})[0].attrs['content']
    title = soup0.find_all('meta', {'property' : 'og:title'})[0].attrs['content']
    description = soup0.find_all('meta', {'name' : 'description'})[0].attrs['content']
    rubrics = [r.text for r in soup0.find_all('p')[0].find_all('a')]
    diff = soup0.find_all('span', {'class' : 'difficult-value'})[0].text
    text_list = soup0.find_all('p', {'class' : None})
    text = [t.text for t in text_list]
    final_text = ' '.join(text)
    final_text = final_text.replace('\n', ' ')
    
    return url0, date, author, description, title, final_text, rubrics, diff
51/94: from time import sleep
51/95:
news = [] # это будет список из кортежей, в которых будут храниться данные по каждой новости

for link in full_urls:
    res = GetNews(link)
    news.append(res)
    sleep(3) # задержка в 3 секунды
51/96: news[0]
51/97: import pandas as pd
51/98: df = pd.DataFrame(news)
51/99: df.head(2)
51/100: df.columns = ['link', 'date', 'author', 'desc', 'title', 'text', 'rubric', 'diffc']
51/101: df.head(2)
51/102: df['diffc'] = [float(i) for i in df.diffc]
51/103: df.diffc.describe()
51/104:
%matplotlib inline
df.diffc.plot.hist()
51/105: df['rubric'] = [','.join(r) for r in df.rubric]
51/106: df.text[0]
51/107: df['clean_text'] = [t.split('Нашли опечатку?')[0] for t in df.text]
51/108: df['clean_text'] = [t.replace("\xa0", " ") for t in df.clean_text]
51/109: df.clean_text[0]
51/110: df.to_excel('nplus-news.xlsx')
52/1:
# импортируем библиотеку для доступа к файлам в интернете
import requests
import re
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text
emails = re.findall(r'[\w\.\-]+@[\w\-\.]+\b', mbox)

print(emails)
52/2:
# импортируем библиотеку для доступа к файлам в интернете
import requests
import re
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text
emails = re.findall(r'[\w\.\-]+@[\w\-\.]+\b', mbox)

print(len(emails)
52/3:
# импортируем библиотеку для доступа к файлам в интернете
import requests
import re
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text
emails = re.findall(r'[\w\.\-]+@[\w\-\.]+\b', mbox)

print(len(emails))
52/4:
# импортируем библиотеку для доступа к файлам в интернете
import requests
import re
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text
emails = re.findall(r'[\w\.\-]+@[\w\-\.]+\b', mbox)

print(emails)
52/5:
# импортируем библиотеку для доступа к файлам в интернете
import requests
import re
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text
emails = re.findall(r'Author: [\w\.\-]+@[\w\-\.]+\b', mbox)

print(emails)
52/6:
# импортируем библиотеку для доступа к файлам в интернете
import requests
import re
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text
emails = re.findall(r'Author: [\w\.\-]+@[\w\-\.]+\b', mbox)

print(len(emails))
52/7:
# импортируем библиотеку для доступа к файлам в интернете
import requests
import re
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text
emails_with_author = re.findall(r'Author: [\w\.\-]+@[\w\-\.]+\b', mbox)
emails = [ m.split()[1] for m in emails_with_author]

email_frequency_dict = {}

# for m.split(). in range(len(emails)):
#     if email_frequency_dict.get()

print(len(emails))
52/8:
# импортируем библиотеку для доступа к файлам в интернете
import requests
import re
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text
emails_with_author = re.findall(r'Author: [\w\.\-]+@[\w\-\.]+\b', mbox)
emails = [ m.split()[1] for m in emails_with_author]

email_frequency_dict = {}

# for m.split(). in range(len(emails)):
#     if email_frequency_dict.get()

print((emails))
52/9:
# импортируем библиотеку для доступа к файлам в интернете
import requests
import re
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text
emails_with_author = re.findall(r'Author: [\w\.\-]+@[\w\-\.]+\b', mbox)
emails = [m.split()[1] for m in emails_with_author]

email_frequency_dict = {}

for m in range(len(emails)):
    if email_frequency_dict.get(m, 0)
        email_frequency_dict[m] += 1;

print((email_frequency_dict))
52/10:
# импортируем библиотеку для доступа к файлам в интернете
import requests
import re
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text
emails_with_author = re.findall(r'Author: [\w\.\-]+@[\w\-\.]+\b', mbox)
emails = [m.split()[1] for m in emails_with_author]

email_frequency_dict = {}

for m in range(len(emails)):
    if email_frequency_dict.get(m, 0):
        email_frequency_dict[m] += 1

print((email_frequency_dict))
52/11:
# импортируем библиотеку для доступа к файлам в интернете
import requests
import re
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text
emails_with_author = re.findall(r'Author: [\w\.\-]+@[\w\-\.]+\b', mbox)
emails = [m.split()[1] for m in emails_with_author]

email_frequency_dict = {}

for m in range(len(emails)):
    if email_frequency_dict.get(m):
        email_frequency_dict[m] += 1
    else:
        email_frequency_dict = 0

print((email_frequency_dict))
52/12:
# импортируем библиотеку для доступа к файлам в интернете
import requests
import re
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text
emails_with_author = re.findall(r'Author: [\w\.\-]+@[\w\-\.]+\b', mbox)
emails = [m.split()[1] for m in emails_with_author]

email_frequency_dict = {}

for m in range(len(emails)):
    print(m)
    if email_frequency_dict.get(m):
        email_frequency_dict[m] += 1
    else:
        email_frequency_dict = 0

print((email_frequency_dict))
52/13:
# импортируем библиотеку для доступа к файлам в интернете
import requests
import re
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text
emails_with_author = re.findall(r'Author: [\w\.\-]+@[\w\-\.]+\b', mbox)
emails = [m.split()[1] for m in emails_with_author]

email_frequency_dict = {}

for m in emails:
    print(m)
    if email_frequency_dict.get(m):
        email_frequency_dict[m] += 1
    else:
        email_frequency_dict = 0

print((email_frequency_dict))
52/14:
# импортируем библиотеку для доступа к файлам в интернете
import requests
import re
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text
emails_with_author = re.findall(r'Author: [\w\.\-]+@[\w\-\.]+\b', mbox)
emails = [m.split()[1] for m in emails_with_author]

email_frequency_dict = {}

for m in emails:
    print(m)
    if email_frequency_dict.get(m):
        email_frequency_dict[m] += 1
    else:
        email_frequency_dict[m] = 0

print((email_frequency_dict))
52/15:
# импортируем библиотеку для доступа к файлам в интернете
import requests
import re
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text
emails_with_author = re.findall(r'Author: [\w\.\-]+@[\w\-\.]+\b', mbox)
emails = [m.split()[1] for m in emails_with_author]

email_frequency_dict = {}

for m in emails:
    print(m)
    if email_frequency_dict.get(m):
        email_frequency_dict[m] += 1
    else:
        email_frequency_dict[m] = 1

print((email_frequency_dict))
52/16:
# импортируем библиотеку для доступа к файлам в интернете
import requests
import re
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text
emails_with_author = re.findall(r'Author: [\w\.\-]+@[\w\-\.]+\b', mbox)
emails = [m.split()[1] for m in emails_with_author]

email_frequency_dict = {}

for m in emails:
    if email_frequency_dict.get(m):
        email_frequency_dict[m] += 1
    else:
        email_frequency_dict[m] = 1

print((email_frequency_dict))
52/17:
# импортируем библиотеку для доступа к файлам в интернете
import requests
import re
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text
emails_with_author = re.findall(r'Author: [\w\.\-]+@[\w\-\.]+\b', mbox)
emails = [m.split()[1] for m in emails_with_author]

email_frequency_dict = {}

for m in emails:
    if email_frequency_dict.get(m):
        email_frequency_dict[m] += 1
    else:
        email_frequency_dict[m] = 1
        
all_values = email_frequency_dict.values()
max_value = max(email_frequency_dict)
print(max_value)

print((email_frequency_dict))
52/18:
# импортируем библиотеку для доступа к файлам в интернете
import requests
import re
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text
emails_with_author = re.findall(r'Author: [\w\.\-]+@[\w\-\.]+\b', mbox)
emails = [m.split()[1] for m in emails_with_author]

email_frequency_dict = {}

for m in emails:
    if email_frequency_dict.get(m):
        email_frequency_dict[m] += 1
    else:
        email_frequency_dict[m] = 1
        
all_values = email_frequency_dict.values()
max_value = max(email_frequency_dict)
print(max_value)
52/19:
# импортируем библиотеку для доступа к файлам в интернете
import requests
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text

emails_with_author = re.findall(r'X-DSPAM-Confidence: (\d+)', mbox)
emails = [m.split()[1] for m in emails_with_author]

email_frequency_dict = {}

for m in emails:
    if email_frequency_dict.get(m):
        email_frequency_dict[m] += 1
    else:
        email_frequency_dict[m] = 1
        
all_values = email_frequency_dict.values()
max_value = max(email_frequency_dict)
print(max_value)
52/20:
# импортируем библиотеку для доступа к файлам в интернете
import requests
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text

metrika_dspam = re.findall(r'X-DSPAM-Confidence: (\d+)', mbox)
# emails = [m.split()[1] for m in emails_with_author]
print(metrika_dspam)
52/21:
# импортируем библиотеку для доступа к файлам в интернете
import requests
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text

metrika_dspam = re.findall(r'X-DSPAM-Confidence: \d+\.\d+', mbox)
# emails = [m.split()[1] for m in emails_with_author]
print(metrika_dspam)
52/22:
# импортируем библиотеку для доступа к файлам в интернете
import requests
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text

metrics_dspam = re.findall(r'X-DSPAM-Confidence: \d+\.\d+', mbox)
list_metrics = [m.split()[1] for m in metrika_dspam]
average_metr = sum(list_metrics) / len(list_metrics)
print(average_metr)
52/23:
# импортируем библиотеку для доступа к файлам в интернете
import requests
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text

metrics_dspam = re.findall(r'X-DSPAM-Confidence: \d+\.\d+', mbox)
list_metrics = [m.split()[1] for m in metrika_dspam]
# average_metr = sum(list_metrics) / len(list_metrics)
print(list_metrics)
52/24:
# импортируем библиотеку для доступа к файлам в интернете
import requests
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text

metrics_dspam = re.findall(r'X-DSPAM-Confidence: \d+\.\d+', mbox)
list_metrics = [int(m.split()[1]) for m in metrika_dspam]
# average_metr = sum(list_metrics) / len(list_metrics)
print(list_metrics)
52/25:
# импортируем библиотеку для доступа к файлам в интернете
import requests
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text

metrics_dspam = re.findall(r'X-DSPAM-Confidence: \d+\.\d+', mbox)
list_metrics = [float(m.split()[1]) for m in metrika_dspam]
# average_metr = sum(list_metrics) / len(list_metrics)
print(list_metrics)
52/26:
# импортируем библиотеку для доступа к файлам в интернете
import requests
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text

metrics_dspam = re.findall(r'X-DSPAM-Confidence: \d+\.\d+', mbox)
list_metrics = [float(m.split()[1]) for m in metrika_dspam]
average_metr = sum(list_metrics) / len(list_metrics)
print(list_metrics)
52/27:
# импортируем библиотеку для доступа к файлам в интернете
import requests
# в переменной mbox хранится текст для работы
mbox = requests.get('http://www.py4inf.com/code/mbox.txt').text

metrics_dspam = re.findall(r'X-DSPAM-Confidence: \d+\.\d+', mbox)
list_metrics = [float(m.split()[1]) for m in metrika_dspam]
average_metr = sum(list_metrics) / len(list_metrics)
print(average_metr)
52/28:
shops = [{'товар': 'яблоки', 'количество': 400}, 
         {'товар': 'конфеты', 'количество': 300}, 
         {'товар': 'яблоки', 'количество': 750}]
52/29:
my_shop_dict = {}

for item in shops:
    if my_shop_dict.get(item.get('товар')):
        my_shop_dict[item.get('товар')] = my_shop_dict[item.get('товар')] + item.get('количество')
    else:
        my_shop_dict[item.get('товар')] = item.get('количество')

print(my_shop_dict)
52/30:
even_numbers = [x%2 == 0 for x in range(1000, 3001)]
print(even_numbers)
52/31:
even_numbers = [x%2 for x in range(1000, 3001)]
print(even_numbers)
52/32:
even_numbers = [x for x in range(1000, 3001) if x % 2 == 0]
print(even_numbers)
52/33: even_numbers = [x for x in range(1000, 3001) if x % 2 == 0]
52/34: even_numbers = [x for x in range(1000, 3001) if x % 2 == 0]
52/35:
import re
my_text = str(input())

letters = re.findall(r'[A-Za-zА-Яа-яЁё]', my_text):
digits = re.findall(r'\d', my_text):

print(letters)
print(digits)
52/36:
import re
my_text = str(input())

letters = re.findall(r'[A-Za-zА-Яа-яЁё]', my_text)
digits = re.findall(r'\d', my_text)

print(letters)
print(digits)
52/37:
import re
my_text = str(input())

letters = re.findall(r'[A-Za-zА-Яа-яЁё]', my_text)
digits = re.findall(r'\d', my_text)

print(f'Цифры: {len(digits)}')
print(f'Буквы: {len(letters)}')
52/38:
my_string = str(input())
frequency_words = {}
52/39:
my_string = str(input()).split()
frequency_words = {}

print(my_string)
52/40:
my_string = str(input()).split()
frequency_words = {}

for m in my_string:
    if frequency_words.get(m):
        frequency_words[m] += 1
    else:
        frequency_words[m] = 1

print(frequency_words)
52/41:
my_string = str(input()).split()
frequency_words = {}

for m in my_string:
    if frequency_words.get(m):
        frequency_words[m] += 1
    else:
        frequency_words[m] = 1

print(frequency_words)
52/42:
from random import randint
 
N = 10
a = []
for i in range(N):
    a.append(randint(1, 99))
print(a)
52/43:
from random import randint
 
N = 10
a = []
for i in range(N):
    a.append(randint(1, 99))
print(a)
52/44:
from random import randint
 
N = 10
a = []
for i in range(N):
    a.append(randint(1, 99))
print(a)
52/45:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    pivot = arr[len(arr)]

print(len(a)//2)
52/46:
from random import randint
 
N = 101
a = []
for i in range(N):
    a.append(randint(1, 99))
print(a)
52/47:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    pivot = arr[len(arr)]

print(len(a)//2)
52/48:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    pivot = arr[len(arr) // 2]
    leftArr = list(filter(lambda x: x <= pivot, arr))

print(list(filter(lambda x: x <= 100, arr)))
52/49:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    pivot = arr[len(arr) // 2]
    leftArr = list(filter(lambda x: x <= pivot, arr))

print(list(filter(lambda x: x <= 100, 1)))
52/50:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    pivot = arr[len(arr) // 2]
    leftArr = list(filter(lambda x: x <= pivot, arr))

print(list(filter(lambda x: x <= 100, a)))
52/51:
from random import randint
 
N = 10
a = []
for i in range(N):
    a.append(randint(1, 99))
print(a)
52/52:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    pivot = arr[len(arr) // 2]
    leftArr = list(filter(lambda x: x <= pivot, arr))

print(list(filter(lambda x: x <= 10, a)))
52/53:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    pivot = arr[len(arr) // 2]
    leftArr = list(filter(lambda x: x <= pivot, arr))
    rightArr = list(filter(lambda x: x > pivot, arr))
    return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
52/54:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    pivot = arr[len(arr) // 2]
    leftArr = list(filter(lambda x: x <= pivot, arr))
    rightArr = list(filter(lambda x: x > pivot, arr))
    return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
52/55:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
52/56:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print('leftArr', leftArr)
        return arr
#     quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
52/57:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print('leftArr', leftArr)
        return quick_sort(leftArr
#     quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
52/58:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print('leftArr', leftArr)
        return quick_sort(leftArr)
#     quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
52/59:
def quick_sort(arr):
    if len(arr) == 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print('leftArr', leftArr)
        return quick_sort(leftArr)
#     quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
52/60:
def quick_sort(arr):
    if len(arr) == 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print('leftArr', leftArr)
        return quick_sort(leftArr) + quick_sort(rightArr)
#     quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
52/61:
def quick_sort(arr):
    if len(arr) == 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print(leftArr)
        print(rightArr)
        return quick_sort(leftArr) + quick_sort(rightArr)
#     quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
52/62:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print(leftArr)
        print(rightArr)
        return quick_sort(leftArr) + quick_sort(rightArr)
#     quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
52/63:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print(leftArr)
        print(rightArr)
        return quick_sort(leftArr) + quick_sort(rightArr)
#     quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)

b = [2, 5]
c = [14, 71, 42, 56, 27, 65, 55, 16]
print(b + c)
52/64:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
#         print(leftArr)
#         print(rightArr)
        return quick_sort(leftArr) + quick_sort(rightArr)
#     quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)

b = [2, 5]
c = [14, 71, 42, 56, 27, 65, 55, 16]
print(b + c)
52/65:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
#         print(leftArr)
#         print(rightArr)
#         return quick_sort(leftArr) + quick_sort(rightArr)
#     quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)

b = [2, 5]
c = [14, 71, 42, 56, 27, 65, 55, 16]
print(b + c)
52/66:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
#         print(leftArr)
#         print(rightArr)
        return quick_sort(leftArr) + quick_sort(rightArr)
#     quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

# quick_sort(a)

b = [2, 5]
c = [14, 71, 42, 56, 27, 65, 55, 16]
print(b + c)
52/67:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
#         print(leftArr)
#         print(rightArr)
        return quick_sort(leftArr) + quick_sort(rightArr)
#     quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

# quick_sort(a)

b = [2, 5]
c = [14, 71, 42, 56, 27, 65, 55, 16]
print(b + c)
52/68:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
#         print(leftArr)
#         print(rightArr)
        return quick_sort(leftArr) + quick_sort(rightArr)
#     quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

# quick_sort(a)
e = 12222
b = [2, 5]
c = [14, 71, 42, 56, 27, 65, 55, 16]
print(b +[e] + c)
52/69:
def quick_sort(arr):
    if len(arr) == 0:
        return arr

    pivot = arr[len(arr) // 2]
    leftArr = list(filter(lambda x: x <= pivot, arr))
    rightArr = list(filter(lambda x: x > pivot, arr))
    print(leftArr, 'left')
    print(rightArr, 'right')
    return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

# quick_sort(a)
e = 12222
b = [2, 5]
c = [14, 71, 42, 56, 27, 65, 55, 16]
print(b +[e] + c)
52/70:
def quick_sort(arr):
    if len(arr) == 0:
        return arr

    pivot = arr[len(arr) // 2]
    leftArr = list(filter(lambda x: x <= pivot, arr))
    rightArr = list(filter(lambda x: x > pivot, arr))
    print(leftArr, 'left')
    print(rightArr, 'right')
    return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
52/71:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    elif len(arr) == 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print(leftArr, 'left')
        print(rightArr, 'right')
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
52/72:
def quick_sort(arr):
    if len(arr) == 0:
        return arr
    elif len(arr) == 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))

        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
52/73:
def quick_sort(arr):
    print(arr)
    if len(arr) == 0:
        return arr
    elif len(arr) == 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
52/74:
def quick_sort(arr):
    print(arr)
    if len(arr) == 0:
        return arr
    elif len(arr) == 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        print(pivot)
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
52/75:
def quick_sort(arr):
    print(arr)
    if len(arr) == 0:
        return arr
    elif len(arr) == 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        print(pivot)
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print(leftArr)
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
52/76:
def quick_sort(arr):
    print(arr)
    if len(arr) == 0:
        return arr
    elif len(arr) == 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        print(pivot)
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print(rightArr)
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
52/77:
def quick_sort(arr):
    print(arr)
    if len(arr) == 0:
        print()
        print()
        return arr
    elif len(arr) == 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        print(pivot)
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print(rightArr)
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
52/78:
def quick_sort(arr):
    print(arr)
    if len(arr) == 0:
        print(arr, 'empty')
        return arr
    elif len(arr) == 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        print(pivot)
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print(rightArr)
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
52/79:
def quick_sort(arr):
    print(arr)
    if len(arr) == 0:
        print(arr, 'empty')
        return arr
    elif len(arr) == 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        print(pivot)
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print(rightArr)
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

# quick_sort(a)
len([])
52/80:
def quick_sort(arr):
    print(arr)
    if len(arr) == 0:
        print(arr, 'empty')
        return arr
    elif len(arr) == 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        print(pivot)
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print(rightArr)
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

# quick_sort(a)
len([])
52/81:
def quick_sort(arr):
    print(arr)
    if len(arr) == 0:
        print(arr, 'empty')
        return arr
    elif len(arr) == 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        print(pivot)
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print(rightArr)
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
len([])
52/82:
def quick_sort(arr):
    print(len(arr)
    if len(arr) == 0:
        print(arr, 'empty')
        return arr
    elif len(arr) == 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        print(pivot)
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print(rightArr)
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
# len([])
52/83:
def quick_sort(arr):
    print(len(arr)
    if len(arr) == 0:
        print(arr, 'empty')
        return arr
    elif len(arr) == 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        print(pivot)
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print(rightArr)
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
# len([])
52/84:
def quick_sort(arr):
    print(len(arr))
    if len(arr) == 0:
        print(arr, 'empty')
        return arr
    elif len(arr) == 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        print(pivot)
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        print(rightArr)
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
# len([])
52/85:
def quick_sort(arr):
    print(len(arr))
    if len(arr) == 0:
        print(arr, 'empty')
        return arr
    elif len(arr) == 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)

quick_sort(a)
# len([])
52/86:
def quick_sort(arr):
    print(len(arr))
    if len(arr) != 0:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        print(arr, 'empty')
        return arr


quick_sort(a)
# len([])
52/87:
def quick_sort(arr):
    print(arr)
    if len(arr) != 0:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        print(arr, 'empty')
        return arr


quick_sort(a)
# len([])
52/88:
def quick_sort(arr):
    print(arr)
    if len(arr) != 0:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        print(arr, 'empty')
        return []


quick_sort(a)
# len([])
52/89:
def quick_sort(arr):
    print(arr)
    if len(arr) > 1:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        print(arr, 'empty')
        return arr


quick_sort(a)
# len([])
52/90:
def quick_sort(arr):
    print(arr)
    if len(arr) > 2:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        print(arr, 'empty')
        return arr


quick_sort(a)
# len([])
52/91:
def quick_sort(arr):
    print(arr)
    if arr:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        print(arr, 'empty')
        return arr


quick_sort(a)
# len([])
52/92:
def quick_sort(arr):
    print(arr)
    if arr:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        return arr


quick_sort(a)
# len([])
52/93:
def quick_sort(arr):
    print(arr)
    if arr:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        return arr



def quicksort(xs):
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quicksort(a)
# len([])
52/94:
def quick_sort(arr):
    print(arr)
    if arr:
        pivot = arr[len(arr) // 2]
        leftArr = filter(lambda x: x <= pivot, arr)
        rightArr = filter(lambda x: x > pivot, arr)
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        return arr



def quicksort(xs):
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/95:
def quick_sort(arr):
    print(arr)
    if arr:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        return arr



def quicksort(xs):
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/96:
def quick_sort(arr):
    print(type(arr))
    if arr:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        return arr



def quicksort(xs):
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/97:
def quick_sort(arr):
    print(type(arr))
    if arr:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        return arr



def quicksort(xs):
    type(xs)
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quicksort(a)
# len([])
52/98:
def quick_sort(arr):
    print(type(arr))
    if arr:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        return arr



def quicksort(xs):
    print(type(xs)
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quicksort(a)
# len([])
52/99:
def quick_sort(arr):
    print(type(arr))
    if arr:
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        return arr



def quicksort(xs):
    print(type(xs))
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quicksort(a)
# len([])
52/100:
def quick_sort(arr):
    print(type(arr))
    if arr:
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else:
        return arr



def quicksort(xs):
    print(type(xs))
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/101:
def quick_sort(arr):
    print(type(arr))
    if arr:
        below = [i for i in [1:] if i < arr[0]] 
        above = [i for i in [1:] if i >= arr[0]]
        return quicksort(below) + [arr[0]] + quicksort(above)
    else:
        return arr



def quicksort(xs):
    print(type(xs))
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/102:
def quick_sort(arr):
    print(type(arr))
    if arr:
        below = [i for i in arr[1:] if i < arr[0]] 
        above = [i for i in arr[1:] if i >= arr[0]]
        return quicksort(below) + [arr[0]] + quicksort(above)
    else:
        return arr



def quicksort(xs):
    print(type(xs))
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/103:
def quick_sort(arr):
#     print(type(arr))
    if arr:
        below = [i for i in arr[1:] if i < arr[0]] 
        above = [i for i in arr[1:] if i >= arr[0]]
        return quicksort(below) + [arr[0]] + quicksort(above)
    else:
        return arr



def quicksort(xs):
    print(type(xs))
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/104:
def quick_sort(arr):
#     print(type(arr))
    if arr:
        below = [i for i in arr[1:] if i < arr[0]] 
        above = [i for i in arr[1:] if i >= arr[0]]
        return quicksort(below) + [arr[0]] + quicksort(above)
    else:
        return arr



def quicksort(xs):
    print(type(xs))
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/105:
def quick_sort(arr):
#     print(type(arr))
    if arr:
        below = [i for i in arr[1:] if i < arr[0]] 
        above = [i for i in arr[1:] if i >= arr[0]]
        return quicksort(below) + [arr[0]] + quicksort(above)
    else:
        return arr



def quicksort(xs):
#     print(type(xs))
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/106:
def quick_sort(arr):
#     print(type(arr))
    if arr:
        below = [i for i in arr[1:] if i < arr[0]] 
        above = [i for i in arr[1:] if i >= arr[0]]
        return quicksort(below) + [arr[0]] + quicksort(above)
    else:
        return arr






quick_sort(a)
# len([])
52/107:
def quick_sort(arr):
#     print(type(arr))
    if arr:
        below = [i for i in arr[1:] if i < arr[0]] 
        above = [i for i in arr[1:] if i >= arr[0]]
        return quicksort(below) + [arr[0]] + quicksort(above)
    else:
        return arr






quick_sort(a)
# len([])
52/108:
def quick_sort(arr):
    if arr:
        print((arr))
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        return arr



def quicksort(xs):
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quicksort(a)
# len([])
52/109:
def quick_sort(arr):
    if arr:
        print((arr))
        pivot = arr[len(arr) // 2]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        return arr



def quicksort(xs):
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/110:
def quick_sort(arr):
    if arr:
        print((arr))
        pivot = arr[0]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        return arr



def quicksort(xs):
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/111:
def quick_sort(arr):
    if arr:
#         print((arr))
        pivot = arr[0]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        return arr



def quicksort(xs):
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/112:
def quick_sort(arr):
    if arr:
        print((arr))
        pivot = arr[0]
        leftArr = list(filter(lambda x: x <= pivot, arr))
        rightArr = list(filter(lambda x: x > pivot, arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        return arr



def quicksort(xs):
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/113:
def quick_sort(arr):
    if arr:
        print((arr))
        pivot = arr[0]
        leftArr = list(filter(lambda x: (x <= pivot), arr))
        rightArr = list(filter(lambda x: (x > pivot), arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        return arr



def quicksort(xs):
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/114:
def quick_sort(arr):
    if len(arr) != 0:
        pivot = arr[0]
        leftArr = list(filter(lambda x: (x <= pivot), arr))
        rightArr = list(filter(lambda x: (x > pivot), arr))
        return quick_sort(leftArr) + [pivot] + quick_sort(rightArr)
    else:
        return arr



def quicksort(xs):
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/115:
def quick_sort(arr):
    if len(arr) != 0:
        leftArr = list(filter(lambda x: (x <= arr[0]), arr))
        rightArr = list(filter(lambda x: (x > arr[0]), arr))
        return quick_sort(leftArr) + [arr[0]] + quick_sort(rightArr)
    else:
        return arr



def quicksort(xs):
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/116:
def quick_sort(lst):
    if len(lst) != 0:
        left_lst = [i for i in lst[1:] if i < lst[0]] 
        right_lst = [i for i in lst[1:] if i >= lst[0]]
        return quick_sort(left_lst) + [arr[0]] + quick_sort(right_lst)
    else:
        return arr



def quicksort(xs):
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/117:
def quick_sort(lst):
    if len(lst) != 0:
        left_lst = [i for i in lst[1:] if i < lst[0]] 
        right_lst = [i for i in lst[1:] if i >= lst[0]]
        return quick_sort(left_lst) + [lst[0]] + quick_sort(right_lst)
    else:
        return arr



def quicksort(xs):
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/118:
def quick_sort(lst):
    if len(lst) != 0:
        left_lst = [i for i in lst[1:] if i < lst[0]] 
        right_lst = [i for i in lst[1:] if i >= lst[0]]
        return quick_sort(left_lst) + [lst[0]] + quick_sort(right_lst)
    else:
        return right_lst



def quicksort(xs):
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/119:
def quick_sort(lst):
    if len(lst) != 0:
        left_lst = [i for i in lst[1:] if i < lst[0]] 
        right_lst = [i for i in lst[1:] if i >= lst[0]]
        return quick_sort(left_lst) + [lst[0]] + quick_sort(right_lst)
    else:
        return lst



def quicksort(xs):
    if xs: 
        below = [i for i in xs[1:] if i < xs[0]] 
        above = [i for i in xs[1:] if i >= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs


quick_sort(a)
# len([])
52/120:
def quick_sort(lst):
    if len(lst) != 0:
        left_lst = [i for i in lst[1:] if i < lst[0]] 
        right_lst = [i for i in lst[1:] if i >= lst[0]]
        return quick_sort(left_lst) + [lst[0]] + quick_sort(right_lst)
    else:
        return lst


quick_sort(a)
52/121: steps = int(input('Введите N: '))
52/122:
steps = int(input('Введите N: '))
distance = {}

for i in range(len(steps)):
    move = string(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if(distance.get(name)):
        distance[name] +=1
    else:
        distance[name] = 1
print(distance)
52/123:
steps = int(input('Введите N: '))
distance = {}

for i in range(len(steps)):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if(distance.get(name)):
        distance[name] +=1
    else:
        distance[name] = 1
print(distance)
52/124:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if(distance.get(name)):
        distance[name] +=1
    else:
        distance[name] = 1
print(distance)
52/125:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    print(i)
    [name, value] = move.split()
    if(distance.get(name)):
        distance[name] +=1
    else:
        distance[name] = 1
print(distance)
52/126:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    print(i)
    [name, value] = move.split()
    if distance.get(name):
        distance[name] += 1
    else:
        distance[name] = 1
print(distance)
52/127:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    print(i)
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + value
    else:
        distance[name] = value
print(distance)
52/128:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)
print(distance)
52/129:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps: 
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {vertical_steps} от оси X и {horizontal_steps} от оси Y')
52/130:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps: 
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {vertical_steps} от оси X и {horizontal_steps} от оси Y')
52/131:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps: 
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {vertical_steps >= 0 ? 'шага вверх' : 'шага вниз'}
     и {horizontal_steps >= 0 ? 'шага вправо' : 'шага влево'}')
52/132:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps:
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {'шага вверх' if vertical_steps >= 0 else 'шага вниз'}
     и {'шага вправо' if horizontal_steps >= 0 else 'шага влево'}')
52/133:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps:
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {шага вверх if vertical_steps >= 0 else 'шага вниз'}
     и {'шага вправо' if horizontal_steps >= 0 else 'шага влево'}')
52/134:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps:
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {шага вверх if vertical_steps >= 0 else шага вниз}
     и {'шага вправо' if horizontal_steps >= 0 else 'шага влево'}')
52/135:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps:
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {шага вверх if vertical_steps >= 0 else шага вниз} и {'шага вправо' if horizontal_steps >= 0 else 'шага влево'}')
52/136:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps:
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {шага вверх if vertical_steps >= 0 else шага вниз} и {шага вправо if horizontal_steps >= 0 else шага влево}')
52/137:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps:
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {'шага вверх' if vertical_steps >= 0 else 'шага вниз'} и {'шага вправо' if horizontal_steps >= 0 else 'шага влево'}')
52/138:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps:
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {if vertical_steps >= 0: 'шага вверх' else 'шага вниз'} и {'шага вправо' if horizontal_steps >= 0 else 'шага влево'}')
52/139:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps:
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {if vertical_steps >= 0: 'шага вверх' else 'шага вниз'} и {'шага вправо' if horizontal_steps >= 0 else 'шага влево'}')
52/140:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps:
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {'шага вверх'} if vertical_steps >= 0 else {'шага вниз'} и {'шага вправо' if horizontal_steps >= 0 else 'шага влево'}')
52/141:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps:
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {'шага вверх'{ if vertical_steps >= 0 else} 'шага вниз'} и {'шага вправо' if horizontal_steps >= 0 else 'шага влево'}')
52/142:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps:
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {"шага вверх" if vertical_steps >= 0 else "шага вниз"} и {'шага вправо' if horizontal_steps >= 0 else 'шага влево'}')
52/143:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps:
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {"шага вверх" if vertical_steps >= 0 else "шага вниз"} и {"шага вправо" if horizontal_steps >= 0 else "шага влево"}')
52/144:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps:
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {abs(vertical_steps)} {"шага вверх" if vertical_steps >= 0 else "шага вниз"} и {abs(horizontal_steps)} {"шага вправо" if horizontal_steps >= 0 else "шага влево"}')
52/145:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps:
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {abs(vertical_steps)} {"шага вверх" if vertical_steps >= 0 else "шага вниз"} и {abs(horizontal_steps)} {"шага вправо" if horizontal_steps >= 0 else "шага влево"}')
52/146:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps:
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {abs(vertical_steps)} {"шага вверх" if vertical_steps >= 0 else "шага вниз"} и {abs(horizontal_steps)} {"шага вправо" if horizontal_steps >= 0 else "шага влево"}')
52/147:
steps = int(input('Введите N: '))
distance = {}

for i in range(steps):
    move = str(input(f'Ход {i+1}: '))
    [name, value] = move.split()
    if distance.get(name):
        distance[name] = distance[name] + int(value)
    else:
        distance[name] = int(value)

vertical_steps = distance.get('Вверх', 0) - distance.get('Вниз', 0)
horizontal_steps = distance.get('Вправо', 0) - distance.get('Влево', 0)

if vertical_steps == horizontal_steps:
    print(f'Пётр находится на расстоянии: {vertical_steps} от (0,0)')
else:
    print(f'Пётр находится на расстоянии: {abs(vertical_steps)} {"шага вверх" if vertical_steps >= 0 else "шага вниз"} и {abs(horizontal_steps)} {"шага вправо" if horizontal_steps >= 0 else "шага влево"}')
55/1:
# мой номер странички
myid = ''  # вставить номер странички

# версия используемого API
version = '5.103' 

# подгружаем токен из файлика на компьютере
with open('secret_token.txt') as f:
    token = f.read()
55/2:
# мой номер странички
myid = ''  # вставить номер странички

# версия используемого API
version = '5.103' 

# подгружаем токен из файлика на компьютере
# with open('secret_token.txt') as f:
    token = '84ad0e5384ad0e5384ad0e538c84d4aef0884ad84ad0e53e5cc655d12b6de646db18b38'
55/3:
# мой номер странички
myid = ''  # вставить номер странички

# версия используемого API
version = '5.103' 

# подгружаем токен из файлика на компьютере
# with open('secret_token.txt') as f:
token = '84ad0e5384ad0e5384ad0e538c84d4aef0884ad84ad0e53e5cc655d12b6de646db18b38'
55/4:
method = 'users.get'
parameters = 'user_ids='

url = 'https://api.vk.com/method/' + method + '?' + parameters + '&v=' + version + '&access_token=' + token

response = requests.get(url) 
response.json()
55/5:
import requests  

method = 'users.get'
parameters = 'user_ids='

url = 'https://api.vk.com/method/' + method + '?' + parameters + '&v=' + version + '&access_token=' + token

response = requests.get(url) 
response.json()
55/6:
# мой номер странички
myid = ''  # вставить номер странички

# версия используемого API
version = '5.103' 

# подгружаем токен из файлика на компьютере
# with open('secret_token.txt') as f:
token = '5ea241b4d3f9357c0f6c4ce20eeb29dc34d84aeb0b1fee581a70cf6c23eace985ae31d75890fab78601af&expires_in=86400&user_id=434087427'
55/7:
# мой номер странички
myid = ''  # вставить номер странички

# версия используемого API
version = '5.103' 

# подгружаем токен из файлика на компьютере
# with open('secret_token.txt') as f:
token = '5ea241b4d3f9357c0f6c4ce20eeb29dc34d84aeb0b1fee581a70cf6c23eace985ae31d75890fab78601af&expires_in=86400&user_id=434087427'
55/8:
import requests  

method = 'users.get'
parameters = 'user_ids='

url = 'https://api.vk.com/method/' + method + '?' + parameters + '&v=' + version + '&access_token=' + token

response = requests.get(url) 
response.json()
55/9:
def vk_download(method, parameters):
    
    url = 'https://api.vk.com/method/' + method + '?' + parameters + '&access_token=' + token + '&v=' + version
    response = requests.get(url) 
    infa = response.json()
    return infa
55/10: response.json()['response'][0]['first_name']
55/11:
def vk_download(method, parameters):
    
    url = 'https://api.vk.com/method/' + method + '?' + parameters + '&access_token=' + token + '&v=' + version
    response = requests.get(url) 
    infa = response.json()
    return infa
55/12: group_id = '-51126445'  # взяли из ссылки на группу
55/13:
wall = vk_download('wall.get', 'owner_id={}&count=100'.format(group_id))
wall = wall['response']
55/14: wall['items'][0]
55/15: wall['items'][0]['likes']['count']
55/16:
likes = [item['likes']['count'] for item in wall['items']]
likes[:10]
55/17: wall['count']
55/18:
import time

likes = [ ] # сюда буду сохранять лайки

for offset in range(0, 4800, 100):
    
    time.sleep(0.4) # вк согласен работать 3 раза в секунду, 
                    # между запросами python спит 0.4 секунды
    
    wall = vk_download('wall.get', 'owner_id={}&count=100&offset={}'.format(group_id, offset))
    
    likes.extend([item['likes']['count'] for item in wall['response']['items']])
56/1: import requests
56/2:
import requests
from bs4 import BeautifulSoup
56/3:
import requests
from bs4 import BeautifulSoup
56/4: soup = BeautifulSoup(website_url, 'lxml')
56/5:
website_url = 'https://www.imdb.com/search/title/?count=1000&groups=top_1000&sort=user_rating'
soup = BeautifulSoup(website_url, 'lxml')
56/6:
website_url = requests.get('https://www.imdb.com/search/title/?count=1000&groups=top_1000&sort=user_rating').text
soup = BeautifulSoup(website_url, 'lxml')
56/7: print(soup)
56/8: print(soup)
56/9: My_table = soup.find_all('h3',{'class':'lister-item-header'})
56/10: my_headers = soup.find_all('h3',{'class':'lister-item-header'})
56/11:
my_headers = soup.find_all('h3',{'class':'lister-item-header'})
print(my_headers)
56/12:
my_headers = soup.find_all('a',{'href':'/title'})
print(my_headers)
56/13:
my_headers = soup.find_all('h3',{'class':'lister-item-header'})
print(my_headers)
56/14:
my_headers = soup.find_all('h3',{'class':'lister-item-header'})get_text().strip()
print(my_headers)
56/15:
my_headers = soup.find_all('h3',{'class':'lister-item-header'}).get_text().strip()
print(my_headers)
56/16:
my_headers = soup.find_all('h3',{'class':'lister-item-header'}).get_text()
print(my_headers)
56/17:
my_headers = soup.find_all('h3',{'class':'lister-item-header'}).find_all('a')
print(my_headers)
56/18:
my_headers = soup.find_all('h3',{'class':'lister-item-header'}).find_all('a')
print(my_headers)
56/19:
my_headers = soup.find_all('h3',{'class':'lister-item-header'})
print(my_headers)
56/20:
my_headers = soup.find_all('h3',{'class':'lister-item-header'})
print(len(my_headers))
56/21: my_headers = soup.find_all('h3',{'class':'lister-item-header'})[0].find_all('a')
56/22: my_headers = soup.find_all('h3',{'class':'lister-item-header'})[0].find_all('a')[0].get_text()
56/23:
my_headers = soup.find_all('h3',{'class':'lister-item-header'})[0].find_all('a')[0].get_text()
print(my_headers)
56/24:
my_headers = [soup.find_all('h3',{'class':'lister-item-header'})[0].find_all('a')[0].get_text()[:-1]]
print(my_headers)
56/25:
my_headers = [i..find_all('a')[0].get_text() for i  un soup.find_all('h3',{'class':'lister-item-header'})[0][:-1]]
print(my_headers)
56/26:
my_headers = [i.find_all('a')[0].get_text() for i in soup.find_all('h3',{'class':'lister-item-header'})[0][:-1]]
print(my_headers)
56/27:
my_headers = [i.find_all('a')[0].get_text() for i in soup.find_all('h3',{'class':'lister-item-header'})[0]
print(my_headers)
56/28:
my_headers = [i.find_all('a')[0].get_text() for i in soup.find_all('h3',{'class':'lister-item-header'})[0]]
print(my_headers)
56/29:
my_headers = [i.find_all('a')[0].get_text() for i in soup.find_all('h3',{'class':'lister-item-header'})["-1"]]
print(my_headers)
56/30:
my_headers = [i.find_all('a')[0].get_text() for i in soup.find_all('h3',{'class':'lister-item-header'})[:-1]]
print(my_headers)
56/31: my_ratigs = [i.find_all('strong')[0].get_text() for i in soup.find_all('div',{'class':'inline-block ratings-imdb-rating'})[:-1]]
56/32:
my_ratigs = [i.find_all('strong')[0].get_text() for i in soup.find_all('div',{'class':'inline-block ratings-imdb-rating'})[:-1]]
print(my_ratigs)
56/33:
my_ratings = [i.find_all('strong')[0].get_text() for i in soup.find_all('div',{'class':'inline-block ratings-imdb-rating'})[:-1]]
print(my_ratings)
56/34:
my_headers = [i.find_all('a')[0].get_text() for i in soup.find_all('h3')[:-1]]
print(my_headers)
56/35:
my_years = soup.find_all('span',{'class':'lister-item-year'})
print(my_years)
56/36:
my_years = soup.find_all('span',{'class':'lister-item-year'}).get_text()
print(my_years)
56/37:
my_years = soup.find_all('span',{'class':'lister-item-year'})[0].get_text()
print(my_years)
56/38:
my_years = soup.find_all('span',{'class':'lister-item-year'})[0].get_text()
print(my_years)
56/39:
my_years = soup.find_all('span',{'class':'lister-item-year'}).get_text()
print(my_years)
56/40:
my_years = soup.find_all('span',{'class':'lister-item-year'})
print(my_years)
56/41:
my_years = [i.get_text() for i in soup.find_all('span',{'class':'lister-item-year'})]
print(my_years)
56/42:
my_actors = [i.get_text() for i in soup.find_all('p',{'class':''})]
print(my_actors)
56/43:
soup.find_all('p',{'class':''})
# print(my_actors)
56/44:
soup.find_all('p',{'class':''})[0].findAll['a']
# print(my_actors)
56/45:
soup.find_all('p',{'class':''})[0].findAll('a')
# print(my_actors)
56/46:
soup.find_all('p',{'class':''})[0].text().split('\n')
# print(my_actors)
56/47:
soup.find_all('p',{'class':''})[0].text.split('\n')
# print(my_actors)
56/48:
# soup.find_all('p',{'class':''})[0].text
import re

re.split(r'Stars:, soup.find_all('p',{'class':''})[0].text')
# print(my_actors)
56/49:
# soup.find_all('p',{'class':''})[0].text
import re

re.split(r'Stars:'', soup.find_all('p',{'class':''})[0].text)
# print(my_actors)
56/50:
# soup.find_all('p',{'class':''})[0].text
import re

re.split(r'Stars:', soup.find_all('p',{'class':''})[0].text)
# print(my_actors)
56/51:
# soup.find_all('p',{'class':''})[0].text
import re

directors = re.split(r'Stars:', soup.find_all('p',{'class':''})[0].text)
actors = re.split(r'Stars:', soup.find_all('p',{'class':''})[0].text)
56/52:
# soup.find_all('p',{'class':''})[0].text
import re

directors = re.split(r'Stars:', soup.find_all('p',{'class':''})[0].text)[0]
actors = re.split(r'Stars:', soup.find_all('p',{'class':''})[0].text)[1].replace('\n', '')
print(actors)
56/53:
website_url = requests.get('https://www.imdb.com/search/title/?count=200&groups=top_1000&sort=user_rating').text
soup = BeautifulSoup(website_url, 'lxml')
56/54:
my_headers = [i.find_all('a')[0].get_text() for i in soup.find_all('h3')[:-1]]
print(my_headers)
56/55: my_voices = [i['data-value'] for i in soup.find_all('span',{'name':'nv'})]
56/56:
my_voices = [i['data-value'] for i in soup.find_all('span',{'name':'nv'})]
print(my_voices)
56/57:
my_voices = [i['data-value'] for i in soup.find_all('span',{'name':'nv'})[0]]
print(my_voices)
56/58:
my_voices = [i['data-value'] for i in soup.find_all('span',{'name':'nv'})
print(my_voices)
56/59:
my_voices = [i['data-value'] for i in soup.find_all('span',{'name':'nv'})]
print(my_voices)
56/60:
my_voices = [i['data-value'] for i in soup.find('span',{'name':'nv'})]
print(my_voices)
56/61:
my_voices = [i['data-value'] for i in soup.find_all('span',{'name':'nv'})]
print(my_voices)
56/62:
my_voices = [i['data-value'] for i in soup.find_all('span',{'name':'nv'}) if soup.find_all('span',{'name':'nv'}.index(x) %2 == 1]
print(my_voices)
56/63:
my_voices = [i['data-value'] for i in soup.find_all('span',{'name':'nv'}) if soup.find_all('span',{'name':'nv'}.index(x)%2 == 1]
print(my_voices)
56/64:
my_voices = [i['data-value'] for i in soup.find_all('span',{'name':'nv'}) if soup.find_all('span',{'name':'nv'}).index(x)%2 == 1]
print(my_voices)
56/65:
my_voices = [i['data-value'] for i in soup.find_all('span',{'name':'nv'}) if soup.find_all('span',{'name':'nv'}).index(i)%2 == 1]
print(my_voices)
56/66:
table = soup.find_all('span',{'name':'nv'})
my_voices = [i['data-value'] for i in table if table.index(i)%2 == 0]
print(my_voices)
58/1: !pip install selenium
58/2:
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import Select

# browser = webdriver.Firefox()
58/3:
from selenium import webdriver

driver = webdriver.Firefox()
58/4:
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import Select

browser = webdriver.Firefox()
58/5:
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import Select

# browser = webdriver.Firefox()
58/6:
from selenium import webdriver

driver = webdriver.Firefox()
58/7:
from selenium import webdriver

driver = webdriver.Firefox()
58/8:
from selenium import webdriver

driver = webdriver.Firefox()
58/9:
from selenium import webdriver

driver = webdriver.Firefox()
58/10:
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import Select

# browser = webdriver.Firefox()
58/11:
from selenium import webdriver

driver = webdriver.Firefox()
58/12: br = wb.Chrome("/Users/elenaefimova/Downloads/chromedriver")
58/13:
from selenium import webdriver

driver = webdriver.Chrome()
58/14: br = webdriver.Chrome("/Users/elenaefimova/Downloads/chromedriver")
58/15: br = webdriver.Chrome("/Users/elenaefimova/Downloads/chromedriver")
58/16:
fld = driver.find_element_by_xpath('/html/body/div[2]/div/div/button')
fld.click()
58/17: driver = webdriver.Chrome("/Users/elenaefimova/Downloads/chromedriver")
58/18:
import requests
from bs4 import BeautifulSoup
s = requests.get("http://cikrf.ru/digital-services/naydi-svoy-izbiratelnyy-uchastok/").text
58/19: driver.get("http://cikrf.ru/digital-services/naydi-svoy-izbiratelnyy-uchastok/")
58/20: driver.get("http://cikrf.ru/digital-services/naydi-svoy-izbiratelnyy-uchastok/")
58/21:
fld = driver.find_element_by_xpath('/html/body/div[2]/div/div/button')
fld.click()
58/22: driver = webdriver.Chrome("/Users/elenaefimova/Downloads/chromedriver")
58/23:
import requests
from bs4 import BeautifulSoup
s = requests.get("http://cikrf.ru/digital-services/naydi-svoy-izbiratelnyy-uchastok/").text
58/24:
fld = driver.find_element_by_xpath('/html/body/div[2]/div/div/button')
fld.click()
58/25:
fld = driver.find_element_by_xpath("/html/body/div[1]/div/div[2]/div/div[4]/form/div[1]/div[2]")
fld.click()
58/26:
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import Select

browser = webdriver.Firefox()
58/27: safaridriver --enable
58/28:
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import Select

browser = webdriver.Firefox()
58/29:
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import Select

browser = webdriver.Firefox()
58/30:
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import Select

# browser = webdriver.Firefox()
58/31: safaridriver --enable
58/32:
from selenium import webdriver

# driver = webdriver.Chrome()
60/1:
import requests 
from bs4 import BeautifulSoup

website_url='https://www.rusmuseum.ru/collections/painting-of-the-second-half-of-the-xix-century-beginning-of-xxi-century/artworks/?PAGEN_1=2'
soup = BeautifulSoup(website_url,'lxml')
# friends = requests.get('1=2').text
# soup = BeautifulSoup(friends, 'lxml')
60/2:
import requests 
from bs4 import BeautifulSoup

website_url='https://www.rusmuseum.ru/collections/painting-of-the-second-half-of-the-xix-century-beginning-of-xxi-century/artworks/?PAGEN_1=2'
# soup = BeautifulSoup(website_url,'lxml')
friends = requests.get(website_url).text
soup = BeautifulSoup(friends, 'lxml')
60/3:
import requests 
from bs4 import BeautifulSoup

website_url='https://www.rusmuseum.ru/collections/painting-of-the-second-half-of-the-xix-century-beginning-of-xxi-century/artworks/?PAGEN_1=2'
# soup = BeautifulSoup(website_url,'lxml')
pics = requests.get(website_url).text
soup = BeautifulSoup(pics, 'lxml')
60/4: soup.find_all('p',{'class':'name'})
60/5: i.find('a').get_text() for i in soup.find_all('p',{'class':'name'})
60/6: [i.find('a').get_text() for i in soup.find_all('p',{'class':'name'})]
60/7:
m_table = soup.find_all('p',{'class':'author'})

[i.find('a').get_text() for i in m_table if m_table.index(i)%2 == 0]
60/8:
m_table = soup.find_all('p',{'class':'author'})

[i.text.strip() for i in m_table if m_table.index(i)%2 == 0]
60/9:
m_table = soup.find_all('p',{'class':'author'})

[i.text.strip() for i in m_table if m_table.index(i)%2 == 1]
64/1:
import requests
import from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')
64/2:
import requests
import bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')
64/3:
import requests
import bs4 from BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')
64/4:
import requests
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')
64/5:
import requests
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

years =  soup.find_all('span', {'class':'mw-headline'})
64/6:
import requests
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

years = soup.find_all('span', {'class':'mw-headline'})
64/7:
import requests
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

[i.find('span', {'class':'mw-headline'}).get_text() for i in soup.find_all('h3')]
64/8:
import requests
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

[i.find('span', {'class':'mw-headline'}).text for i in soup.find_all('h3')]
64/9:
import requests
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

[i.find('span', {'class':'mw-headline'}) for i in soup.find_all('h3')]
64/10:
import requests
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

[i.find('span', {'class':'mw-headline'}) for i in soup.find_all('h3') if type(i) != None]
64/11:
import requests
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

years = [i.find('span', {'class':'mw-headline'}) for i in soup.find_all('h3') if type(i) != None]

print(years)
64/12:
import requests
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

years = [i.find('span', {'class':'mw-headline'}) for i in soup.find_all('h3') if type(i) != None]

print(type(years))
64/13:
import requests
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

years = [i.find('span', {'class':'mw-headline'}) for i in soup.find_all('h3') if type(i) != None]

print([type(i) for i in years])
64/14:
import requests
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

years = [i.find('span', {'class':'mw-headline'}) for i in soup.find_all('h3') if type(i) != NoneType]

print([type(i) for i in years])
64/15:
import requests
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

years = [i.find('span', {'class':'mw-headline'}) for i in soup.find_all('h3') if print(type(i))]

# print([type(i) for i in years])
64/16:
import requests
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

years = [i.find('span', {'class':'mw-headline'}) for i in soup.find_all('h3') if i != 'None']

# print([type(i) for i in years])
64/17:
import requests
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

[i.find('span', {'class':'mw-headline'}) for i in soup.find_all('h3') if i != 'None']
64/18:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

[i.find('span', {'class':'mw-headline'}) for i in soup.find_all('h3') if i.match(r'^((?!None).)*$')]
64/19:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

[i.find('span', {'class':'mw-headline'}) for i in soup.find_all('h3') if i is not None]
64/20:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

[i.find('span', {'class':'mw-headline'}) for i in soup.find_all('h3') if type(i) == NoneType]
64/21:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

[i.find('span', {'class':'mw-headline'}) for i in soup.find_all('h3') if type(i) == None]
64/22:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

rows = [i.find('tr') for i in soup.find_all('table', {'class': 'wikitable'})]

print(rows)
64/23:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

rows = [i.find_all('tr') for i in soup.find_all('table', {'class': 'wikitable'})]

print(rows)
64/24:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

rows = [i.find_all('tr') for i in soup.find_all('table', {'class': 'wikitable'})]

# print(rows)


rows[1].find_all('td')
64/25:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

rows = [i.find_all('tr') for i in soup.find_all('table', {'class': 'wikitable'})]

# print(rows)


rows[0].find_all('td')
64/26:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

rows = [i.find_all('tr') for i in soup.find_all('table', {'class': 'wikitable'})]

# print(rows)


rows.find_all('td')
64/27:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

rows = [i.find_all('td') for i in soup.find_all('table', {'class': 'wikitable'})]

# print(rows)


rows.find_all('td')
64/28:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

rows = [i.find_all('td') for i in soup.find_all('table', {'class': 'wikitable'})]

print(rows)
64/29:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

[i.find_all('big').text for i in soup.find_all('table', {'class': 'wikitable'})]

# print(rows)
64/30:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

[i.find('big').text for i in soup.find_all('table', {'class': 'wikitable'})]

# print(rows)
64/31:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

[i.find('big') for i in soup.find_all('table', {'class': 'wikitable'})]

# print(rows)
64/32:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

[i.find_all('big') for i in soup.find_all('table', {'class': 'wikitable'})]

# print(rows)
64/33:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

[i.find_all('td') for i in soup.find_all('table', {'class': 'wikitable'})]

# print(rows)
64/34:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

rows = [i.find_all('tr') for i in soup.find_all('table', {'class': 'wikitable'})]
64/35:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

rows = [i.find_all('tr') for i in soup.find_all('table', {'class': 'wikitable'})[1:12:1]]

rows_for_frame = []
for row in rows:
    res = GetRow(row)
    rows_for_frame.append(res)
64/36:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

rows = [i.find_all('tr') for i in soup.find_all('table', {'class': 'wikitable'})[1:12:1]]

# rows_for_frame = []
# for row in rows:
#     res = GetRow(row)
#     rows_for_frame.append(res)
64/37:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

rows = [i.find_all('tr') for i in soup.find_all('table', {'class': 'wikitable'})[1:12:1]]
print(rows)
# rows_for_frame = []
# for row in rows:
#     res = GetRow(row)
#     rows_for_frame.append(res)
64/38:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

rows = [i.find_all('tr') for i in soup.find_all('table', {'class': 'wikitable'})[1:11:1]]
print(rows)
# rows_for_frame = []
# for row in rows:
#     res = GetRow(row)
#     rows_for_frame.append(res)
64/39:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[1:11:1]

def get_table(table):
    print(table)

table_for_frame = []
for table in tables:
    res = get_table(table)
#     table_for_frame.append(res)
64/40:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[1:11:1]

def get_table(table):
    rows = table.find_all('tr')[1::]
    for row in rows:
        cell_tuple = (cell.text for cell in table.find_all('td'))
        print(cell_tuple)
#         if r[0].get_text().strip() != '':
#         Dates.append(r[0].get_text().strip())
#         retained = r[0].get_text().strip()
#     else:
#         Dates.append(retained)
    
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)
64/41:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[1:11:1]

def get_table(table):
    rows = table.find_all('tr')[1::]
    for row in rows:
        cell_tuple = [cell.text for cell in table.find_all('td')]
        print(cell_tuple)
#         if r[0].get_text().strip() != '':
#         Dates.append(r[0].get_text().strip())
#         retained = r[0].get_text().strip()
#     else:
#         Dates.append(retained)
    
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)
64/42:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[1:11:1]

def get_table(table):
    rows = table.find_all('tr')[1::]
    for row in rows:
        cell_tuple = [cell.get_text().strip() for cell in table.find_all('td')]
        print(cell_tuple)
#         if r[0].get_text().strip() != '':
#         Dates.append(r[0].get_text().strip())
#         retained = r[0].get_text().strip()
#     else:
#         Dates.append(retained)
    
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)
64/43:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[1:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')[1::]
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)
64/44:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[1:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')[1::]
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)
64/45:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[1:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')[1::]
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)



table_for_frame
64/46:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[1:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')[1::]
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df.head(2)
64/47:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[1:11:1]
print(tables)

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')[1::]
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df.head(2)
64/48:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
print(tables)

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')[1::]
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df.head(2)
64/49:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')[1::]
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df.head(2)
64/50:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')[1::]
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
# df.head(2)
64/51:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')[1::]
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/52:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')[1::]
    print(rows)
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/53:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')[1::]
#     print(rows)
    for row in rows:
        row_tuple = get_row(row)
        print(row_tuple)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/54:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')[1::]
#     print(rows)
    for row in rows:
        row_tuple = get_row(row)
        print(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/55:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    print(rows)
    for row in rows:
        row_tuple = get_row(row)
#         print(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/56:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = [r for r in table.find_all('tr')]
    print(rows)
    for row in rows:
        row_tuple = get_row(row)
#         print(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/57:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = [get_row(r) for r in table.find_all('tr')]
    print(rows)
#     for row in rows:
#         row_tuple = get_row(row)
#         print(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/58:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = [get_row(r) for r in table.find_all('tr')]
    return rows
#     print(rows)
#     for row in rows:
#         row_tuple = get_row(row)
#         print(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/59:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = [get_row(r) for r in table.find_all('tr')]
    return rows
#     print(rows)
#     for row in rows:
#         row_tuple = get_row(row)
#         print(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(rows)
df
64/60:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = [get_row(r) for r in table.find_all('tr')]
#     return rows
    print(rows)
#     for row in rows:
#         row_tuple = get_row(row)
#         print(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(rows)
df
64/61:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = [get_row(r) for r in table.find_all('tr')]
#     return rows
    df = pd.DataFrame(rows)
#     for row in rows:
#         row_tuple = get_row(row)
#         print(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)





df
64/62:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = [get_row(r) for r in table.find_all('tr')]
    return rows
#     print(rows)
#     for row in rows:
#         row_tuple = get_row(row)
#         print(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(rows)
df
64/63:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
#     print(rows)
    for row in rows:
        row_tuple = get_row(row)
        print(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(rows)
df
64/64:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
#     print(rows)
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(rows)
df
64/65:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
#     print(rows)
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/66:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    print(row)
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/67:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        print(rows)
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/68:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    print(rows)
    for row in rows:
        
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/69:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = []
    [rows.append(r) in r for table.find_all('tr')]
    print(rows)
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/70:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = []
    for r in table.find_all('tr'):
        print(r)
    print(rows)
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/71:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = []
    for r in table.find_all('tr'):
        print(r)
        print('\n')
    print(rows)
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/72:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = []
    for r in table.find_all('tr'):
        rows.append(r)

    print(rows)
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/73:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/74:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    print(table)
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/75:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        print(rows)
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/76:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')[1::]
    for row in rows:
        print(rows)
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/77:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')[1::]
    for row in rows:
        print(row)
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/78:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')[1::]
    for row in rows:
        print(row)
        print('\n')
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/79:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')[1::]
    for row in rows:
        print(row)
        print('\n')
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/80:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
#     print(cell_parced)
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')[1::]
    for row in rows:
        print(row)
        print('\n')
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/81:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
#     print(cell_parced)
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
        print('\n')
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/82:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
#     print(cell_parced)
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr'):
        print('\n')
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/83:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        print(row)
        print('\n')
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/84:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    print(type(rows))
    for row in rows:
        print(row)
        print('\n')
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/85:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        print(row_tuple)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/86:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        print(row_tuple)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/87:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
    year = cell_parced[6]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        print(row_tuple)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/88:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(type(cell_parced))
    year = cell_parced[]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        print(row_tuple)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/89:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cells = table.find_all('td')[::5];
        for c in cells:
            print(c)
    
#     cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
#     print(type(cell_parced))
#     year = [cell.get_text().strip() for cell in  if ]
#     winner = cell_parced[1].replace('★ ', '')
#     company = cell_parced[2]
#     producers = cell_parced[3]
#     return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/90:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cells = table.find_all('td')[::5]
        for c in cells:
            print(c)
    
#     cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
#     print(type(cell_parced))
#     year = [cell.get_text().strip() for cell in  if ]
#     winner = cell_parced[1].replace('★ ', '')
#     company = cell_parced[2]
#     producers = cell_parced[3]
#     return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/91:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cells = table.find_all('td')[::5]
    for c in cells:
        print(c)
    
#     cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
#     print(type(cell_parced))
#     year = [cell.get_text().strip() for cell in  if ]
#     winner = cell_parced[1].replace('★ ', '')
#     company = cell_parced[2]
#     producers = cell_parced[3]
#     return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/92:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cells = table.find_all('td')[::5]
    for c in cells:
        print(c)
        print('\n')
    
#     cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
#     print(type(cell_parced))
#     year = [cell.get_text().strip() for cell in  if ]
#     winner = cell_parced[1].replace('★ ', '')
#     company = cell_parced[2]
#     producers = cell_parced[3]
#     return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/93:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cells = table.find_all('td')
    for c in cells:
        print(c)
        print('\n')
    
#     cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
#     print(type(cell_parced))
#     year = [cell.get_text().strip() for cell in  if ]
#     winner = cell_parced[1].replace('★ ', '')
#     company = cell_parced[2]
#     producers = cell_parced[3]
#     return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/94:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cells = table.find_all('td')
    for c, i in cells:
        print(c)
        print('\n')
    
#     cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
#     print(type(cell_parced))
#     year = [cell.get_text().strip() for cell in  if ]
#     winner = cell_parced[1].replace('★ ', '')
#     company = cell_parced[2]
#     producers = cell_parced[3]
#     return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/95:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(type(cell_parced))
#     year = [cell.get_text().strip() for cell in  if ]
#     winner = cell_parced[1].replace('★ ', '')
#     company = cell_parced[2]
#     producers = cell_parced[3]
#     return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/96:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
#     year = [cell.get_text().strip() for cell in  if ]
#     winner = cell_parced[1].replace('★ ', '')
#     company = cell_parced[2]
#     producers = cell_parced[3]
#     return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/97:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
    print('\n')
#     year = [cell.get_text().strip() for cell in  if ]
#     winner = cell_parced[1].replace('★ ', '')
#     company = cell_parced[2]
#     producers = cell_parced[3]
#     return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/98:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
    print('\n')
    for i in range(len(cell_parced)):
        year = cell_parced[i%5 == 0].get_text().strip()
        winner = cell_parced[i%5 ==1].replace('★ ', '')
        company = cell_parced[i%5 == 2].strip()
        producers = cell_parced[i%5 == 3].strip()
        return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/99:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
    print('\n')
    for i in range(len(cell_parced)):
        year = cell_parced[i%5 == 0].text.strip()
        winner = cell_parced[i%5 ==1].replace('★ ', '')
        company = cell_parced[i%5 == 2].strip()
        producers = cell_parced[i%5 == 3].strip()
        return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/100:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
    print('\n')
    for i in range(len(cell_parced)):
        year = cell_parced[i%5 == 0].text
        winner = cell_parced[i%5 ==1].replace('★ ', '')
        company = cell_parced[i%5 == 2]
        producers = cell_parced[i%5 == 3]
        return year, winner, company, producers
    

def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/101:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
    print('\n')
    for i in range(len(cell_parced)):
        j = (i % 5)
        for j in range(0, 5):
            year = cell_parced[i%5 == 0].text
            winner = cell_parced[i%5 ==1].replace('★ ', '')
            company = cell_parced[i%5 == 2]
            producers = cell_parced[i%5 == 3]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/102:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
    print('\n')
    for i in range(len(cell_parced)):
        j = (i % 5)
        for j in range(0, 5):
            year = cell_parced[i%5 == 0].text
            winner = cell_parced[i%5 ==1].replace('★ ', '')
            company = cell_parced[i%5 == 2]
            producers = cell_parced[i%5 == 3]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/103:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
    print('\n')
    for i in range(len(cell_parced)):
        j = (i % 5)
        for j in range(0, 5):
            year = cell_parced[i%5 == 0]
            winner = cell_parced[i%5 ==1].replace('★ ', '')
            company = cell_parced[i%5 == 2]
            producers = cell_parced[i%5 == 3]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/104:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
#     print(cell_parced)
#     print('\n')
    for i in range(len(cell_parced)):
        j = (i % 5)
        for j in range(0, 5):
            year = cell_parced[i%5 == 0]
            winner = cell_parced[i%5 ==1].replace('★ ', '')
            company = cell_parced[i%5 == 2]
            producers = cell_parced[i%5 == 3]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        print(row_tuple)
        print('\n')
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/105:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
#     print('\n')
    for i in range(len(cell_parced)):
        j = (i % 5)
        for j in range(0, 5):
            year = cell_parced[i%5 == 0]
            winner = cell_parced[i%5 == 1].replace('★ ', '')
            company = cell_parced[i%5 == 2]
            producers = cell_parced[i%5 == 3]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        print(row_tuple)
        print('\n')
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/106:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
#     print('\n')
    for i in range(len(cell_parced)):
        j = (i % 5)
        for j in range(0, 5):
            year = cell_parced[i%5]
            winner = cell_parced[i%5].replace('★ ', '')
            company = cell_parced[i%5 == 2]
            producers = cell_parced[i%5 == 3]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        print(row_tuple)
        print('\n')
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/107:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
#     print('\n')
    for i in range(len(cell_parced)):
        j = (i % 5)
        for j in range(0, 5):
            year = cell_parced[i%5]
            winner = cell_parced[i%5].replace('★ ', '')
            company = cell_parced[i%5]
            producers = cell_parced[i%5]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        print(row_tuple)
        print('\n')
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/108:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
#     print('\n')
    for i in range(len(cell_parced)):
        j = (i % 5)
        for j in range(0, 5):
            year = cell_parced[i]
            winner = cell_parced[i].replace('★ ', '')
            company = cell_parced[i]
            producers = cell_parced[i]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        print(row_tuple)
        print('\n')
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/109:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
#     print('\n')
    for i in range(len(cell_parced)):
        j = (i % 5)
        for j in range(0, 5):
            year = cell_parced[i]
            winner = cell_parced[i+1].replace('★ ', '')
            company = cell_parced[i+2]
            producers = cell_parced[i+3]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        print(row_tuple)
        print('\n')
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/110:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
#     print('\n')
    for i in range(len(cell_parced)):

            year = cell_parced[i]
            winner = cell_parced[i+1].replace('★ ', '')
            company = cell_parced[i+2]
            producers = cell_parced[i+3]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        print(row_tuple)
        print('\n')
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/111:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in table.find_all('td')]
    print(cell_parced)
#     print('\n')
    for i in range(len(cell_parced)):
        year = cell_parced[i]
        winner = cell_parced[i+1].replace('★ ', '')
        company = cell_parced[i+2]
        producers = cell_parced[i+3]
        return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        print(row_tuple)
        print('\n')
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/112:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    print(cell_parced)
#     print('\n')
    for i in range(len(cell_parced)):
        year = cell_parced[i]
        winner = cell_parced[i+1].replace('★ ', '')
        company = cell_parced[i+2]
        producers = cell_parced[i+3]
        return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        print(row_tuple)
        print('\n')
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/113:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text() for cell in row.find_all('td')]
    print(cell_parced)
#     print('\n')
    for i in range(len(cell_parced)):
        year = cell_parced[i]
        winner = cell_parced[i+1].replace('★ ', '')
        company = cell_parced[i+2]
        producers = cell_parced[i+3]
        return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        print(row_tuple)
        print('\n')
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/114:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text() for cell in row.find_all('td')]
    print(cell_parced)
#     print('\n')
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/115:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text() for cell in row.find_all('td')]
    print(cell_parced)
#     print('\n')
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/116:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text() for cell in row.find_all('td')]
    print(cell_parced)
#     print('\n')
    year = cell_parced[0]
    winner = cell_parced[1].replace('★ ', '')
    company = cell_parced[2]
    producers = cell_parced[3]
    return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/117:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text() for cell in row.find_all('td')]
    print(cell_parced)
#     print('\n')
#     year = cell_parced[0]
#     winner = cell_parced[1].replace('★ ', '')
#     company = cell_parced[2]
#     producers = cell_parced[3]
#     return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/118:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text() for cell in row.find_all('td')]
    print(cell_parced)
#     print('\n')
#     year = cell_parced[0]
#     winner = cell_parced[1].replace('★ ', '')
#     company = cell_parced[2]
#     producers = cell_parced[3]
#     return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    for row in rows:
        print(row)
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/119:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text() for cell in row.find_all('td')]
#     print(cell_parced)
#     print('\n')
#     year = cell_parced[0]
#     winner = cell_parced[1].replace('★ ', '')
#     company = cell_parced[2]
#     producers = cell_parced[3]
#     return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
    print('rows', rows)
    for row in rows:
        print(row)
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/120:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text() for cell in row.find_all('td')]
#     print(cell_parced)
#     print('\n')
#     year = cell_parced[0]
#     winner = cell_parced[1].replace('★ ', '')
#     company = cell_parced[2]
#     producers = cell_parced[3]
#     return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')
#     print('rows', rows)
    for row in rows:
        print(row)
        row_tuple = get_row(row)
        return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/121:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    print(row)
    cell_parced = [cell.get_text() for cell in row.find_all('td')]
#     print(cell_parced)
#     print('\n')
#     year = cell_parced[0]
#     winner = cell_parced[1].replace('★ ', '')
#     company = cell_parced[2]
#     producers = cell_parced[3]
#     return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')]
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/122:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
#     print(row)
    cell_parced = [cell.get_text() for cell in row.find_all('td')]
    print(cell_parced)
#     print('\n')
#     year = cell_parced[0]
#     winner = cell_parced[1].replace('★ ', '')
#     company = cell_parced[2]
#     producers = cell_parced[3]
#     return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')]
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/123:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
#     print(row)
    cell_parced = [cell.get_text() for cell in row.find_all('td')]
    print(cell_parced)
    if len(cell_parced) != 0:
        print('\n')
        year = cell_parced[0]
        winner = cell_parced[1].replace('★ ', '')
        company = cell_parced[2]
        producers = cell_parced[3]
        return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')]
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/124:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
#     print(row)
    cell_parced = [cell.get_text() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        print(cell_parced)
        print('\n')
#         year = cell_parced[0]
#         winner = cell_parced[1].replace('★ ', '')
#         company = cell_parced[2]
#         producers = cell_parced[3]
#         return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')]
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/125:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
#     print(row)
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        print(cell_parced)
        print('\n')
#         year = cell_parced[0]
#         winner = cell_parced[1].replace('★ ', '')
#         company = cell_parced[2]
#         producers = cell_parced[3]
#         return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')]
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/126:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
#     print(row)
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        tmp_year = ''
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
        return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')]
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/127:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
#     print(row)
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        tmp_year = ''
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')]
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/128:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
#     print(row)
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        tmp_year = ''
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')]
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/129:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
#     print(row)
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        tmp_year = ''
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')]
    return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/130:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
#     print(row)
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        tmp_year = ''
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')]
#     return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/131:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
#     print(row)
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        tmp_year = ''
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            print('tmp_year', tmp_year)
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')]
#     return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/132:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year = ''
def get_row(row):
#     print(row)
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            print('tmp_year', tmp_year)
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')]
#     return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/133:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

tmp_year = ''
def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            print('tmp_year', tmp_year)
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')]
#     return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/134:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            print('tmp_year', tmp_year)
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    tmp_year = ''
    row_tuples = [get_row(r) for r in table.find_all('tr')]
#     return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/135:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    tmp_year = ''
    row_tuples = [get_row(r) for r in table.find_all('tr')]
#     return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/136:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    tmp_year = ''
    row_tuples = [get_row(r) for r in table.find_all('tr') if r != 'None']
#     return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/137:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    tmp_year = ''
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::] if r != 'None']
#     return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/138:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

tables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    tmp_year = ''
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
#     return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    

table_for_frame = []
for table in tables:
    res = get_table(table)
    table_for_frame.append(res)




df = pd.DataFrame(table_for_frame)
df
64/139:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    tmp_year = ''
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
def get_frame(tables):    
    for table in tables:
        res = get_table(table)
        return res



table_for_frame = get_frame(wikitables)
df = pd.DataFrame(table_for_frame)
df
64/140:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    tmp_year = ''
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
def get_frame(tables):    
    for table in tables:
        res = get_table(table)
        table_for_frame = [*table_for_frame, *res]



table_for_frame = get_frame(wikitables)
df = pd.DataFrame(table_for_frame)
df
64/141:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    tmp_year = ''
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
def get_frame(tables):    
    for table in tables:
        res = get_table(table)
        table_for_frame = [*table_for_frame, *res]



# table_for_frame = get_frame(wikitables)
df = pd.DataFrame(table_for_frame)
df
64/142:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    tmp_year = ''
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
def get_frame(tables):    
    for table in tables:
        res = get_table(table)
        print(res)
        table_for_frame = [*table_for_frame, *res]



# table_for_frame = get_frame(wikitables)
df = pd.DataFrame(table_for_frame)
df
64/143:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    tmp_year = ''
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
def get_frame(tables):    
    for table in tables:
        res = get_table(table)
        print(res)
#         table_for_frame = [*table_for_frame, *res]



# table_for_frame = get_frame(wikitables)
df = pd.DataFrame(table_for_frame)
df
64/144:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    tmp_year = ''
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
for table in wikitables:
    res = get_table(table)
    print(res)
#         table_for_frame = [*table_for_frame, *res]



# table_for_frame = get_frame(wikitables)
df = pd.DataFrame(table_for_frame)
df
64/145:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    tmp_year = ''
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
for table in wikitables:
    res = get_table(table)
    table_for_frame = table_for_frame + res
#         table_for_frame = [*table_for_frame, *res]



# table_for_frame = get_frame(wikitables)
df = pd.DataFrame(table_for_frame)
df
64/146:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    tmp_year = ''
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
for table in wikitables:
    res = get_table(table)
    table_for_frame = table_for_frame + res
#         table_for_frame = [*table_for_frame, *res]



# table_for_frame = get_frame(wikitables)
df = pd.DataFrame(table_for_frame)
df.head(100)
64/147:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    tmp_year = ''
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples
    print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
for table in wikitables:
    res = get_table(table)
    table_for_frame = table_for_frame + res
#         table_for_frame = [*table_for_frame, *res]



# table_for_frame = get_frame(wikitables)
df = pd.DataFrame(table_for_frame)
df.head(20)
64/148:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')[1::]
    for r in rows:
        return get_row(r)
#     row_tuples = [get_row(r) for r in]
#     return row_tuples
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
for table in wikitables:
    res = get_table(table)
    table_for_frame = table_for_frame + res
#         table_for_frame = [*table_for_frame, *res]



# table_for_frame = get_frame(wikitables)
df = pd.DataFrame(table_for_frame)
df.head(20)
64/149:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')[1::]
    for r in rows:
        return get_row(r)
#     row_tuples = [get_row(r) for r in]
#     return row_tuples
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
for table in wikitables:
    res = get_table(table)
    table_for_frame.append(res)
#         table_for_frame = [*table_for_frame, *res]



# table_for_frame = get_frame(wikitables)
df = pd.DataFrame(table_for_frame)
df.head(20)
64/150:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')[1::]
    for r in rows:
        return get_row(r)
#     row_tuples = [get_row(r) for r in]
#     return row_tuples
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
for table in wikitables:
    res = get_table(table)
    table_for_frame.append(res)
#         table_for_frame = [*table_for_frame, *res]



# table_for_frame = get_frame(wikitables)
df = pd.DataFrame(table_for_frame)
df.head(30)
64/151:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')[1::]
    for r in rows:
        return get_row(r)
#     row_tuples = [get_row(r) for r in]
#     return row_tuples
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
for table in wikitables:
    res = get_table(table)
    print(res)
    table_for_frame.append(res)
#         table_for_frame = [*table_for_frame, *res]



# table_for_frame = get_frame(wikitables)
# df = pd.DataFrame(table_for_frame)
# df.head(30)
64/152:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')[1::]
    for r in rows:
        return get_row(r)
    
    
for table in wikitables:
    res = get_table(table)
    print(table_for_frame)
    table_for_frame.append(res)
#         table_for_frame = [*table_for_frame, *res]



# table_for_frame = get_frame(wikitables)
# df = pd.DataFrame(table_for_frame)
# df.head(30)
64/153:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')[1::]
    for r in rows:
        return get_row(r)
#     row_tuples = [get_row(r) for r in]
#     return row_tuples
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
for table in wikitables:
    res = get_table(table)
    table_for_frame.append(res)
#         table_for_frame = [*table_for_frame, *res]

print(table_for_frame)

# table_for_frame = get_frame(wikitables)
# df = pd.DataFrame(table_for_frame)
# df.head(30)
64/154:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')[1::]
    for r in rows:
        return get_row(r)
#     row_tuples = [get_row(r) for r in]
#     return row_tuples
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
for table in wikitables:
    res = get_table(table)
    print(res)
    pint('\n')
    table_for_frame.append(res)
#         table_for_frame = [*table_for_frame, *res]

# print(table_for_frame)

# table_for_frame = get_frame(wikitables)
# df = pd.DataFrame(table_for_frame)
# df.head(30)
64/155:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')[1::]
    for r in rows:
        return get_row(r)
#     row_tuples = [get_row(r) for r in]
#     return row_tuples
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
for table in wikitables:
    res = get_table(table)
    print(res)
    print('\n')
    table_for_frame.append(res)
#         table_for_frame = [*table_for_frame, *res]

# print(table_for_frame)

# table_for_frame = get_frame(wikitables)
# df = pd.DataFrame(table_for_frame)
# df.head(30)
64/156:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    rows = table.find_all('tr')[1::]
    for r in rows:
        return get_row(r)
#     row_tuples = [get_row(r) for r in]
#     return row_tuples
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
for table in wikitables:
    res = get_table(table)
    print(get_table(table))
    print('\n')
    table_for_frame.append(res)
#         table_for_frame = [*table_for_frame, *res]

# print(table_for_frame)

# table_for_frame = get_frame(wikitables)
# df = pd.DataFrame(table_for_frame)
# df.head(30)
64/157:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
#     rows = table.find_all('tr')[1::]
#     for r in rows:
#         return get_row(r)
    row_tuples = [get_row(r) for r in able.find_all('tr')[1::]]
    return row_tuples
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
for table in wikitables:
    res = get_table(table)
    print('\n')
    table_for_frame.append(res)
#         table_for_frame = [*table_for_frame, *res]

# print(table_for_frame)

# table_for_frame = get_frame(wikitables)
# df = pd.DataFrame(table_for_frame)
# df.head(30)
64/158:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
#     rows = table.find_all('tr')[1::]
#     for r in rows:
#         return get_row(r)
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
for table in wikitables:
    res = get_table(table)
    print('\n')
    table_for_frame.append(res)
#         table_for_frame = [*table_for_frame, *res]

# print(table_for_frame)

# table_for_frame = get_frame(wikitables)
# df = pd.DataFrame(table_for_frame)
# df.head(30)
64/159:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
#     rows = table.find_all('tr')[1::]
#     for r in rows:
#         return get_row(r)
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
for table in wikitables:
    res = get_table(table)
    print('\n')
    print(res)
    table_for_frame.append(res)
#         table_for_frame = [*table_for_frame, *res]

# print(table_for_frame)

# table_for_frame = get_frame(wikitables)
# df = pd.DataFrame(table_for_frame)
# df.head(30)
64/160:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
#     rows = table.find_all('tr')[1::]
#     for r in rows:
#         return get_row(r)
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
for table in wikitables:
    res = get_table(table)
    print('\n')
    print(res)
    table_for_frame += res
#         table_for_frame = [*table_for_frame, *res]

# print(table_for_frame)

# table_for_frame = get_frame(wikitables)
# df = pd.DataFrame(table_for_frame)
# df.head(30)
64/161:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
#     rows = table.find_all('tr')[1::]
#     for r in rows:
#         return get_row(r)
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
for table in wikitables:
    res = get_table(table)
#     print('\n')
#     print(res)
    table_for_frame += res
#         table_for_frame = [*table_for_frame, *res]

# print(table_for_frame)

table_for_frame = get_frame(wikitables)
df = pd.DataFrame(table_for_frame)
df.head(30)
64/162:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
#     rows = table.find_all('tr')[1::]
#     for r in rows:
#         return get_row(r)
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
for table in wikitables:
    res = get_table(table)
#     print('\n')
#     print(res)
    table_for_frame += res
#         table_for_frame = [*table_for_frame, *res]

# print(table_for_frame)

# table_for_frame = get_frame(wikitables)
df = pd.DataFrame(table_for_frame)
df.head(30)
64/163:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
#     rows = table.find_all('tr')[1::]
#     for r in rows:
#         return get_row(r)
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples
#     print('row_tuples', row_tuples)
#     for row in rows:
#         print(row)
#         row_tuple = get_row(row)
#         return row_tuple
    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
#     print('\n')
#     print(res)
    table_for_frame += res
#         table_for_frame = [*table_for_frame, *res]

# print(table_for_frame)

# table_for_frame = get_frame(wikitables)
df = pd.DataFrame(table_for_frame)
df.head(30)
64/164:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df
64/165:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nom = len([i for i in wikitables.find_all('td') if td.match(r'Стивен Спилберг')])
64/166:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df
64/167:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nom = len([i for i in wikitables.find_all('td') if td.match(r'Стивен Спилберг')])
64/168:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'desc', 'producers']
df
64/169:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]


def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = '1222'
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers']
df
64/170:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = df.b.str.contains('Стивен Спилберг')
64/171:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = df.producers.str.contains('Стивен Спилберг')
64/172:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = df.producers.str.contains('Стивен Спилберг')
print(number_of_nominations)
64/173:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = [i for i in df.producers.str.contains('Стивен Спилберг') if i == 'True']
print(number_of_nominations)
64/174:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = [i for i in df.producers.str.contains('Марк Платт') if i == 'True']
print(number_of_nominations)
64/175:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = [i for i in df.producers.str.match(r'Марк Платт') if i == 'True']
print(number_of_nominations)
64/176:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = [i for i in df.producers.str.match(r'Марк Платт') if i == 'True']
print(number_of_nominations)
64/177:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = [i for i in df.producers.str.match(r'Марк Платт') if i == 'True']
print(number_of_nominations)
64/178:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = [print(i for i in df.producers.str.match(r'Марк Платт')]
print(number_of_nominations)
64/179:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = [print(i) for i in df.producers.str.match(r'Марк Платт')]
print(number_of_nominations)
64/180:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = df.str.match(r'Марк Платт')
print(number_of_nominations)
64/181:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = df.producers.str.match(r'Марк Платт')
print(number_of_nominations)
64/182:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = df.producers.str.match(r'Стюарт М. Бессер и Марк Платт')
print(number_of_nominations)
64/183:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = df.producers.str.match(r'[Марк Платт]')
print(number_of_nominations)
64/184:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = df.producers.str.contains(r'[Марк Платт]')
print(number_of_nominations)
64/185:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = df.producers.str.contains('Марк Платт')
print(number_of_nominations)
64/186:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = [i for i in df.producers.str.contains('Марк Платт') if i == 'True']
print(number_of_nominations)
64/187:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = [print(i) for i in df.producers.str.contains('Марк Платт') if i == 'True']
print(number_of_nominations)
64/188:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = [print(i) for i in df.producers.str.contains('Марк Платт')]
print(number_of_nominations)
64/189:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = [print(type(i) for i in df.producers.str.contains('Марк Платт')]
print(number_of_nominations)
64/190:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = [print(type(i)) for i in df.producers.str.contains('Марк Платт')]
print(number_of_nominations)
64/191:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = [print(type(i)) for i in df.producers.str.contains('Марк Платт') if i is True]
print(number_of_nominations)
64/192:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = [i for i in df.producers.str.contains('Марк Платт') if i is True]
print(number_of_nominations)
64/193:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?
import re

number_of_nominations = [i for i in df.producers.str.contains('Стивен Спилберг') if i is True]
print(len(number_of_nominations))
64/194:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year = ''

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = tmp_year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers']
df
64/195:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year = ''

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers']
df
64/196:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
global tmp_year = ''

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers']
df
64/197:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
global tmp_year

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers']
df
64/198:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers']
df
64/199:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    tmp_year
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers']
df
64/200:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year='11'

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers']
df
64/201:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year='11'

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        global tmp_year
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers']
df
64/202:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year='11'

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        nonlocal tmp_year
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers']
df
64/203:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year='11'

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        global tmp_year
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers']
df
64/204:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year=''

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        global tmp_year
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers']
df
64/205:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year=''

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        nonlocal tmp_year
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers']
df
64/206:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year=''

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        global tmp_year
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers']
df
64/207:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        nonlocal tmp_year
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    tmp_year=''
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers']
df
68/1:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year = ''
def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        global tmp_year
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            winner = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            return year, winner, company, producers
        else:
            year = tmp_year
            winner = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            return year, winner, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers']
df
68/2:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year = ''
def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        global tmp_year
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            film = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            is_winner = 'Winner'
            return year, film, company, producers
        else:
            year = tmp_year
            film = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            is_winner = 'Nominee'
            return year, film, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers', 'Победитель']
df
68/3:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year = ''
def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        global tmp_year
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            film = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            is_winner = 'Winner'
            return year, film, company, producers
        else:
            year = tmp_year
            film = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            is_winner = 'Nominee'
            return year, film, company, producers


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'Победитель']
df
68/4:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year = ''
def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        global tmp_year
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            film = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            is_winner = 'Winner'
            return year, film, company, producers, is_winner
        else:
            year = tmp_year
            film = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            is_winner = 'Nominee'
            return year, film, company, producers, is_winner


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers', 'Победитель']
df
68/5:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year = ''
def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        global tmp_year
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            film = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            is_winner = 'Winner'
            return year, film, company, producers, is_winner
        else:
            year = tmp_year
            film = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            is_winner = 'Nominee'
            return year, film, company, producers, is_winner


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/6:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?

winners_table = [i for i in df.winner.str.contains('Winner')]
print(winners_table)
68/7:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
df[df['winner'] == Winner]
68/8:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
df[df['winner'] == 'Winner']
68/9:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
df[df['film'] == 'Крылья']
68/10:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
df[df['film'] == '«Крылья»  ']
68/11:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
df[df['film'] == '«Крылья»']
68/12:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
df[df['winner'] == 'Winner']
68/13:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']
wn.head(50)
68/14:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']
# wn.head(50)
len(wn)
68/15:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]

len(wn)
len(warner_bros_res)
68/16:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]

len(wn)
len(warner_bros_res)
68/17:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]

len(wn)
len(warner_bros_res)
68/18:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]

print(len(wn))
len(warner_bros_res)
68/19:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]
paramount_res = [i for i in wn.company.str.contains('Paramount Pictures') if i is True]

print('Warner Bros.', len(wn))
print('Paramount Pictures ', len(paramount_res))
68/20:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]
paramount_res = [i for i in wn.company.str.contains('Paramount Pictures') if i is True]

print('Warner Bros.', len(warner_bros_res))
print('Paramount Pictures ', len(paramount_res))
68/21:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]
paramount_res = [i for i in wn.company.str.contains('Paramount Pictures') if i is True]

print('Warner Bros.', len(warner_bros_res))
print('Paramount Pictures ', len(paramount_res))

print(f'Warner Bros. получил больше на {len(warner_bros_res) - len(paramount_res)} оскаров чем Paramount Pictures')
68/22:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]
paramount_res = [i for i in wn.company.str.contains('Paramount Pictures') if i is True]

print('Warner Bros.', len(warner_bros_res))
print('Paramount Pictures ', len(paramount_res))

print(f'Warner Bros. получил больше на {len(warner_bros_res) - len(paramount_res)} оскар чем Paramount Pictures')
68/23:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]
paramount_res = [i for i in wn.company.str.contains('Paramount Pictures') if i is True]

print('Warner Bros.', len(warner_bros_res))
print('Paramount Pictures ', len(paramount_res))

print(f'Warner Bros. получил больше на {len(warner_bros_res) - len(paramount_res)} оскар большк, чем Paramount Pictures')
68/24:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]
paramount_res = [i for i in wn.company.str.contains('Paramount Pictures') if i is True]

print('Warner Bros.', len(warner_bros_res))
print('Paramount Pictures ', len(paramount_res))

print(f'Warner Bros. получил больше на {len(warner_bros_res) - len(paramount_res)} оскар больше, чем Paramount Pictures')
68/25:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup_2 = BeautifulSoup(website_url, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    for r in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                if len(cell_parced) > 3:
                    year = cell_parced[0]
                    tmp_year = year
                    actress = cell_parced[2].replace('★ ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'
                    row_tuples.append(tuple(year, film, company, producers, is_winner))
                else:
                    year = tmp_year
                    actress = cell_parced[0]
                    company = cell_parced[1]
                    producers = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple(year, film, company, producers, is_winner))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/26:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup_2 = BeautifulSoup(website_url, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                if len(cell_parced) > 3:
                    year = cell_parced[0]
                    tmp_year = year
                    actress = cell_parced[2].replace('★ ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'
                    row_tuples.append(tuple(year, film, company, producers, is_winner))
                else:
                    year = tmp_year
                    actress = cell_parced[0]
                    company = cell_parced[1]
                    producers = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple(year, film, company, producers, is_winner))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/27:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup_2 = BeautifulSoup(website_url, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                if len(cell_parced) > 3:
                    year = cell_parced[0]
                    tmp_year = year
                    actress = cell_parced[2].replace('★ ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'
                    row_tuples.append(tuple(year, actress, film, role, is_winner))
                else:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple(year, actress, film, role, is_winner))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/28:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup_2 = BeautifulSoup(website_url, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                if len(cell_parced) > 3:
                    year = cell_parced[0]
                    tmp_year = year
                    actress = cell_parced[2].replace('★ ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/29:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup_2 = BeautifulSoup(website_url, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                if len(cell_parced) > 3:
                    year = cell_parced[0]
                    tmp_year = year
                    actress = cell_parced[2].replace('★ ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[0]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/30:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup_2 = BeautifulSoup(website_url, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                if len(cell_parced) > 3:
                    year = cell_parced[0]
                    tmp_year = year
                    actress = cell_parced[2].replace('★ ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
#                 else:
#                     year = tmp_year
#                     actress = cell_parced[0]
#                     film = cell_parced[1]
#                     role = cell_parced[2]
#                     is_winner = 'Nominee'
#                     row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/31:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup_2 = BeautifulSoup(website_url, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            print(cell_parced)
            print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 3:
                    year = cell_parced[0]
                    tmp_year = year
                    actress = cell_parced[2].replace('★ ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
#                 else:
#                     year = tmp_year
#                     actress = cell_parced[0]
#                     film = cell_parced[1]
#                     role = cell_parced[2]
#                     is_winner = 'Nominee'
#                     row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/32:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                if len(cell_parced) > 3:
                    year = cell_parced[0]
                    tmp_year = year
                    actress = cell_parced[2].replace('★ ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/33:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            print(cell_parced)
            print('\n')
            if len(cell_parced) != 0:
#                 if len(cell_parced) > 3:
#                     year = cell_parced[0]
#                     tmp_year = year
#                     actress = cell_parced[2].replace('★ ', '')
#                     film = cell_parced[3]
#                     role = cell_parced[4]
#                     is_winner = 'Winner'
#                     row_tuples.append(tuple([year, actress, film, role, is_winner]))
#                 else:
#                     year = tmp_year
#                     actress = cell_parced[0]
#                     film = cell_parced[1]
#                     role = cell_parced[2]
#                     is_winner = 'Nominee'
#                     row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/34:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            print(cell_parced)
            print('\n')
#             if len(cell_parced) != 0:
#                 if len(cell_parced) > 3:
#                     year = cell_parced[0]
#                     tmp_year = year
#                     actress = cell_parced[2].replace('★ ', '')
#                     film = cell_parced[3]
#                     role = cell_parced[4]
#                     is_winner = 'Winner'
#                     row_tuples.append(tuple([year, actress, film, role, is_winner]))
#                 else:
#                     year = tmp_year
#                     actress = cell_parced[0]
#                     film = cell_parced[1]
#                     role = cell_parced[2]
#                     is_winner = 'Nominee'
#                     row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/35:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            print(cell_parced)
            print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 3:
                    year = cell_parced[0]
                    actress = cell_parced[2].replace('★ ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) = 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/36:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            print(cell_parced)
            print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 3:
                    year = cell_parced[0]
                    actress = cell_parced[2].replace('★ ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/37:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 3:
                    year = cell_parced[0]
                    actress = cell_parced[2].replace('★ ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/38:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) >= 4:
                    year = cell_parced[0]
                    actress = cell_parced[2].replace('★ ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/39:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 3:
                            print(cell_parced)
            print('\n')
                    year = cell_parced[0]
                    actress = cell_parced[2].replace('★ ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/41:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 3:
                    print(cell_parced)
                    print('\n')
                    year = cell_parced[0]
                    actress = cell_parced[2].replace('★ ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/42:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 4:
                    year = cell_parced[0]
                    actress = cell_parced[2].replace('★ ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = cell_parced[0]
                    actress = cell_parced[1].replace('★ ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
                    is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/43:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 4:
                    year = re.sub(r'^(\d{4})', '', cell_parced[0])
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = cell_parced[0]
                    actress = cell_parced[1].replace('★ ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
                    is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/44:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 4:
                    year = re.sub(r'(\d{4})', '', cell_parced[0])
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = cell_parced[0]
                    actress = cell_parced[1].replace('★ ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
                    is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/45:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 4:
                    year = re.sub(r'^(\d{4})', '', cell_parced[0])
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = cell_parced[0]
                    actress = cell_parced[1].replace('★ ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
                    is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/46:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 4:
                    year = re.re.search('\d{4}', cell_parced[0]).group(0)
#                     sub(r'^(\d{4})', '', cell_parced[0])
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = cell_parced[0]
                    actress = cell_parced[1].replace('★ ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
                    is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/47:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
#                     sub(r'^(\d{4})', '', cell_parced[0])
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = cell_parced[0]
                    actress = cell_parced[1].replace('★ ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
                    is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/48:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('★ ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
                    is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/49:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('★ ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
                    is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'actress', 'film', 'role', 'winner']
df.head(50)
68/50:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('★ ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
                    is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'actress', 'film', 'role', 'winner']
df.head(50)
68/51:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].text.replace('★ ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
                    is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'actress', 'film', 'role', 'winner']
df.head(50)
68/52:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].get_text().replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('★ ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
                    is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'actress', 'film', 'role', 'winner']
df.head(50)
68/53:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('★ ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
                    is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'actress', 'film', 'role', 'winner']
df.head(50)
68/54:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
                    is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'actress', 'film', 'role', 'winner']
df.head(50)
68/55:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
                    is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0]
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'actress', 'film', 'role', 'winner']
df.head(50)
68/56:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
                    is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'actress', 'film', 'role', 'winner']
df.head(50)
68/57:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
                    is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    print(cell_parced)
                    print('\n')
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'actress', 'film', 'role', 'winner']
# df.head(50)
68/58:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
                    is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
                    is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    print(row)
                    print('\n')
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'actress', 'film', 'role', 'winner']
# df.head(50)
68/59:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
#                     is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
#                     is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
#                     is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    print(row)
                    print('\n')
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
#                     is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'actress', 'film', 'role', 'winner']
# df.head(50)
68/60:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
#                     is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
#                     is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
#                     is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
#                     is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'actress', 'film', 'role', 'winner']
# df.head(50)
68/61:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
#             print(cell_parced)
#             print('\n')
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]
#                     is_winner = 'Winner'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]
#                     is_winner = 'хз'                    
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
#                     is_winner = 'Nominee'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
#                     is_winner = 'хз'
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'actress', 'film', 'role', 'winner']
df.head(50)
68/62:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
df_1.head(20)
68/63:
# 1. Какая актриса чаще всего номинировалась на Оскар?
df_1.actress.mode
68/64:
# 1. Какая актриса чаще всего номинировалась на Оскар?
df_1.actress.mode()
68/65: df_1.actress.value_counts()[:5].sort_values(ascending=False)
68/66:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

# df_1.actress.value_counts()[:5].sort_values(ascending=False)

df_1[df_1['actress'] == 'Кэтрин Хепбёрн']
68/67:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
df_1[100, 300]
68/68:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
df_1[100]
68/69:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
df_1tail(10)
68/70:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
df_1.tail(10)
68/71:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
df_1.iloc[-3:]
68/72:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
df_1.iloc[-100:]
68/73:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
df_1.iloc[500:]
68/74:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
df_1.iloc[-500:]
68/75:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
print(df[50:55])
68/76:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
print(df_1[50:55])
68/77:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
print(df_1[60:68])
68/78:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
print(df_1[110:120])
68/79:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
print(df_1[150:160])
68/80:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
print(df_1[190:200])
68/81:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    print(cell_parced)
                    print('\n')
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[2].replace('• ', '')
                    film = cell_parced[3]
                    role = cell_parced[4]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
print(df_1[190:200])
68/82:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    if cell_parced[1] != '':
                        actress = cell_parced[2].replace('• ', '')
                        film = cell_parced[3]
                        role = cell_parced[4]                   
                        tmp_year = year
                        tmp_actress = actress
                    else:
                        actress = cell_parced[1].replace('• ', '')
                        film = cell_parced[2]
                        role = cell_parced[3]                   
                        tmp_year = year
                        tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
print(df_1[190:200])
68/83:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    if cell_parced[1] != '':
                        actress = cell_parced[2].replace('• ', '')
                        film = cell_parced[3]
                        role = cell_parced[4]                   
                        tmp_year = year
                        tmp_actress = actress
                    else:
                        actress = cell_parced[1].replace('• ', '')
                        film = cell_parced[2]
                        role = cell_parced[3]                   
                        tmp_year = year
                        tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
print(df_1[190:200])
68/84:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

# df_1.actress.value_counts()[:5].sort_values(ascending=False)

df_1[df_1['actress'] == 'Кэтрин Хепбёрн']
68/85:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    if cell_parced[1] != '':
                        print('11 cell_parced', cell_parced)
                        actress = cell_parced[2].replace('• ', '')
                        film = cell_parced[3]
                        role = cell_parced[4]                   
                        tmp_year = year
                        tmp_actress = actress
                    else:
                        print('22 cell_parced', cell_parced)
                        actress = cell_parced[1].replace('• ', '')
                        film = cell_parced[2]
                        role = cell_parced[3]                   
                        tmp_year = year
                        tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
print(df_1[190:200])
68/86:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    if cell_parced[1] == '':
                        print('11 cell_parced', cell_parced)
                        actress = cell_parced[2].replace('• ', '')
                        film = cell_parced[3]
                        role = cell_parced[4]                   
                        tmp_year = year
                        tmp_actress = actress
                    else:
                        print('22 cell_parced', cell_parced)
                        actress = cell_parced[1].replace('• ', '')
                        film = cell_parced[2]
                        role = cell_parced[3]                   
                        tmp_year = year
                        tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
print(df_1[190:200])
68/87:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    if cell_parced[1] == '':
                        actress = cell_parced[2].replace('• ', '')
                        film = cell_parced[3]
                        role = cell_parced[4]                   
                        tmp_year = year
                        tmp_actress = actress
                    else:
                        actress = cell_parced[1].replace('• ', '')
                        film = cell_parced[2]
                        role = cell_parced[3]                   
                        tmp_year = year
                        tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
print(df_1[190:200])
68/88:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    if cell_parced[1] == '':
                        actress = cell_parced[2].replace('• ', '')
                        film = cell_parced[3]
                        role = cell_parced[4]                   
                        tmp_year = year
                        tmp_actress = actress
                    else:
                        actress = cell_parced[1].replace('• ', '')
                        film = cell_parced[2]
                        role = cell_parced[3]                   
                        tmp_year = year
                        tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
print(df_1[190:200])
df_1.head(20)
68/89:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    if cell_parced[1] == '':
                        actress = cell_parced[2].replace('• ', '')
                        film = cell_parced[3]
                        role = cell_parced[4]                   
                        tmp_year = year
                        tmp_actress = actress
                    else:
                        actress = cell_parced[1].replace('• ', '')
                        film = cell_parced[2]
                        role = cell_parced[3]                   
                        tmp_year = year
                        tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
# print(df_1[190:200])
df_1.head(20)
68/90:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

df_1.actress.value_counts()[:5].sort_values(ascending=False)

# df_1[df_1['actress'] == 'Кэтрин Хепбёрн']
68/91:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

# df_1.actress.value_counts()[:5].sort_values(ascending=False)

df_1[df_1['actress'] == ' Норма Ширер']
68/92:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

# df_1.actress.value_counts()[:5].sort_values(ascending=False)

df_1[df_1['actress'] == 'Норма Ширер']
68/93:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_2 = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D1%83%D1%8E_%D0%B6%D0%B5%D0%BD%D1%81%D0%BA%D1%83%D1%8E_%D1%80%D0%BE%D0%BB%D1%8C'
website_url_2 = requests.get(link_2).text
soup_2 = BeautifulSoup(website_url_2, 'lxml')

women_wikitables = soup_2.find_all('table', {'class': 'wikitable'})


def get_table(table):
    rows = table.find_all('tr')[1::]
    row_tuples = []
    tmp_year = ''
    tmp_actress = ''
    for row in rows:
            cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
            if len(cell_parced) != 0:
                is_winner_cells = [cell for cell in row.find_all('td',{'style':'background:#EEDD82'})]
                is_winner = len(is_winner_cells) != 0
                if len(cell_parced) > 4:
                    
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    if cell_parced[1] == '':
                        actress = cell_parced[2].replace('• ', '')
                        film = cell_parced[3]
                        role = cell_parced[4]                   
                        tmp_year = year
                        tmp_actress = actress
                    else:
                        actress = cell_parced[1].replace('• ', '')
                        film = cell_parced[2]
                        role = cell_parced[3]                   
                        tmp_year = year
                        tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 4:
                    year = re.search('\d{4}', cell_parced[0]).group(0)
                    actress = cell_parced[1].replace('• ', '')
                    film = cell_parced[2]
                    role = cell_parced[3]                   
                    tmp_year = year
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                elif len(cell_parced) == 3:
                    year = tmp_year
                    actress = cell_parced[0].replace('• ', '')
                    film = cell_parced[1]
                    role = cell_parced[2]
                    tmp_actress = actress
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
                else:
                    year = tmp_year
                    actress = tmp_actress
                    film = cell_parced[0]
                    role = cell_parced[1]
                    row_tuples.append(tuple([year, actress, film, role, is_winner]))
    return row_tuples

    
    
table_for_frame = []
for table in women_wikitables:
    res = get_table(table)
    table_for_frame += res


df_1 = pd.DataFrame(table_for_frame)
df_1.columns = ['year', 'actress', 'film', 'role', 'winner']
df_1.head(20)
68/94:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

# df_1.actress.value_counts()[:5].sort_values(ascending=False)

df_1[df_1['actress'] == 'Норма Ширер']
68/95:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

# df_1.actress.value_counts()[:5].sort_values(ascending=False)
68/96:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

df_1.actress.value_counts()[:5].sort_values(ascending=False)
68/97:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

df_1.actress.value_counts()[:5].sort_values(ascending=False)

delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]

print(delta_nominee)
68/98:
# 1. Какая актриса чаще всего номинировалась на Оскар?
df_1.actress.mode()
68/99:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

# df_1.actress.value_counts()[:5].sort_values(ascending=False)

delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]

print(delta_nominee)
68/100:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

# df_1.actress.value_counts()[:5].sort_values(ascending=False)

delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]

print(delta_nominee)
68/101:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

# df_1.actress.value_counts()[:5].sort_values(ascending=False)

delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]

print()
68/102:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

df_1.actress.value_counts()[:1].sort_values(ascending=False)

# delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]

print()
68/103:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

df_1.actress.value_counts()[:1].sort_values(ascending=False)

# delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]

print()
68/104:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

df_1.actress.value_counts()[:1].sort_values(ascending=False)

# delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]
68/105:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

name, oscars = df_1.actress.value_counts()[:1].sort_values(ascending=False)

# delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]
print(name, oscars)
68/106:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

name, oscars = df_1.actress.value_counts()[:1](sort=False)


# delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]
print(name, oscars)
68/107:
# 1. Какая актриса чаще всего номинировалась на Оскар?
df_1.actress.mode()
68/108:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

name, oscars = df_1.actress.value_counts()[:1].sort_values(ascending=False)

# delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]
print(name, oscars)
68/109:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

df_1.actress.value_counts()[:1].sort_values(ascending=False)

# delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]
print(name, oscars)
68/110:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

df_1.actress.value_counts()[:1].sort_values(ascending=False)

# delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]
# print(name, oscars)
68/111:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

df_1.actress.value_counts()[:2].sort_values(ascending=False)

# delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]
# print(name, oscars)
68/112:
# 1. Какая актриса чаще всего номинировалась на Оскар?
df_1.actress.mode()
68/113:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

wm = df_1.actress.value_counts()[:2].sort_values(ascending=False)
print(wm)
# delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]
# print(name, oscars)
68/114:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

wm = df_1.actress.value_counts()[:2].sort_values(ascending=False)

print(wm)
wm.loc[df.Name=='actress','Name'].values[0]

# delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]
# print(name, oscars)
68/115:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

wm = df_1.actress.value_counts()[:2].sort_values(ascending=False)

print(wm)
wm.loc[df.Name=='actress'].values[0]

# delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]
# print(name, oscars)
68/116:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

wm = df_1.actress.value_counts()[:2].sort_values(ascending=False)

print(wm)
wm.loc[df.Name].values[0]

# delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]
# print(name, oscars)
68/117:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

wm = df_1.actress.value_counts()[:2].sort_values(ascending=False)

print(wm)
wm.loc[wm.Name].values[0]

# delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]
# print(name, oscars)
68/118:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

wm = df_1.actress.value_counts()[:2].sort_values(ascending=False)

print(wm)
wm.loc[wm.Name].values[0]

# delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]
# print(name, oscars)
68/119:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

wm = df_1.actress.value_counts()[:2].sort_values(ascending=False)

print(wm)
wm.values[0]

# delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]
# print(name, oscars)
68/120:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

wm = df_1.actress.value_counts()[:2].sort_values(ascending=False)

print(wm)
wm.values[1]

# delta_nominee = df_1.actress.value_counts().max() - df_1.actress.value_counts()[:5]
# print(name, oscars)
68/121:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

wm = df_1.actress.value_counts()[:2].sort_values(ascending=False)

print(wm)
wm.values[1]

print('Ответ: ' wm.values[0] - wm.values[1])
68/122:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

wm = df_1.actress.value_counts()[:2].sort_values(ascending=False)

print(wm)
wm.values[1]

print(f'Ответ: ' {wm.values[0] - wm.values[1]})
68/123:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

wm = df_1.actress.value_counts()[:2].sort_values(ascending=False)

print(wm)
osc_0 = wm.values[0]
osc_1 = wm.values[1]

print(f'Ответ: ' {osc_0 - osc_1})
68/124:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

wm = df_1.actress.value_counts()[:2].sort_values(ascending=False)

print(wm)
osc_delta = wm.values[0] - wm.values[1]

print(f'Ответ: {osc_delta}')
68/125:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

wm = df_1.actress.value_counts()[:2].sort_values(ascending=False)

osc_delta = wm.values[0] - wm.values[1]

print(f'Ответ: {osc_delta}')
68/126:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

wm = df_1.actress.value_counts()[:2].sort_values(ascending=False)

print(wm)
osc_delta = wm.values[0] - wm.values[1]

print(f'Ответ: {osc_delta}')
68/127:
#     2. Насколько отличается количество номинаций самой часто номинировавшейся актрисы и второй по частоте?

wm = df_1.actress.value_counts()[:5].sort_values(ascending=False)

print(wm)
osc_delta = wm.values[0] - wm.values[1]

print(f'Ответ: {osc_delta}')
68/128:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find_all('table', {'class': 'table'})
68/129:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find_all('table', {'class': 'table'})

population_dict = {}

headers = [h.get_text().strip() for h in population_table.find_all('th')]

for header in headers:
    print(header)
68/130:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find_all('table', {'class': 'table'})
print(population_table)
# population_dict = {}

# headers = [h.get_text().strip() for h in population_table.find_all('th')]

# for header in headers:
#     print(header)
68/131:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find_all('table', {'class': 'table'})

population_dict = {}

headers = [h.get_text().strip() for h in population_table.find_all('th')]

for header in headers:
    print(header)
68/132:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

headers = [h.get_text().strip() for h in population_table.find_all('th')]

for header in headers:
    print(header)
68/133:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows = [r.get_text().strip() for h in population_table.find_all('tr')]

for header, index in headers:
    population_dict[header] = []
    print(index)
68/134:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

headers = [h.get_text().strip() for h in population_table.find_all('th')]

# rows = [r.get_text().strip() for h in population_table.find_all('tr')]

for header, index in headers:
    population_dict[header] = []
    print(index)
68/135:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

headers = [h.get_text().strip() for h in population_table.find_all('th')]

# rows = [r.get_text().strip() for h in population_table.find_all('tr')]

for idx, header in headers:
    population_dict[header] = []
    print(idx)
68/136:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

headers = [h.get_text().strip() for h in population_table.find_all('th')]

# rows = [r.get_text().strip() for h in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
    print(idx)
68/137:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

headers = [h.get_text().strip() for h in population_table.find_all('th')]

# rows = [r.get_text().strip() for h in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
    print(idx, header)
68/138:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def get_cells_in_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/139:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def get_cells_in_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    print(cell_parced)
    return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/140:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def get_cells_in_row(row):
    cell_parced = [float(cell.get_text().strip().replace(',', ''))) for cell in row.find_all('td')]
    print(cell_parced)
    return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/141:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def get_cells_in_row(row):
    cell_parced = [float(cell.get_text().strip().replace(',', '')) for cell in row.find_all('td')]
    print(cell_parced)
    return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/142:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def get_cells_in_row(row):
    cell_parced = [float(cell.get_text().strip().replace('%', '')) for cell in row.find_all('td')]
    print(cell_parced)
    return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/143:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def get_cells_in_row(row):
    cell_parced = [float(cell.get_text().strip().replace(r'[,|%]', '')) for cell in row.find_all('td')]
    print(cell_parced)
    return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/144:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def get_cells_in_row(row):
    cell_parced = [float(re.sub("[^\d\.]", "", cell.get_text().strip()) for cell in row.find_all('td')]
    print(cell_parced)
    return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/145:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def get_cells_in_row(row):
    cell_parced = [float(re.sub("[^\d\.]", "", cell.get_text().strip()) for cell in row.find_all('td')]
    print(cell_parced)
    return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/146:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def get_cells_in_row(row):
    cell_parced = [float(re.sub("[^\d\.]", "", cell.get_text().strip() ) for cell in row.find_all('td')]
    print(cell_parced)
    return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/147:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def get_cells_in_row(row):
    cell_parced = [float(re.sub("[^\d]", "", cell.get_text().strip() ) for cell in row.find_all('td')]
    print(cell_parced)
    return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/148:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def get_cells_in_row(row):
    cell_parced = [float(re.sub("[^\d\.]", "", cell.get_text().strip())) for cell in row.find_all('td')]
    print(cell_parced)
    return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/149:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def get_cells_in_row(row):
    cells_row = row.find_all('td')
    if len(cells_row) != 0:
        cell_parced = [float(re.sub("[^\d\.]", "", cell.get_text().strip())) for cell in row.find_all('td')]
        print(cell_parced)
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/150:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif: number.match(r'\d{4}'):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", cell.get_text().strip()))
        
def get_cells_in_row(row):
    cells_row = row.find_all('td')
    if len(cells_row) != 0:
        cell_parced = [convert_number(cell) for cell in row.find_all('td')]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/151:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif number.match(r'\d{4}'):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", cell.get_text().strip()))
        
def get_cells_in_row(row):
    cells_row = row.find_all('td')
    if len(cells_row) != 0:
        cell_parced = [convert_number(cell) for cell in row.find_all('td')]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/152:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.match(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", cell.get_text().strip()))
        
def get_cells_in_row(row):
    cells_row = row.find_all('td')
    if len(cells_row) != 0:
        cell_parced = [convert_number(cell) for cell in row.find_all('td')]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/153:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.match('\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", cell.get_text().strip()))
        
def get_cells_in_row(row):
    cells_row = row.find_all('td')
    if len(cells_row) != 0:
        cell_parced = [convert_number(cell) for cell in row.find_all('td')]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/154:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.match('d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", cell.get_text().strip()))
        
def get_cells_in_row(row):
    cells_row = row.find_all('td')
    if len(cells_row) != 0:
        cell_parced = [convert_number(cell) for cell in row.find_all('td')]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/155:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", cell.get_text().strip()))
        
def get_cells_in_row(row):
    cells_row = row.find_all('td')
    if len(cells_row) != 0:
        cell_parced = [convert_number(cell) for cell in row.find_all('td')]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/156:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    print(number)
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", cell.get_text().strip()))
        
def get_cells_in_row(row):
    cells_row = row.find_all('td')
    if len(cells_row) != 0:
        cell_parced = [convert_number(cell) for cell in row.find_all('td')]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/157:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    print(number)
    print('\n')
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", cell.get_text().strip()))
        
def get_cells_in_row(row):
    cells_row = row.find_all('td')
    if len(cells_row) != 0:
        cell_parced = [convert_number(cell) for cell in row.find_all('td')]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/158:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    print(number)
    print('\n')
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row = row.find_all('td')
    if len(cells_row) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in row.find_all('td')]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)
68/159:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row = row.find_all('td')
    if len(cells_row) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in row.find_all('td')]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)

print(rows_of_cells)
68/160:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row = row.find_all('td')
    if len(cells_row) != 0:
        print(cells_row)
        cell_parced = [convert_number(cell.get_text().strip()) for cell in row.find_all('td')]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)

# print(rows_of_cells)
68/161:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    for cells_row in cells_row_list:
        if len(cells_row) != 0:
            print(cells_row)
            cell_parced = [convert_number(cell.get_text().strip()) for cell in row.find_all('td')]
            return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)

# print(rows_of_cells)
68/162:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    for cells_row in cells_row_list:
        if len(cells_row) != 0:
            cell_parced = [convert_number(cell.get_text().strip()) for cell in row.find_all('td')]
            return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)

# print(rows_of_cells)
68/163:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    for cells_row in cells_row_list:
        if len(cells_row) != 0:
            cell_parced = [convert_number(cell.get_text().strip()) for cell in row.find_all('td')]
            return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)

print(rows_of_cells)
68/164:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    for cells_row in cells_row_list:
        if len(cells_row) != 0:
            print(cells_row)
            print('\n')
            cell_parced = [convert_number(cell.get_text().strip()) for cell in row.find_all('td')]
            return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)

print(rows_of_cells)
68/165:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    print(row)
    print('\n')
    cells_row_list = row.find_all('td')
    for cells_row in cells_row_list:
        if len(cells_row) != 0:
#             print(cells_row)
#             print('\n')
            cell_parced = [convert_number(cell.get_text().strip()) for cell in row.find_all('td')]
            return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)

print(rows_of_cells)
68/166:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    print(row)
    print('\n')
    cells_row_list = row.find_all('td')
    print(cells_row_list)
    for cells_row in cells_row_list:
        if len(cells_row) != 0:
#             print(cells_row)
#             print('\n')
            cell_parced = [convert_number(cell.get_text().strip()) for cell in row.find_all('td')]
            return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)

print(rows_of_cells)
68/167:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):

    cells_row_list = row.find_all('td')
    print(cells_row_list)
    for cells_row in cells_row_list:
        if len(cells_row) != 0:
#             print(cells_row)
#             print('\n')
            cell_parced = [convert_number(cell.get_text().strip()) for cell in row.find_all('td')]
            return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)

print(rows_of_cells)
68/168:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
      print(cells_row_list)
      print('\n')
        cell_parced = [convert_number(cell.get_text().strip()) for cell in row.find_all('td')]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)

print(rows_of_cells)
68/169:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        print(cells_row_list)
        print('\n')
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = []
#     print(idx, header)

print(rows_of_cells)
68/170:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

# for idx, header in enumerate(headers):
#     population_dict[header] = []
# #     print(idx, header)

print(rows_of_cells)
df_3 = pd.DataFrame(rows_of_cells)
df_3.columns = [h.get_text().strip() for h in population_table.find_all('th')]
df_3
68/171:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

# for idx, header in enumerate(headers):
#     population_dict[header] = []
# #     print(idx, header)

# print(rows_of_cells)
df_3 = pd.DataFrame(rows_of_cells)
df_3.columns = [h.get_text().strip() for h in population_table.find_all('th')]
df_3
68/172:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

# for idx, header in enumerate(headers):
#     population_dict[header] = []
# #     print(idx, header)

# print(rows_of_cells)
df_3 = pd.DataFrame(rows_of_cells)
# df_3.columns = [h.get_text().strip() for h in population_table.find_all('th')]
df_3
68/173:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

# for idx, header in enumerate(headers):
#     population_dict[header] = []
# #     print(idx, header)

print(rows_of_cells)
# df_3 = pd.DataFrame(rows_of_cells)
# df_3.columns = [h.get_text().strip() for h in population_table.find_all('th')]
# df_3
68/174:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows_of_cells]
#     print(idx, header)

print(population_dict)
# df_3 = pd.DataFrame(rows_of_cells)
# df_3.columns = [h.get_text().strip() for h in population_table.find_all('th')]
# df_3
68/175:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr') if len(r)!= 0]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows_of_cells]
#     print(idx, header)

print(population_dict)
# df_3 = pd.DataFrame(rows_of_cells)
# df_3.columns = [h.get_text().strip() for h in population_table.find_all('th')]
# df_3
68/176:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr') if len(r)!= 0]

# for idx, header in enumerate(headers):
#     population_dict[header] = [i[idx] for i in rows_of_cells]
#     print(idx, header)

print(rows_of_cells)
# df_3 = pd.DataFrame(rows_of_cells)
# df_3.columns = [h.get_text().strip() for h in population_table.find_all('th')]
# df_3
68/177:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr') if print(r)]

# for idx, header in enumerate(headers):
#     population_dict[header] = [i[idx] for i in rows_of_cells]
#     print(idx, header)

print(rows_of_cells)
# df_3 = pd.DataFrame(rows_of_cells)
# df_3.columns = [h.get_text().strip() for h in population_table.find_all('th')]
# df_3
68/178:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]

# for idx, header in enumerate(headers):
#     population_dict[header] = [i[idx] for i in rows_of_cells]
#     print(idx, header)

print(rows_of_cells)
# df_3 = pd.DataFrame(rows_of_cells)
# df_3.columns = [h.get_text().strip() for h in population_table.find_all('th')]
# df_3
68/179:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

# for idx, header in enumerate(headers):
#     population_dict[header] = [i[idx] for i in rows_of_cells]
#     print(idx, header)

print(rows_of_cells)
# df_3 = pd.DataFrame(rows_of_cells)
# df_3.columns = [h.get_text().strip() for h in population_table.find_all('th')]
# df_3
68/180:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

# for idx, header in enumerate(headers):
#     population_dict[header] = [i[idx] for i in rows_of_cells]
#     print(idx, header)

print(rows)
# df_3 = pd.DataFrame(rows_of_cells)
# df_3.columns = [h.get_text().strip() for h in population_table.find_all('th')]
# df_3
68/181:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

# print(rows)
print(population_dict)
# df_3 = pd.DataFrame(rows_of_cells)
# df_3.columns = [h.get_text().strip() for h in population_table.find_all('th')]
# df_3
68/182:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

# print(rows)
print(population_dict)
df_3 = pd.DataFrame(population_dict)

df_3
68/183:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/184:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        print('number', number)
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

# df_3 = pd.DataFrame(population_dict)
# df_3
68/185:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        print('number', number)
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]
print(population_dict)
# df_3 = pd.DataFrame(population_dict)
# df_3
68/186:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        print('number', number)
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/187:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/188:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return int(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/189:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/190:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        print(number)
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/191:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    print(number, type(number))
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/192:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    print(number, type(number))
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return str(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/193:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return str(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/194:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

pl = df_3.plot(x='year', y='World Population')
68/195:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

pl = df_3.plot(x='Year', y='World Population')
68/196:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return str(number)
    else:
        return str(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/197:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

pl = df_3.plot(x='Year', y='World Population')
68/198:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return str(number)
    else:
        return int(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/199:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return str(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/200:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

pl = df_3.plot(x='Year', y='World Population')
68/201:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    elif re.search(r'.', number):
        return float(number)
    else:
        return int(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/202:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return int(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/203:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return int(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/204:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/205:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.find("\d+\.\d+", number):
        return float(re.sub("[^\d]", "", number))
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/206:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search("\d+\.\d+", number):
        return float(re.sub("[^\d]", "", number))
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/207:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search("\d+\.\d+", number):
        return float(re.sub("[^\d\.]", "", number))
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/208:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search("\d+\.\d+", number):
        return float(re.sub("[^\d\.]", "", number))
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d\.]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/209:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search("\d+\.\d+", number):
        return float(re.sub("[^\d\.]", "", number))
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return float(re.sub("[^\d]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/210:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search("\d+\.\d+", number):
        return float(re.sub("[^\d\.]", "", number))
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return int(re.sub("[^\d]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/211:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

pl = df_3.plot(x='Year', y='World Population')
68/212:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:69]


# pl = df_3.plot(x='Year', y='World Population')
68/213:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:69]
decr_df

# pl = df_3.plot(x='Year', y='World Population')
68/214:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:69]
decr_df.head(70)

# pl = df_3.plot(x='Year', y='World Population')
68/215:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)

# pl = df_3.plot(x='Year', y='World Population')
68/216:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]
paramount_res = [i for i in wn.company.str.contains('Paramount') if i is True]

print('Warner Bros.', len(warner_bros_res))
print('Paramount Pictures ', len(paramount_res))

print(f'Warner Bros. получил больше на {len(warner_bros_res) - len(paramount_res)} оскар больше, чем Paramount Pictures')
68/217:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year = ''
def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        global tmp_year
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            film = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            is_winner = 'Winner'
            return year, film, company, producers, is_winner
        else:
            year = tmp_year
            film = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            is_winner = 'Nominee'
            return year, film, company, producers, is_winner


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/218:
# 1. Сколько раз были номинированы фильмы, созданные при участии Стивена Спилберга?

number_of_nominations = [i for i in df.producers.str.contains('Стивен Спилберг') if i is True]
print(len(number_of_nominations))
68/219:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]
paramount_res = [i for i in wn.company.str.contains('Paramount') if i is True]

print('Warner Bros.', len(warner_bros_res))
print('Paramount Pictures ', len(paramount_res))

print(f'Warner Bros. получил больше на {len(warner_bros_res) - len(paramount_res)} оскар больше, чем Paramount Pictures')
68/220:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]

paramount_res = [i for i in wn.company.str.contains(' Paramount Pictures') if i is True]

print('Warner Bros.', len(warner_bros_res))
print('Paramount Pictures ', len(paramount_res))

print(f'Warner Bros. получил больше на {len(warner_bros_res) - len(paramount_res)} оскар больше, чем Paramount Pictures')
68/221:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]

paramount_res = [i for i in wn.company.str.contains(' Paramount Pictures') if i is True]

print('Warner Bros.', len(warner_bros_res))
print('Paramount Pictures ', len(paramount_res))

print(f'Warner Bros. получил больше на {len(warner_bros_res) - len(paramount_res)} оскар больше, чем Paramount Pictures')
68/222:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]

paramount_res = [i for i in wn.company.str.contains(' Paramount Pictures') if i is True]

print('Warner Bros.', len(warner_bros_res))
print('Paramount Pictures ', len(paramount_res))

print(f'Warner Bros. получил больше на {len(warner_bros_res) - len(paramount_res)} оскар больше, чем Paramount Pictures')
68/223:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]
# Считаю некоректным засчитывать просто Paramount
paramount_res = [i for i in wn.company.str.contains('Paramount') if i is True]

print('Warner Bros.', len(warner_bros_res))
print('Paramount Pictures ', len(paramount_res))

print(f'Paramount Pictures получил больше на {len(warner_bros_res) - len(paramount_res)} оскара больше, чем Warner Bros.')
68/224:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]
# Считаю некоректным засчитывать просто Paramount
paramount_res = [i for i in wn.company.str.contains('Paramount') if i is True]

print('Warner Bros.', len(warner_bros_res))
print('Paramount Pictures ', len(paramount_res))

print(f'Paramount Pictures получил больше на {len(paramount_res) - len(warner_bros_res)} оскара больше, чем Warner Bros.')
68/225:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search("\d+\.\d+", number):
        return float(re.sub("[^\d\.]", "", number))
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return int(re.sub("[^\d]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/226:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)

# pl = df_3.plot(x='Year', y='World Population')
68/227:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
diff =  df['Difference UrbanPop'] = df['UrbanPop'].diff(periods=-1)
# pl = df_3.plot(x='Year', y='World Population')
68/228:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
decr_df['Difference UrbanPop'] = decr_df['UrbanPop'].diff(periods=-1)
# pl = df_3.plot(x='Year', y='World Population')
decr_df
68/229:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year = ''
def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        global tmp_year
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            film = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            is_winner = 'Winner'
            return year, film, company, producers, is_winner
        else:
            year = tmp_year
            film = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            is_winner = 'Nominee'
            return year, film, company, producers, is_winner


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res

print(table_for_frame)
# df = pd.DataFrame(table_for_frame)
# df.columns = ['year', 'film', 'company', 'producers', 'winner']
# df
68/230:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year = ''
def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        global tmp_year
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            film = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            is_winner = 'Winner'
            return year, film, company, producers, is_winner
        else:
            year = tmp_year
            film = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            is_winner = 'Nominee'
            return year, film, company, producers, is_winner


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/231:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year = ''

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        global tmp_year
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            film = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            is_winner = 'Winner'
            return year, film, company, producers, is_winner
        else:
            year = tmp_year
            film = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            is_winner = 'Nominee'
            return year, film, company, producers, is_winner


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table) [(row), (row), (1,2,3,td ), ()]
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers', 'winner']
df.head(20)
68/232:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year = ''

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        global tmp_year
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            film = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            is_winner = 'Winner'
            return year, film, company, producers, is_winner
        else:
            year = tmp_year
            film = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            is_winner = 'Nominee'
            return year, film, company, producers, is_winner


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers', 'winner']
df.head(20)
68/233:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]
# Считаю некоректным засчитывать просто Paramount
paramount_res = [i for i in wn.company.str.contains('Paramount') if i is True]

print('Warner Bros.', len(warner_bros_res))
print('Paramount Pictures ', len(paramount_res))

print(f'Paramount Pictures получил больше на {len(paramount_res) - len(warner_bros_res)} оскара больше, чем Warner Bros.')
wn
68/234:
# 2. Фильмы какой компании получили больше Оскаров за лучший фильм: Warner Bros. или Paramount Pictures и насколько больше?
wn = df[df['winner'] == 'Winner']

warner_bros_res = [i for i in wn.company.str.contains('Warner Bros') if i is True]
# Считаю некоректным засчитывать просто Paramount
paramount_res = [i for i in wn.company.str.contains('Paramount') if i is True]

print('Warner Bros.', len(warner_bros_res))
print('Paramount Pictures ', len(paramount_res))

print(f'Paramount Pictures получил больше на {len(paramount_res) - len(warner_bros_res)} оскара больше, чем Warner Bros.')
68/235:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search("\d+\.\d+", number):
        return float(re.sub("[^\d\.]", "", number))
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return int(re.sub("[^\d]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

print(rows)

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

# df_3 = pd.DataFrame(population_dict)
# df_3
68/236:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search("\d+\.\d+", number):
        return float(re.sub("[^\d\.]", "", number))
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return int(re.sub("[^\d]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

# print(rows)

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

print(population_dict)
# df_3 = pd.DataFrame(population_dict)
# df_3
68/237:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search("\d+\.\d+", number):
        return float(re.sub("[^\d\.]", "", number))
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return int(re.sub("[^\d]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

print(population_dict)
df_3 = pd.DataFrame(population_dict)
df_3
68/238:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link_3 = 'https://www.worldometers.info/world-population/world-population-by-year/'
website_url_3 = requests.get(link_3).text
soup_3 = BeautifulSoup(website_url_3, 'lxml')

population_table = soup_3.find('table', {'class': 'table'})

population_dict = {}

def convert_number(number):
    if number == '':
        return 0
    elif re.search("\d+\.\d+", number):
        return float(re.sub("[^\d\.]", "", number))
    elif re.search(r'\d{4}', number):
        return int(number)
    else:
        return int(re.sub("[^\d]", "", number))
        
def get_cells_in_row(row):
    cells_row_list = row.find_all('td')
    if len(cells_row_list) != 0:
        cell_parced = [convert_number(cell.get_text().strip()) for cell in cells_row_list]
        return cell_parced

headers = [h.get_text().strip() for h in population_table.find_all('th')]

rows_of_cells = [get_cells_in_row(r) for r in population_table.find_all('tr')]
rows =  [x for x in rows_of_cells if x is not None]

for idx, header in enumerate(headers):
    population_dict[header] = [i[idx] for i in rows]

df_3 = pd.DataFrame(population_dict)
df_3
68/239:
import requests
import re
from bs4 import BeautifulSoup
import pandas as pd


link = 'https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D0%B8%D1%8F_%C2%AB%D0%9E%D1%81%D0%BA%D0%B0%D1%80%C2%BB_%D0%B7%D0%B0_%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B9_%D1%84%D0%B8%D0%BB%D1%8C%D0%BC'
website_url = requests.get(link).text
soup = BeautifulSoup(website_url, 'lxml')

wikitables = soup.find_all('table', {'class': 'wikitable'})[:11:1]
tmp_year = ''

def get_row(row):
    cell_parced = [cell.get_text().strip() for cell in row.find_all('td')]
    if len(cell_parced) != 0:
        global tmp_year
        if len(cell_parced) > 3:
            year = cell_parced[0]
            tmp_year = year
            film = cell_parced[1].replace('★ ', '')
            company = cell_parced[2]
            producers = cell_parced[3]
            is_winner = 'Winner'
            return year, film, company, producers, is_winner
        else:
            year = tmp_year
            film = cell_parced[0]
            company = cell_parced[1]
            producers = cell_parced[2]
            is_winner = 'Nominee'
            return year, film, company, producers, is_winner


def get_table(table):
    row_tuples = [get_row(r) for r in table.find_all('tr')[1::]]
    return row_tuples

    
    
table_for_frame = []
for table in wikitables:
    res = get_table(table)
    table_for_frame += res


df = pd.DataFrame(table_for_frame)
df.columns = ['year', 'film', 'company', 'producers', 'winner']
df
68/240:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
decr_df.loc['Difference UrbanPop'] = decr_df['UrbanPop'].diff(periods=-1)
# pl = df_3.plot(x='Year', y='World Population')
decr_df
68/241:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
decr_df.loc[7, 'Difference UrbanPop'] = decr_df['UrbanPop'].diff(periods=-1)
# pl = df_3.plot(x='Year', y='World Population')
decr_df
68/242:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
decr_df.loc[7] = decr_df['UrbanPop'].diff(periods=-1)
# pl = df_3.plot(x='Year', y='World Population')
decr_df
68/243:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
decr_df.loc[:'Difference UrbanPop'] = decr_df['UrbanPop'].diff(periods=-1)
# pl = df_3.plot(x='Year', y='World Population')
decr_df
68/244:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
decr_df.loc[:'Difference UrbanPop'] = decr_df['UrbanPop'].diff(periods=-1)
# pl = df_3.plot(x='Year', y='World Population')
decr_df
68/245:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
decr_df['Difference UrbanPop'] = decr_df['UrbanPop'].diff(periods=-1)
# pl = df_3.plot(x='Year', y='World Population')
decr_df
68/246:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
decr_df[decr_df['UrbanPop'].diff(periods=-1),7] = new_val
# pl = df_3.plot(x='Year', y='World Population')
decr_df
68/247:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
decr_df[decr_df['UrbanPop'].diff(periods=-1),7] = '1'
# pl = df_3.plot(x='Year', y='World Population')
decr_df
68/248:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)
# decr_df[,7] = '1'
# pl = df_3.plot(x='Year', y='World Population')
decr_df
68/249:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)
# decr_df[,7] = '1'
# pl = df_3.plot(x='Year', y='World Population')
decr_df.append(urban_diff)
68/250:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)
# decr_df[,7] = '1'
# pl = df_3.plot(x='Year', y='World Population')
urban_diff
68/251:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)
# decr_df[,7] = '1'
# pl = df_3.plot(x='Year', y='World Population')
x = [print(i) for i in urban_diff]
68/252:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)
# decr_df[,7] = '1'
# pl = df_3.plot(x='Year', y='World Population')
lst = [print(i) for i in urban_diff]
population_dict['urban_diff'] = lst
pd.DataFrame(population_dict)
68/253:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)
# decr_df[,7] = '1'
# pl = df_3.plot(x='Year', y='World Population')
lst = [i for i in urban_diff]
population_dict['urban_diff'] = lst
pd.DataFrame(population_dict)
68/254:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)
# decr_df[,7] = '1'
# pl = df_3.plot(x='Year', y='World Population')
plot_1 = {}
plot_1['urban_diff'] = [i for i in urban_diff]
68/255:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)
# decr_df[,7] = '1'
# pl = df_3.plot(x='Year', y='World Population')
plot_1 = {}
plot_1['urban_diff'] = [i for i in urban_diff]
df_4 = pd.DataFrame(plot_1)
df_4
68/256:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)
# decr_df[,7] = '1'
# pl = df_3.plot(x='Year', y='World Population')
plot_1 = {}
decr_df['urban_diff'] = [i for i in urban_diff]
68/257:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [i for i in urban_diff])

decr_df
68/258:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [print(type(i)) for i in urban_diff] if )

# decr_df
68/259:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [i for i in urban_diff] if )
[print(type(i)) for i in urban_diff
# decr_df
68/260:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [i for i in urban_diff])
[print(type(i)) for i in urban_diff]
# decr_df
68/261:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [i for i in urban_diff] if i is None return 0)
[print(type(i)) for i in urban_diff]
# decr_df
68/262:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [if i is None return 0 else return i for i in urban_diff] )
[print(type(i)) for i in urban_diff]
# decr_df
68/263:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [x = 0 if is None else i i for i in urban_diff] )

decr_df
68/264:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [(0 if is None else i) for i in urban_diff] )

decr_df
68/265:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [(0 if i is None else i) for i in urban_diff] )

decr_df
68/266:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [(0 if i == 'NaN' else i) for i in urban_diff] )

decr_df
68/267:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [(print(i) if i == 'NaN' else i) for i in urban_diff] )

decr_df
68/268:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [(print(i) if i == 'NaN' else i) for i in urban_diff] )

[(print(i) if i == 'NaN' else i) for i in urban_diff]
# decr_df
68/269:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [(print(i) if i == 'nan' else i) for i in urban_diff] )

# [(print(i) if i == 'NaN' else i) for i in urban_diff]
decr_df
68/270:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [(print(i) if i == 'nan' else i) for i in urban_diff] )

[(print(i) if i == 'NaN' else i) for i in urban_diff]
# decr_df
68/271:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [(print(i) if i == 'nan' else i) for i in urban_diff] )

[(print(type(i) if i == 'NaN' else i) for i in urban_diff]
# decr_df
68/272:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [(print(i) if i == 'nan' else i) for i in urban_diff] )

[(print(type(i)) if i == 'NaN' else i) for i in urban_diff]
# decr_df
68/273:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

# decr_df = decr_df.assign(address = [(print(i) if i == 'nan' else i) for i in urban_diff] )

[(print(type(i))) for i in urban_diff]
# decr_df
68/274:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

# decr_df = decr_df.assign(address = [(print(i) if i == 'nan' else i) for i in urban_diff] )

[(print(type(i) is None)) for i in urban_diff]
# decr_df
68/275:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

# decr_df = decr_df.assign(address = [(print(i) if i == 'nan' else i) for i in urban_diff] )

[(print(i)) for i in urban_diff]
# decr_df
68/276:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

# decr_df = decr_df.assign(address = [(print(i) if i == 'nan' else i) for i in urban_diff] )

[(print(i)isnull()) for i in urban_diff]
# decr_df
68/277:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

# decr_df = decr_df.assign(address = [(print(i) if i == 'nan' else i) for i in urban_diff] )

[(print(i).isnull()) for i in urban_diff]
# decr_df
68/278:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

# decr_df = decr_df.assign(address = [(print(i) if i == 'nan' else i) for i in urban_diff] )

[(print(i).isnull().values.any()) for i in urban_diff]
# decr_df
68/279:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [(print(i) if i == 'nan' else i) for i in urban_diff] )


decr_df
68/280:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [(0 if i == 'nan' else i) for i in urban_diff] )


decr_df
p = df.plot(x='dt', y='value')
68/281:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [(0 if i is None else i) for i in urban_diff] )


decr_df
p = df.plot(x='dt', y='value')
68/282:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(address = [(0 if i is None else i) for i in urban_diff] )


decr_df
# p = df.plot(x='dt', y='value')
68/283:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(Urban_diff = [(0 if i is None else i) for i in urban_diff] )


decr_df
pl = df.plot(x='Year', y='Urban_diff')
68/284:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(Urban_diff = [(0 if i is None else i) for i in urban_diff] )


decr_df
# pl = df.plot(x='Year', y='Urban_diff')
68/285:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(Urban_diff = [(0 if i is None else i) for i in urban_diff] )


decr_df
pl = df.plot(x='Year', y='UrbanPop')
68/286:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(Urban_diff = [(0 if i is None else i) for i in urban_diff] )


decr_df
pl = df.plot(x='Year', y='UrbanPop')
68/287:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(Urban_diff = [(0 if i is None else i) for i in urban_diff] )


decr_df
# pl = df.plot(x='Year', y='UrbanPop')
68/288:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(Urban_diff = [(0 if i is None else i) for i in urban_diff] )


decr_df
pl = decr_df.plot(x='Year', y='UrbanPop')
68/289:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(Urban_diff = [(0 if i is None else i) for i in urban_diff] )


decr_df
pl = decr_df.plot(x='Year', y='UrbanPop')
68/290:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(Urban_diff = [(0 if i is None else i) for i in urban_diff] )


decr_df
# pl = decr_df.plot(x='Year', y='UrbanPop')
68/291:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)

decr_df = decr_df.assign(Urban_diff = [(0 if i is None else i) for i in urban_diff] )


decr_df
pl = decr_df.plot(x='Year', y='Urban_diff')
68/292: pl1 = decr_df.plot(x='Year', y='World_diff')
68/293:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)
world_diff = decr_df['World Population'].diff(periods=-1)

decr_df = decr_df.assign(Urban_diff = [(0 if i is None else i) for i in urban_diff] )
decr_df = decr_df.assign(World_diff = [(0 if i is None else i) for i in world_diff] )

decr_df
68/294: pl1 = decr_df.plot(x='Year', y='Urban_diff')
68/295: pl1 = decr_df.plot(x='Year', y='World_diff')
68/296:
# нарисовать графики ежегодного прироста городского населения и ежегодного прироста общего населения, начиная с 1951 года

decr_df = df_3[:70]
decr_df.head(70)
urban_diff = decr_df['UrbanPop'].diff(periods=-1)
world_diff = decr_df['World Population'].diff(periods=-1)

decr_df = decr_df.assign(Urban_diff = [(0 if i is None else i) for i in urban_diff] )
decr_df = decr_df.assign(World_diff = [(0 if i is None else i) for i in world_diff] )
72/1:
import requests
from bs4 import BeautifulSoup
url1 = 'https://www.worldometers.info/coronavirus/'
72/2:
url = 'https://www.worldometers.info/coronavirus/'
website = requests.get(url).text
soup = BeautifulSoup(website, 'lxml')
# soup
72/3: len(soup.find_all('table'))
72/4: soup.find_all('table')[0]
72/5:
table = soup.find_all('table')[0]
# table
72/6:
table = soup.find_all('table')[0]
# table
72/7:
col1 = []

col1.append(rows[0].find_all('th')[1].get_text().strip()) # отдельно добавляем заголовок

for row in rows[1:]: # начинаем со второго ряда таблицы, потому что 0 уже обработали выше
    r = row.find_all('td') # находим все теги td для строки таблицы
    col1.append(r[1].get_text().strip()) # сохраняем данные в наш список

print(col1)
72/8:
col1 = []

col1.append(rows[0].find_all('th')[1].get_text().strip()) # отдельно добавляем заголовок

for row in rows[1:]: # начинаем со второго ряда таблицы, потому что 0 уже обработали выше
    r = row.find_all('td') # находим все теги td для строки таблицы
    col1.append(r[1].get_text().strip()) # сохраняем данные в наш список

print(col1)
72/9: soup.find_all('table')[0]
72/10:
table = soup.find_all('table')[0]
# table
72/11:
rows = table.find_all('tr')
# rows
72/12: rows[0].find_all('th')[1].get_text().strip()
72/13: rows[1].find_all('td')[1].get_text().strip()
72/14:
col1 = []

col1.append(rows[0].find_all('th')[1].get_text().strip()) # отдельно добавляем заголовок

for row in rows[1:]: # начинаем со второго ряда таблицы, потому что 0 уже обработали выше
    r = row.find_all('td') # находим все теги td для строки таблицы
    col1.append(r[1].get_text().strip()) # сохраняем данные в наш список

print(col1)
72/15: col1[:232][-1]
72/16:
col2 = []

col2.append(rows[0].find_all('th')[2].get_text().strip()) # отдельно добавляем заголовок

for row in rows[1:]: # начинаем со второго ряда таблицы, потому что 0 уже обработали выше
    r = row.find_all('td') # находим все теги td для строки таблицы
    col2.append(r[2].get_text().strip()) # сохраняем данные в наш список

print(col2)
72/17:
field_list = []
for i in range(9):
    col = []
    col.append(rows[0].find_all('th')[i+1].get_text().strip()) # отдельно добавляем заголовок
    for row in rows[1:]: # начинаем со второго ряда таблицы, потому что 0 уже обработали выше
        r = row.find_all('td') # находим все теги td для строки таблицы
        col.append(r[i+1].get_text().strip()) # сохраняем данные в наш список
    field_list.append(col)
72/18:
col2 = []

col2.append(rows[0].find_all('th')[2].get_text().strip()) # отдельно добавляем заголовок

for row in rows[1:]: # начинаем со второго ряда таблицы, потому что 0 уже обработали выше
    r = row.find_all('td') # находим все теги td для строки таблицы
    col2.append(r[2].get_text().strip()) # сохраняем данные в наш список

print(col2)
72/19:
field_list = []
for i in range(9):
    col = []
    col.append(rows[0].find_all('th')[i+1].get_text().strip()) # отдельно добавляем заголовок
    for row in rows[1:]: # начинаем со второго ряда таблицы, потому что 0 уже обработали выше
        r = row.find_all('td') # находим все теги td для строки таблицы
        col.append(r[i+1].get_text().strip()) # сохраняем данные в наш список
    field_list.append(col)
72/20: field_list[2][0]
72/21:
d = dict()
for i in range(9):
    d[field_list[i][0]] = field_list[i][1:]
# d
72/22:
import pandas as pd 
df = pd.DataFrame(d)
df.head(10)
72/23: df = df.rename(columns={'Country,Other': 'Country', 'Serious,Critical': 'SeriousCritical'})
72/24:
def stat(tag = 0):
    url = 'https://www.worldometers.info/coronavirus/'
    website = requests.get(url).text
    soup = BeautifulSoup(website, 'lxml')
    table = soup.find_all('table')[tag]
    rows = table.find_all('tr')
    d = dict()
    for i in range(9):
        col = []
        key = rows[0].find_all('th')[i+1].get_text().strip()
        
        for row in rows[1:230]:
            r = row.find_all('td')
            col.append(r[i+1].get_text().strip())
        d[key] = col
    df = pd.DataFrame(d)
    df = df.rename(columns = {'Country,Other':'Country', 'Serious,Critical':'SeriousCritical'})
    return df
72/25: stat().head(10)
72/26:
d = dict()
for i in range(9):
    d[field_list[i][0]] = field_list[i][1:]
# d
72/27:
import pandas as pd 
df = pd.DataFrame(d)
df.head(10)
72/28: df.head(8)
72/29:
def stat(tag = 0):
    url = 'https://www.worldometers.info/coronavirus/'
    website = requests.get(url).text
    soup = BeautifulSoup(website, 'lxml')
    table = soup.find_all('table')[tag]
    rows = table.find_all('tr')
    d = dict()
    for i in range(9):
        col = []
        key = rows[0].find_all('th')[i+1].get_text().strip()
        
        for row in rows[1:230]:
            r = row.find_all('td')
            col.append(r[i+1].get_text().strip())
        d[key] = col
    df = pd.DataFrame(d)
    df = df.rename(columns = {'Country,Other':'Country', 'Serious,Critical':'SeriousCritical'})
    return df
72/30: list(stat()['Country'][:8])
72/31: print(*list(i+'\n' for i in list(stat()['Country'][:8]) if i!=''))
72/32:
x = stat()['Country'][8:230]
', '.join([e+'\n' if i%6 == 5 else e for i,e in enumerate(x)])
72/33:
x = stat()['Country'][8:232]
import re
# print(x)
print(', '.join([e+'\n' if i%6 == 5 else e for i,e in enumerate(x)]).replace('\n,',',\n'))
72/34:
x = stat()['Country'][8:232]
import re
# print(x)
print(', '.join([e+'\n' if i%6 == 5 else e for i,e in enumerate(x)]).replace('\n,',',\n'))
72/35: !pip install tabulate
72/36: from tabulate import tabulate
72/37: from tabulate import tabulate
72/38: df[['Country','TotalCases']][df['Country']=='UK'].reset_index(drop=True)
72/39: from tabulate import tabulate
72/40: df[['Country','TotalCases']][df['Country']=='UK'].reset_index(drop=True)
72/41: df[['Country','TotalCases']][df['Country']=='UK'].reset_index(drop=True)
72/42: df[['Country','TotalCases']][df['Country']=='UK'].reset_index(drop=True)
72/43: df[['Country','TotalCases']][df['Country']=='UK'].reset_index(drop=True)
72/44:
x = df[['Country','TotalCases']][df['Country']=='UK'].reset_index(drop=True)
print(tabulate(x, headers = x.columns, tablefmt="grid"))
72/45: from tabulate import tabulate
72/46: df[['Country','TotalCases']][df['Country']=='UK'].reset_index(drop=True)
72/47: df[['Country','TotalCases']][df['Country']=='UK'].reset_index(drop=True)
72/48: df[['Country','TotalCases']][df['Country']=='UK'].reset_index(drop=True)
72/49:
import requests
from bs4 import BeautifulSoup
url1 = 'https://www.worldometers.info/coronavirus/'
72/50:
url = 'https://www.worldometers.info/coronavirus/'
website = requests.get(url).text
soup = BeautifulSoup(website, 'lxml')
# soup
72/51: len(soup.find_all('table'))
72/52: soup.find_all('table')[0]
72/53:
table = soup.find_all('table')[0]
# table
72/54:
rows = table.find_all('tr')
# rows
72/55: rows[0].find_all('th')[1].get_text().strip()
72/56: rows[1].find_all('td')[1].get_text().strip()
72/57:
col1 = []

col1.append(rows[0].find_all('th')[1].get_text().strip()) # отдельно добавляем заголовок

for row in rows[1:]: # начинаем со второго ряда таблицы, потому что 0 уже обработали выше
    r = row.find_all('td') # находим все теги td для строки таблицы
    col1.append(r[1].get_text().strip()) # сохраняем данные в наш список

print(col1)
72/58: col1[:232][-1]
72/59:
col2 = []

col2.append(rows[0].find_all('th')[2].get_text().strip()) # отдельно добавляем заголовок

for row in rows[1:]: # начинаем со второго ряда таблицы, потому что 0 уже обработали выше
    r = row.find_all('td') # находим все теги td для строки таблицы
    col2.append(r[2].get_text().strip()) # сохраняем данные в наш список

print(col2)
72/60:
field_list = []
for i in range(9):
    col = []
    col.append(rows[0].find_all('th')[i+1].get_text().strip()) # отдельно добавляем заголовок
    for row in rows[1:]: # начинаем со второго ряда таблицы, потому что 0 уже обработали выше
        r = row.find_all('td') # находим все теги td для строки таблицы
        col.append(r[i+1].get_text().strip()) # сохраняем данные в наш список
    field_list.append(col)
72/61: field_list[2][0]
72/62:
d = dict()
for i in range(9):
    d[field_list[i][0]] = field_list[i][1:]
# d
72/63:
import pandas as pd 
df = pd.DataFrame(d)
df.head(10)
72/64: df.head(8)
72/65: df = df.rename(columns={'Country,Other': 'Country', 'Serious,Critical': 'SeriousCritical'})
72/66: df.head(8)
72/67:
def stat(tag = 0):
    url = 'https://www.worldometers.info/coronavirus/'
    website = requests.get(url).text
    soup = BeautifulSoup(website, 'lxml')
    table = soup.find_all('table')[tag]
    rows = table.find_all('tr')
    d = dict()
    for i in range(9):
        col = []
        key = rows[0].find_all('th')[i+1].get_text().strip()
        
        for row in rows[1:230]:
            r = row.find_all('td')
            col.append(r[i+1].get_text().strip())
        d[key] = col
    df = pd.DataFrame(d)
    df = df.rename(columns = {'Country,Other':'Country', 'Serious,Critical':'SeriousCritical'})
    return df
72/68: stat().head(10)
72/69: list(stat()['Country'][:8])
72/70: print(*list(i+'\n' for i in list(stat()['Country'][:8]) if i!=''))
72/71:
x = stat()['Country'][8:230]
', '.join([e+'\n' if i%6 == 5 else e for i,e in enumerate(x)])
72/72:
x = stat()['Country'][8:232]
import re
# print(x)
print(', '.join([e+'\n' if i%6 == 5 else e for i,e in enumerate(x)]).replace('\n,',',\n'))
72/73: !pip install tabulate
72/74: from tabulate import tabulate
72/75: df[['Country','TotalCases']][df['Country']=='UK'].reset_index(drop=True)
72/76:
x = df[['Country','TotalCases']][df['Country']=='UK'].reset_index(drop=True)
print(tabulate(x, headers = x.columns, tablefmt="grid"))
72/77:
from enum import Enum

class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3
72/78: Color.RED
72/79:
x = df[['Country','TotalCases']][df['Country']=='UK'].reset_index(drop=True)
print(tabulate(x, headers = x.columns, tablefmt="html"))
72/80:
x = df[['Country','TotalCases']][df['Country']=='UK'].reset_index(drop=True)
print(tabulate(x, headers = x.columns, tablefmt="unsafehtml"))
# html
72/81:
x = df[['Country','TotalCases']][df['Country']=='UK'].reset_index(drop=True)
print(tabulate(x, headers = x.columns, tablefmt="unsafehtml"))
# html
72/82:
x = df[['Country','TotalCases']][df['Country']=='UK'].reset_index(drop=True)
print(tabulate(x, headers = x.columns, tablefmt="unsafehtml"))

print(tabulate(x, headers = x.columns, tablefmt="html"))
# html
# unsafehtml
72/83:
class Stages(Enum):
    START = 1
    DAY = 2
    COUNTRY_REGION = 3
73/1: 9 + 8*9
73/2: 9 + 8*9 + 8*(9**2)
73/3: 9 + 8*9 + 8*(9**2) + 8*(9**3)
73/4: 9 + 8*9 + 8*(9**2) + 8*(9**3) + 8*(9**4) + 8*(9**5)
73/5: a = 9 + 8*9 + 8*(9**2) + 8*(9**3) + 8*(9**4) + 8*(9**5)
73/6:
a = 9 + 8*9 + 8*(9**2) + 8*(9**3) + 8*(9**4) + 8*(9**5)

a
73/7:
b = 10000001
b-a
73/8:
b = 1000001
b-a
73/9:
a = 9 + 8*9 + 8*(9**2) + 8*(9**3) + 8*(9**4) + 8*(9**5) + 8*(9**65)

a
73/10:
a = 9 + 8*9 + 8*(9**2) + 8*(9**3) + 8*(9**4) + 8*(9**5) + 8*(9**6)

a
73/11:
b = 10000001
b-a
74/1:
import numpy as np
scores = np.array([[20, 40, 56, 80, 0, 5, 25, 27, 74, 1],
         [0, 98, 67, 100, 8, 56, 34, 82, 100, 7],
         [78, 54, 23, 79, 100, 0, 0, 42, 95, 83],
         [51, 50, 47, 23, 100, 94, 25, 48, 38, 77],
         [90, 87, 41, 89, 52, 0, 5, 17, 28, 99],
         [32, 18, 21, 18, 29, 31, 48, 62, 76, 22],
         [6, 0, 65, 78, 43, 22, 38, 88, 94, 100],
         [77, 28, 39, 41, 0, 81, 45, 54, 98, 12],
         [66, 0, 88, 0, 44, 0, 55, 100, 12, 11],
         [17, 70, 86, 96, 56, 23, 32, 49, 70, 80],
         [20, 24, 76, 50, 29, 40, 3, 2, 5, 11],
         [33, 63, 28, 40, 51, 100, 98, 87, 22, 30],
         [16, 54, 78, 12, 25, 35, 10, 19, 67, 0],
         [100, 88, 24, 33, 47, 56, 62, 34, 77, 53],
         [50, 89, 70, 72, 56, 29, 15, 20, 0, 0]])
75/1:
x = np.array([[[6, 3],
        [6, 8]],
      [[1, 100],
        [0, 1]]])  # трехмерный
75/2: import numpy as np
75/3:
x = np.array([[[6, 3],
        [6, 8]],
      [[1, 100],
        [0, 1]]])  # трехмерный
75/4: x[1][0][1] # вторая колонка первой строки второго измерения
75/5:
x = np.array([[[6, 3],
        [6, 8]],
      [[1, 100],
        [0, 1]]])  # трехмерный
x
75/6:
lst = [[0, 0, 1],
         [0, 1]]
lst
75/7:
np.array([[0, 0, 1],
         [0, 1]])
75/8:
s = [2,1]
s*2
75/9: np.arange(5)
75/10:
m = np.zeros((5, 5))
print(m)
m += np.arange(5)
print(m)
75/11:
import os
os.getcwd()
75/12:
a = np.array([3, 1, 5, 2])
b = np.array([2, 5, 2, 4])
# <a, b> = 3*1 + 1*5 + 5*2 + 2*4
print(a @ b)    # python 3 style
print(a.dot(b)) 
print(np.dot(a, b))
75/13:
a = np.array([3, 1, 5, 2])
b = np.array([2, 5, 2, 4, 4])
print(a @ b)    # python 3 style
75/14:
a = np.array([[1, 2], [2, 0]])
b = np.array([[2,5], [1, 3]])
# print(a)
# print(b)
print(a @ b)    # python 3 style
print(a.dot(b)) 
print(np.dot(a, b))
75/15:
a = np.array([[1, 2], [2, 0]])
b = np.array([1, 2])
print(a @ b)
74/2:
import numpy as np
scores = np.array([[20, 40, 56, 80, 0, 5, 25, 27, 74, 1],
         [0, 98, 67, 100, 8, 56, 34, 82, 100, 7],
         [78, 54, 23, 79, 100, 0, 0, 42, 95, 83],
         [51, 50, 47, 23, 100, 94, 25, 48, 38, 77],
         [90, 87, 41, 89, 52, 0, 5, 17, 28, 99],
         [32, 18, 21, 18, 29, 31, 48, 62, 76, 22],
         [6, 0, 65, 78, 43, 22, 38, 88, 94, 100],
         [77, 28, 39, 41, 0, 81, 45, 54, 98, 12],
         [66, 0, 88, 0, 44, 0, 55, 100, 12, 11],
         [17, 70, 86, 96, 56, 23, 32, 49, 70, 80],
         [20, 24, 76, 50, 29, 40, 3, 2, 5, 11],
         [33, 63, 28, 40, 51, 100, 98, 87, 22, 30],
         [16, 54, 78, 12, 25, 35, 10, 19, 67, 0],
         [100, 88, 24, 33, 47, 56, 62, 34, 77, 53],
         [50, 89, 70, 72, 56, 29, 15, 20, 0, 0]])
74/3: a = scores[scores == 0]
74/4: a = scores[scores == 0]
74/5:
a = scores[scores == 0]
a
74/6:
a = scores[scores == 0].size()
a
74/7:
a = scores[scores == 0].size
a
74/8: b = scores[scores > 50]
74/9:
b = scores[scores > 50]
v
74/10:
a = scores[scores == 0].size
a
74/11: a = scores[scores == 0].size
74/12:
a = scores[scores == 0].size
a
74/13:
b = scores[scores > 50]
b
74/14:
b = scores[scores > 50].size
b
78/1:
import numpy as np
scores = np.array([[20, 40, 56, 80, 0, 5, 25, 27, 74, 1],
         [0, 98, 67, 100, 8, 56, 34, 82, 100, 7],
         [78, 54, 23, 79, 100, 0, 0, 42, 95, 83],
         [51, 50, 47, 23, 100, 94, 25, 48, 38, 77],
         [90, 87, 41, 89, 52, 0, 5, 17, 28, 99],
         [32, 18, 21, 18, 29, 31, 48, 62, 76, 22],
         [6, 0, 65, 78, 43, 22, 38, 88, 94, 100],
         [77, 28, 39, 41, 0, 81, 45, 54, 98, 12],
         [66, 0, 88, 0, 44, 0, 55, 100, 12, 11],
         [17, 70, 86, 96, 56, 23, 32, 49, 70, 80],
         [20, 24, 76, 50, 29, 40, 3, 2, 5, 11],
         [33, 63, 28, 40, 51, 100, 98, 87, 22, 30],
         [16, 54, 78, 12, 25, 35, 10, 19, 67, 0],
         [100, 88, 24, 33, 47, 56, 62, 34, 77, 53],
         [50, 89, 70, 72, 56, 29, 15, 20, 0, 0]])
78/2:
import numpy as np
scores = np.array([[20, 40, 56, 80, 0, 5, 25, 27, 74, 1],
         [0, 98, 67, 100, 8, 56, 34, 82, 100, 7],
         [78, 54, 23, 79, 100, 0, 0, 42, 95, 83],
         [51, 50, 47, 23, 100, 94, 25, 48, 38, 77],
         [90, 87, 41, 89, 52, 0, 5, 17, 28, 99],
         [32, 18, 21, 18, 29, 31, 48, 62, 76, 22],
         [6, 0, 65, 78, 43, 22, 38, 88, 94, 100],
         [77, 28, 39, 41, 0, 81, 45, 54, 98, 12],
         [66, 0, 88, 0, 44, 0, 55, 100, 12, 11],
         [17, 70, 86, 96, 56, 23, 32, 49, 70, 80],
         [20, 24, 76, 50, 29, 40, 3, 2, 5, 11],
         [33, 63, 28, 40, 51, 100, 98, 87, 22, 30],
         [16, 54, 78, 12, 25, 35, 10, 19, 67, 0],
         [100, 88, 24, 33, 47, 56, 62, 34, 77, 53],
         [50, 89, 70, 72, 56, 29, 15, 20, 0, 0]])
78/3:
b = scores[scores > 50]
b
78/4:
(scores > 50)
b
78/5: (scores > 50)
78/6:
(scores > 50)
b
78/7:
(scores > 50).sum()
b
78/8: (scores > 50).sum()
78/9: (scores >= 50) and (scores <=70)
78/10: (scores >= 50) & (scores <=70)
78/11: ((scores >= 50) & (scores <=70)).sum()
78/12: np.mean(scores, axis=1)
78/13: np.mean(scores, axis=1).max()
78/14: np.mean(scores, axis=1)
78/15:
mean_scores = np.mean(scores, axis=1)
mean_scores.where(mean_scores.hign())
78/16:
mean_scores = np.mean(scores, axis=1)
mean_scores.where(mean_scores.high())
78/17:
mean_scores = array(np.mean(scores, axis=1))
mean_scores.where(mean_scores.high())
78/18:
mean_scores = np.array(np.mean(scores, axis=1))
mean_scores.where(mean_scores.high())
78/19:
mean_scores = np.array([np.mean(scores, axis=1)])
mean_scores.where(mean_scores.high())
78/20:
arr = np.mean(scores, axis=1)
np.where(arr.high())
78/21:
arr = np.mean(scores, axis=1)
np.where(arr > 15)
78/22:
np.mean(scores, axis=1)
# np.where(arr > 15)
78/23:
np.mean(scores, axis=1).high()
# np.where(arr > 15)
78/24: np.mean(scores, axis=1).high()
78/25: np.mean(scores, axis=1).high
78/26:
arr = np.mean(scores, axis=1)
arr.where(arr.max())
78/27:
arr = np.mean(scores, axis=1)
arr.where(arr.max())
78/28:
arr = np.mean(scores, axis=1)
arr.where(arr.max())
78/29:
arr = np.mean(scores, axis=1)
np.where(arr.max())
78/30:
arr = np.array([np.mean(scores, axis=1)])
np.where(arr.max())
78/31:
arr = np.array([np.mean(scores, axis=1)])
np.where(arr.max())
78/32:
arr = np.array([np.mean(scores, axis=1)])
arr.where(arr.max())
78/33:
arr = np.array([np.mean(scores, axis=1)])
arr
78/34:
arr = np.array(np.mean(scores, axis=1))
arr
78/35:
arr = np.array(np.mean(scores, axis=1))
arr.where(arr>15)
78/36:
np.array(np.mean(scores, axis=1)).max()
# arr.where(arr>15)
78/37:
np.array(np.mean(scores, axis=1)).max().index
# arr.where(arr>15)
78/38:
np.array(np.mean(scores, axis=1)).max().index()
# arr.where(arr>15)
78/39:
np.array(np.mean(scores, axis=1))
# arr.where(arr>15)
78/40:
import numpy as np
scores = np.array([[20, 40, 56, 80, 0, 5, 25, 27, 74, 1],
         [0, 98, 67, 100, 8, 56, 34, 82, 100, 7],
         [78, 54, 23, 79, 100, 0, 0, 42, 95, 83],
         [51, 50, 47, 23, 100, 94, 25, 48, 38, 77],
         [90, 87, 41, 89, 52, 0, 5, 17, 28, 99],
         [32, 18, 21, 18, 29, 31, 48, 62, 76, 22],
         [6, 0, 65, 78, 43, 22, 38, 88, 94, 100],
         [77, 28, 39, 41, 0, 81, 45, 54, 98, 12],
         [66, 0, 88, 0, 44, 0, 55, 100, 12, 11],
         [17, 70, 86, 96, 56, 23, 32, 49, 70, 80],
         [20, 24, 76, 50, 29, 40, 3, 2, 5, 11],
         [33, 63, 28, 40, 51, 100, 98, 87, 22, 30],
         [16, 54, 78, 12, 25, 35, 10, 19, 67, 0],
         [100, 88, 24, 33, 47, 56, 62, 34, 77, 53],
         [50, 89, 70, 72, 56, 29, 15, 20, 0, 0]])
scores
78/41:
np.array(np.mean(scores, axis=1))
arr.where(arr>15)
78/42:
arr = np.array(np.mean(scores, axis=1))
arr.where(arr>15)
78/43:
arr = np.array(np.mean(scores, axis=1))
arr.where(arr>15)
78/44:
arr = np.mean(scores, axis=1)
arr.where(arr>15)
78/45:
arr = np.mean(scores, axis=1)
arr.where(arr>15)
78/46:
arr = np.mean(scores, axis=1)
arr
78/47:
arr = np.mean(scores, axis=1)
arr.where(x==2)
78/48:
import numpy as np
arr = np.mean(scores, axis=1)
np.where(arr.max())
78/49:
arr = np.mean(scores, axis=1)
np.where(arr.max())
78/50:
arr = np.mean(scores, axis=1)
np.where(np.mean(scores, axis=1).max())
78/51:
arr = np.mean(scores, axis=1)
np.where(np.mean(scores, axis=1).max())
78/52:
np.mean(scores, axis=1)
np.where(np.mean(scores, axis=1).max())
78/53:
np.mean(scores, axis=1)
np.where(np.mean(scores, axis=1).max())
78/54:
np.mean(scores, axis=1).argmax()
np.where(np.mean(scores, axis=1).max())
78/55:
np.mean(scores, axis=1).argmax()
np.where(np.mean(scores, axis=1).max())
78/56:
np.mean(scores, axis=1).argmax()
# np.where(np.mean(scores, axis=1).max())
78/57:
np.mean(scores, axis=1)
np.mean(scores, axis=1).argmax()
78/58:
np.mean(scores, axis=1)
# np.mean(scores, axis=1).argmax()
78/59:
arr = np.mean(scores, axis=1)
arr.argmax()
# np.mean(scores, axis=1).argmax()
78/60:
arr = np.mean(scores, axis=1)
arr.argmax()
arr.max()
# np.mean(scores, axis=1).argmax()
78/61:
arr = np.mean(scores, axis=1)
arr.argmax()
arr.max()
arr
# np.mean(scores, axis=1).argmax()
78/62:
arr = np.mean(scores, axis=1)
arr.argmax()
78/63:
arr = np.mean(scores, axis=1)
max_index = arr.argmax()

print(max_index + 1)
78/64:
import numpy as np
scores = np.array([[20, 40, 56, 80, 0, 5, 25, 27, 74, 1],
         [0, 98, 67, 100, 8, 56, 34, 82, 100, 7],
         [78, 54, 23, 79, 100, 0, 0, 42, 95, 83],
         [51, 50, 47, 23, 100, 94, 25, 48, 38, 77],
         [90, 87, 41, 89, 52, 0, 5, 17, 28, 99],
         [32, 18, 21, 18, 29, 31, 48, 62, 76, 22],
         [6, 0, 65, 78, 43, 22, 38, 88, 94, 100],
         [77, 28, 39, 41, 0, 81, 45, 54, 98, 12],
         [66, 0, 88, 0, 44, 0, 55, 100, 12, 11],
         [17, 70, 86, 96, 56, 23, 32, 49, 70, 80],
         [20, 24, 76, 50, 29, 40, 3, 2, 5, 11],
         [33, 63, 28, 40, 51, 100, 98, 87, 22, 30],
         [16, 54, 78, 12, 25, 35, 10, 19, 67, 0],
         [100, 88, 24, 33, 47, 56, 62, 34, 77, 53],
         [50, 89, 70, 72, 56, 29, 15, 20, 0, 0]])
78/65: nonzero = scores[np.where(x > 0)]
78/66: nonzero = scores[np.where(scores > 0)]
78/67:
nonzero = scores[np.where(scores > 0)]
nonzero
78/68:
nonzero = scores[np.where(scores[scores > 0])]
nonzero
78/69:
nonzero = scores[np.where(scores > 0)]
nonzero
78/70: nonzero.min()
78/71: advanced = nonzero[np.where(nonzero > 80)]
78/72:
advanced = nonzero[np.where(nonzero > 80)]
advanced
78/73: np.median(scores)
78/74:
arr = np.mean(scores, axis=0)
max_index = arr.argmax()

print(max_index + 1)
78/75: np.median(scores, axis=0)
78/76: new_scores = scores.reshape(10, 15)
78/77:
new_scores = scores.reshape(10, 15)
new_scores
78/78:
new_scores = scores.reshape(10, 15)
np.mean(new_scores, axis=0)
78/79: advanced.size()
78/80: advanced.size
78/81: sto = np.where(scores==100)
78/82: sto = np.where(scores==100)
78/83:
sto = np.where(scores==100)
sto
78/84:
sto = np.where(scores==100, True, False)
sto
78/85: scores[:7:]
81/1:
import pandas as pd
%matplotlib inline
import seaborn as sns
from scipy.stats import norm
81/2:
import pandas as pd
%matplotlib inline
import seaborn as sns
from scipy.stats import norm
81/3:
data = pd.read_csv('https://raw.githubusercontent.com/pileyan/Data/master/data/pima-indians-diabetes.csv')
data.head(10)
85/1:
import pandasql as ps
# pip install pandasql
85/2:
import pandasql as ps
# pip install pandasql
85/3:
import pandasql as ps
pip install pandasql
85/4:
# import pandasql as ps
pip install pandasql
85/5: import pandas
85/6: import pandas as pd # импортировали библиотеку pandas и назвали ее pd
85/7: import pandas as pd # импортировали библиотеку pandas и назвали ее pd
85/8:
df = pd.DataFrame() # создали пустой датафрейм с помощью метода DataFrame() библиотеки pandas (pd)
df['a'] = [10,20,30] # создаем колонку "а" и помещаем в нее столбец с данными - [10, 20, 30]
df
86/1:
import enum

class SectionTypes(enum.Enum):
    QA = ('Software Quality Assurance Section', 'url1')
    DOp = ('DevOps Section', 'url2')
    WA = ('Web Applications Section', 'sdf')
    DS = ('Data Science Section', 'we')
    DB = ('Database Section', 'qw')
    NS = ('Не уточнять раздел', 'ew')

    def __init__(self, num, transitions):
        self.num = num
        self.transitions = transitions
86/2:
import enum

class SectionTypes(enum.Enum):
    QA = ('Software Quality Assurance Section', 'url1')
    DOp = ('DevOps Section', 'url2')
    WA = ('Web Applications Section', 'sdf')
    DS = ('Data Science Section', 'we')
    DB = ('Database Section', 'qw')
    NS = ('Не уточнять раздел', 'ew')

    def __init__(self, num, transitions):
        self.num = num
        self.transitions = transitions
86/3: [lt for lt in text, SectionTypes)]
86/4: [lt for lt in SectionTypes, lt)]
86/5:
import SectionTypes
[lt for lt in SectionTypes, lt)]
86/6:
import enum

class SectionTypes(enum.Enum):
    QA = ('Software Quality Assurance Section', 'url1')
    DOp = ('DevOps Section', 'url2')
    WA = ('Web Applications Section', 'sdf')
    DS = ('Data Science Section', 'we')
    DB = ('Database Section', 'qw')
    NS = ('Не уточнять раздел', 'ew')

    def __init__(self, num, transitions):
        self.num = num
        self.transitions = transitions
87/1:
import pandas as pd
%matplotlib inline
import seaborn as sns
from scipy.stats import norm
87/2:
data = pd.read_csv('https://raw.githubusercontent.com/pileyan/Data/master/data/pima-indians-diabetes.csv')
data.head(10)
87/3: data[cols].isnull()
87/4: data['Pregnancies'].isnull().shape
87/5:
for col in data.columns:
    missing = data[col].isnull()
    num_missing = np.sum(missing)
    if num_missing > 0:
        data['{}_ismissing'.format(col)] = missing
87/6:
import pandas as pd
%matplotlib inline
import seaborn as sns
from scipy.stats import norm
import numpy as np
87/7:
for col in data.columns:
    missing = data[col].isnull()
    num_missing = np.sum(missing)
    if num_missing > 0:
        data['{}_ismissing'.format(col)] = missing
87/8:
for col in data.columns:
    missing = data[col].isnull()
    num_missing = np.sum(missing)
    if num_missing > 0:
        data['{}_ismissing'.format(col)] = missing
        

data
87/9:
nan_dict = {}
for col in data.columns:
    missing = data[col].isnull().shape()

    if missing > 0:
        nan_dict[format(col)] = missing
        

nan_dict
87/10:
nan_dict = {}
for col in data.columns:
    missing = data[col].isnull().shape(

    if missing > 0:
        nan_dict[format(col)] = missing
        

nan_dict
87/11:
nan_dict = {}
for col in data.columns:
    missing = data[col].isnull().shape

    if missing > 0:
        nan_dict[format(col)] = missing
        

nan_dict
87/12:
nan_dict = {}
for col in data.columns:
    missing = data[col].isna().sum()

    if missing > 0:
        nan_dict[format(col)] = missing
        

nan_dict
87/13:
nan_dict = {}
for col in data.columns:
    missing = data[col].isna().sum()

    if missing > 0:
        nan_dict[format(col)] = missing
        

nan_dict
87/14:
for col in data.columns:
    if col == 'DiabetesPedigreeFunction':
        data[col] = data[col].fillna(data[col].mean())
    else:
        data[col] = data[col].fillna(data[col].median())
        
data.head(10)
87/15:
import pandas as pd
%matplotlib inline
import seaborn as sns
from scipy.stats import norm
import numpy as np
87/16:
data = pd.read_csv('https://raw.githubusercontent.com/pileyan/Data/master/data/pima-indians-diabetes.csv')
data.head(10)
87/17:
nan_dict = {}
for col in data.columns:
    missing = data[col].isna().sum()

    if missing > 0:
        nan_dict[format(col)] = missing
        

nan_dict
87/18:
for col in data.columns:
    if col == 'DiabetesPedigreeFunction':
        data[col] = data[col].fillna(data[col].mean())
    else:
        data[col] = data[col].fillna(data[col].median())
        
data.head(10)
87/19: data.describe()
87/20: data[(data.Age > 50) & (data.Сlass == 1)].shape[0]
87/21: data[(data.Age > 50) & (data.Class == 1)].shape[0]
87/22: data[(data.Pregnancies.nlargest(3)]
87/23: (data.Pregnancies.nlargest(3)
87/24: data.Pregnancies.nlargest(3)
87/25: data[data.Pregnancies.nlargest(3)]
87/26: data.Pregnancies.nlargest(3)
87/27:
data.iloc[data.Pregnancies.argsort()[-3:]]
# data.Pregnancies.nlargest(3)
87/28: data[(data.Age >= 30) & (data.Age < 41) & (data.Pregnancies > 2)].shape[0]
87/29: data[(data.BloodPressure >= 89) & (data.BloodPressure < 90)].shape[0]
87/30: data[(data.BloodPressure >= 89) & (data.BloodPressure < 90)].shape[()
87/31: data[(data.BloodPressure >= 89) & (data.BloodPressure < 90)].shape
87/32: data[(data.BloodPressure >= 80) & (data.BloodPressure < 90)].shape[0]
87/33: data[(data.BMI >= 30) & (data.BloodPressure < data.BloodPressure.mean())].shape[0]
87/34:
# Glucose ( ͡° ͜ʖ ͡°)づ ━━ ✫・*。
data[data.Class == 1]].Glucose.mean() > data[data.Class == 0].Glucose.mean()
87/35:
# Glucose ( ͡° ͜ʖ ͡°)づ ━━ ✫・*。
data[data.Class == 1].Glucose.mean() > data[data.Class == 0].Glucose.mean()
87/36:
# BloodPressure ( ͡° ͜ʖ ͡°)づ ━━ ✫・*。
data[data.Class == 1].BloodPressure.mean() > data[data.Class == 0].BloodPressure.mean()
87/37:
# Insulin ( ͡° ͜ʖ ͡°)づ ━━ ✫・*。
data[data.Class == 1].Insulin.mean() > data[data.Class == 0].Insulin.mean()
87/38:
# Insulin ( ͡° ͜ʖ ͡°)づ ━━ ✫・*。
data[data.Class == 1].Insulin.mean()
data[data.Class == 0].Insulin.mean()
87/39:
# Insulin ( ͡° ͜ʖ ͡°)づ ━━ ✫・*。

data[data.Class == 0].Insulin.mean()
data[data.Class == 1].Insulin.mean()
87/40:
# Insulin ( ͡° ͜ʖ ͡°)づ ━━ ✫・*。
data[data.Class == 1].Insulin.mean() > data[data.Class == 0].Insulin.mean()
87/41:
# ( ͡° ͜ʖ ͡°)づ ━━ ✫・*。
data.Age.hist()
87/42: data.Glucose.hist()
87/43: data.groupby('Class').size().plot(kind = 'pie')
87/44:
# ( ͡° ͜ʖ ͡°)づ ━━ ✫・*。
data.groupby(['Age'])['BloodPressure'].value_counts().unstack().plot(kind = 'bar')
87/45: sns.distplot(data.Age.dropna(), fit=norm)  # параметр fit строит нам еще один график поверх существующего,
87/46: sns.distplot(data.BloodPressure.dropna(), fit=norm)
87/47:
# ( ͡° ͜ʖ ͡°)づ ━━ ✫・*
data[['Class', 'Pregnancy']].groupby('Class').mean()
87/48:
# ( ͡° ͜ʖ ͡°)づ ━━ ✫・*
data[['Class', 'Pregnancies']].groupby('Class').mean()
87/49:
# ( ͡° ͜ʖ ͡°)づ ━━ ✫・*
data[['Pregnancies', 'Class']].groupby('Pregnancies').mean()
87/50:
# ( ͡° ͜ʖ ͡°)づ ━━ ✫・*
data[['Pregnancies', 'Class']].groupby('Pregnancies').mean().hist()
87/51:
# ( ͡° ͜ʖ ͡°)づ ━━ ✫・*
data[['Pregnancies', 'Class']].groupby('Pregnancies').mean()
87/52:
# ( ͡° ͜ʖ ͡°)づ ━━ ✫・*

data[['Pregnancies', 'Class']].groupby('Pregnancies').sum()
data[data.Pclass == 1].Age.hist()
87/53:
# ( ͡° ͜ʖ ͡°)づ ━━ ✫・*

data[['Pregnancies', 'Class']].groupby('Pregnancies').sum()
87/54:
# ( ͡° ͜ʖ ͡°)づ ━━ ✫・*

data[['Pregnancies', 'Class']].groupby('Pregnancies').sum().mean()
87/55:
# ( ͡° ͜ʖ ͡°)づ ━━ ✫・*

data[['Pregnancies', 'Class']].groupby('Pregnancies').sum()
87/56:
# ( ͡° ͜ʖ ͡°)づ ━━ ✫・*

# data[['Pregnancies', 'Class']].groupby('Pregnancies').sum()
data['Class'].mean()
87/57:
# ( ͡° ͜ʖ ͡°)づ ━━ ✫・*

# data[['Pregnancies', 'Class']].groupby('Pregnancies').sum()
data['Class'].sum()
87/58:
# ( ͡° ͜ʖ ͡°)づ ━━ ✫・*

sns.distplot(data[['Pregnancies', 'Class']].groupby('Pregnancies').sum(), fit=norm)
87/59:
# ( ͡° ͜ʖ ͡°)づ ━━ ✫・*

data[['Pregnancies', 'Class']].groupby('Pregnancies')
87/60:
# ( ͡° ͜ʖ ͡°)づ ━━ ✫・*

data[['Pregnancies', 'Class']].groupby('Pregnancies')
87/61:
# ( ͡° ͜ʖ ͡°)づ ━━ ✫・*

data[['Pregnancies', 'Class']].groupby('Pregnancies').mean()
87/62: data['wasPregnant'] = data[['Pregnancies']].apply(lambda x : 1 if x > 0 else 0)
87/63: data['wasPregnant'] = data['Pregnancies'].apply(lambda x : 1 if x > 0 else 0)
87/64:
data['wasPregnant'] = data['Pregnancies'].apply(lambda x : 1 if x > 0 else 0)
v
87/65:
data['wasPregnant'] = data['Pregnancies'].apply(lambda x : 1 if x > 0 else 0)
data.head(10)
87/66: data[['wasPregnant', 'Class']].groupby('wasPregnant').sum()
87/67: data[['wasPregnant', 'Class']].groupby('Class').sum()
87/68: data[[Class']].groupby('wasPregnant').sum()
87/69: data[['Class']].groupby('wasPregnant').sum()
87/70: data['Class'].groupby('wasPregnant').sum()
87/71: data[['wasPregnant', 'Class']].groupby('wasPregnant').sum()
87/72: data[['wasPregnant', 'Class']].groupby('wasPregnant').shape(0)
87/73: data[['wasPregnant', 'Class']].groupby('wasPregnant').shape[0]
87/74:
data[(data.Class = 1) & (data.wasPregnant = 1)].shape[0]
data[].shape[0]
87/75:
data[(data.Class == 1) & (data.wasPregnant == 1)].shape[0]
data[].shape[0]
87/76: data[(data.Class == 1) & (data.wasPregnant == 1)].shape[0]
87/77:
data[(data.Class == 1) & (data.wasPregnant == 1)].shape[0]
data[(data.Class == 10) & (data.wasPregnant == 1)].shape[0]
87/78:
data[(data.Class == 1) & (data.wasPregnant == 1)].shape[0]
data[(data.Class == 00) & (data.wasPregnant == 1)].shape[0]
87/79:
data[(data.Class == 1) & (data.wasPregnant == 1)].shape[0]
data[(data.Class == 1) & (data.wasPregnant == 0)].shape[0]
87/80:
pr = data[(data.Class == 1) & (data.wasPregnant == 1)].shape[0]
notpr = data[(data.Class == 1) & (data.wasPregnant == 0)].shape[0]

print(f'Соотношение беременных к не беременным {pr}/{notpr}*100 %')
87/81:
pr = data[(data.Class == 1) & (data.wasPregnant == 1)].shape[0]
notpr = data[(data.Class == 1) & (data.wasPregnant == 0)].shape[0]
val = (pr/notpr*100)
print(f'Соотношение беременных к не беременным {val}%')
87/82:
# ( ͡° ͜ʖ ͡°)づ ━━ ✫・*
def foo(x):
    if x <= 18.5:
        return 'Underweight'
    elif x <= 24.9:
        return 'Normal weight'
    elif x <= 29.9:
        return 'Overweight'
    else:
        return 'Obesity'

data['bodyType'] = data['BMI'].apply(foo)
data.head(10)
87/83: healthy = data[(data.bodyType = 'Normal') &(data.BloodPressure >= 80) & (data.BloodPressure < 90)].shape[0]
87/84: healthy = data[(data.bodyType == 'Normal') &(data.BloodPressure >= 80) & (data.BloodPressure < 90)].shape[0]
87/85:
healthy = data[(data.bodyType == 'Normal') &(data.BloodPressure >= 80) & (data.BloodPressure < 90)].shape[0]
healthy
87/86: data[(data.bodyType == 'Normal')&(data.BloodPressure >= 80)&(data.BloodPressure < 90)].shape[0]
87/87: data[(data.bodyType == 'Normal weight')&(data.BloodPressure >= 80)&(data.BloodPressure < 90)].shape[0]
87/88:
healthy = data[(data.bodyType == 'Normal weight')&(data.BloodPressure >= 80)&(data.BloodPressure < 90)].shape[0]
ill = data[(data.bodyType == 'Normal weight')&(data.BloodPressure >= 80)&(data.BloodPressure < 90)
              & (data.Class == 1)].shape[0]
ill
87/89:
healthy = data[(data.bodyType == 'Normal weight')&(data.BloodPressure >= 80)&(data.BloodPressure < 90)].shape[0]
ill = data[(data.bodyType == 'Normal weight')&(data.BloodPressure >= 80)&(data.BloodPressure < 90)
              & (data.Class == 1)].shape[0]
ill/healthy*100
87/90:
healthy = data[(data.bodyType == 'Normal weight')&(data.BloodPressure >= 80)&(data.BloodPressure < 90)].shape[0]
ill = data[(data.bodyType == 'Normal weight')&(data.BloodPressure >= 80)&(data.BloodPressure < 90)
              & (data.Class == 1)].shape[0]
print(f'{ill/healthy*100} %')
88/1:
def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return

    a = arr[0]; b = arr[1]
 
    for i in range(0, n):
         
        for j in range(i + 1, n):
            if (arr[i] * arr[j] > a * b):
                return a * b
88/2:
numbers = list(int(input()))


def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return

    a = arr[0]; b = arr[1]
 
    for i in range(0, n):
         
        for j in range(i + 1, n):
            if (arr[i] * arr[j] > a * b):
                return a * b
            
n = len(numbers)
maxProduct(numbers, n)
88/3:
numbers = [int(x) for x in input().split()]


def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return

    a = arr[0]; b = arr[1]
 
    for i in range(0, n):
         
        for j in range(i + 1, n):
            if (arr[i] * arr[j] > a * b):
                return [a, b]
            
n = len(numbers)
maxProduct(numbers, n)
88/4:
numbers = [int(x) for x in input().split()]


def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return

    a = arr[0]; b = arr[1]
 
    for i in range(0, n):
         
        for j in range(i + 1, n):
            if (arr[i] * arr[j] > a * b):
                return [a, b]
            
n = len(numbers)
maxProduct(numbers, n)
88/5:
numbers = [int(x) for x in input().split()]


def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return

    a = arr[0]; b = arr[1]
 
    for i in range(0, n):
        for j in range(i + 1, n):
            if (arr[i] * arr[j] > a * b):
                a = arr[i]; b = arr[j]
                return [a, b]
            
n = len(numbers)
maxProduct(numbers, n)
88/6:
numbers = [int(x) for x in input().split()]


def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return

    a = arr[0]; b = arr[1]
 
    for i in range(0, n):
        for j in range(i + 1, n):
            if (arr[i] * arr[j] > a * b):
                a = arr[i]; b = arr[j]
                return a, b
            
n = len(numbers)
maxProduct(numbers, n)
88/7:
numbers = [int(x) for x in input().split()]


def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return

    a = arr[0]; b = arr[1]
 
    for i in range(0, n):
        for j in range(i + 1, n):
            if (arr[i] * arr[j] > a * b):
                a = arr[i]; b = arr[j]
                return a b
            
n = len(numbers)
maxProduct(numbers, n)
88/8:
numbers = [int(x) for x in input().split()]


def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return

    a = arr[0]; b = arr[1]
 
    for i in range(0, n):
        for j in range(i + 1, n):
            if (arr[i] * arr[j] > a * b):
                a = arr[i]; b = arr[j]
                return [a, b]
            
n = len(numbers)
maxProduct(numbers, n)
88/9:
numbers = [int(x) for x in input().split()]


def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return

    a = arr[0]; b = arr[1]
 
    for i in range(0, n):
        for j in range(i + 1, n):
            if (arr[i] * arr[j] > a * b):
                print(f'{arr[i]} \n')
                print(f'{arr[j]} \n')
                a = arr[i]; b = arr[j]
                return [a, b]
            
n = len(numbers)
maxProduct(numbers, n)
88/10:
numbers = [int(x) for x in input().split()]


def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return

    a = arr[0]; b = arr[1]
 
    for i in range(0, n):
        for j in range(i + 1, n):
            if (arr[i] * arr[j] > a * b):
                print(f'{arr[i]} \n')
                print(f'{arr[j]} \n')
                a = arr[i]; b = arr[j]
    return [a, b]
            
n = len(numbers)
maxProduct(numbers, n)
88/11:
numbers = [int(x) for x in input().split()]


def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return

    a = arr[0]; b = arr[1]
 
    for i in range(0, n):
        for j in range(i + 1, n):
            if (arr[i] * arr[j] > a * b):
                print(f'{arr[i]} \n')
                print(f'{arr[j]} \n')
                a = arr[i]; b = arr[j]
    return [a, b]
            
n = len(numbers)
maxProduct(numbers, n)
88/12:
numbers = [int(x) for x in input().split()]


def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return

    a = arr[0]; b = arr[1]
 
    for i in range(0, n):
        for j in range(i + 1, n):
            if (arr[i] * arr[j] > a * b):
                print(f'{arr[i]} \n')
                print(f'{arr[j]} \n')
                a = arr[i]; b = arr[j]
    return [a, b]
            
n = len(numbers)
maxProduct(numbers, n)
88/13:
numbers = [int(x) for x in input().split()]


def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return

    a = arr[0]; b = arr[1]
 
    for i in range(0, n):
        for j in range(i + 1, n):
            if (arr[i] * arr[j] > a * b):
                print(f'{arr[i]} \n')
                print(f'{arr[j]} \n')
                a = arr[i]; b = arr[j]
    return f'{a} {b}'
            
n = len(numbers)
maxProduct(numbers, n)
88/14:
numbers = [int(x) for x in input().split()]


def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return

    a = arr[0]; b = arr[1]
 
    for i in range(0, n):
        for j in range(i + 1, n):
            if (arr[i] * arr[j] > a * b):
                a = arr[i]; b = arr[j]
    return [a, b]
            
n = len(numbers)
result = maxProduct(numbers, n)
print(*result)
88/15:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0] ," " , arr[1])
        return
 
    posa = 0
    posb = 0
 
    nega = 0
    negb = 0
 
    for i in range(n):
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        print("Max product pair is {" ,
                nega ,", ", negb , "}")
    else:
        print( "Max product pair is {" ,
                 posa ,", " ,posb , "}")
        
n = len(numbers)
result = maxProduct(numbers, n)
print(*result)
88/16:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0] ," " , arr[1])
        return
 
    posa = 0
    posb = 0
 
    nega = 0
    negb = 0
 
    for i in range(n):
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        print("Max product pair is {" ,
                nega ,", ", negb , "}")
    else:
        print( "Max product pair is {" ,
                 posa ,", " ,posb , "}")
        
n = len(numbers)
maxProduct(numbers, n)
# print(*result)
88/17:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0] ," ", arr[1])
        return
 
    posa = 0
    posb = 0
 
    nega = 0
    negb = 0
 
    for i in range(n):
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        print(nega ," ", negb )
    else:
        print( posa ," ", posb)
        
n = len(numbers)
maxProduct(numbers, n)
# print(*result)
88/18:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0] ," ", arr[1])
        return
 
    posa = 0
    posb = 0
 
    nega = 0
    negb = 0
 
    for i in range(n):
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        print(f'{nega," ",negb if nega<negb else negb," ",nega}')
    else:
         print(f'{posa," ",posb if posa<negb else posb," ",posa}')
        
n = len(numbers)
maxProduct(numbers, n)
# print(*result)
88/19:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0] ," ", arr[1])
        return
 
    posa = 0
    posb = 0
 
    nega = 0
    negb = 0
 
    for i in range(n):
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        print(1)
        print(f'{nega," ",negb if nega<negb else negb," ",nega}')
    else:
        print(2)
        print(f'{posa," ",posb if posa<negb else posb," ",posa}')
        
n = len(numbers)
maxProduct(numbers, n)
# print(*result)
88/20:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0] ," ", arr[1])
        return
 
    posa = 0
    posb = 0
 
    nega = 0
    negb = 0
 
    for i in range(n):
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        print(1)
        print(f'{nega," ",negb if nega<negb else negb," ",nega}')
    else:
        print(2)
        print(f'{posa," ",posb if posa<negb else posb," ",posa}')
        
n = len(numbers)
maxProduct(numbers, n)
# print(*result)
88/21:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0] ," ", arr[1])
        return
 
    posa = 0
    posb = 0
 
    nega = 0
    negb = 0
 
    for i in range(n):
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        print(1)
        print(f'{nega," ",negb if nega<=negb else negb," ",nega}')
    else:
        res = f{posa," ",posb if posa=<negb else posb," ",posa}
        print(res)
        
n = len(numbers)
maxProduct(numbers, n)
# print(*result)
88/22:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0] ," ", arr[1])
        return
 
    posa = 0
    posb = 0
 
    nega = 0
    negb = 0
 
    for i in range(n):
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        print(1)
        print(f'{nega," ",negb if nega<=negb else negb," ",nega}')
    else:
        res = f'{posa," ",posb if posa=<negb else posb," ",posa}'
        print(res)
        
n = len(numbers)
maxProduct(numbers, n)
# print(*result)
88/23:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0] ," ", arr[1])
        return
 
    posa = 0
    posb = 0
 
    nega = 0
    negb = 0
 
    for i in range(n):
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        print(1)
        print(f'{nega," ",negb if nega < negb else negb," ",nega}')
    else:
        res = f'{posa," ",posb if posa < negb else posb," ",posa}'
        print(res)
        
n = len(numbers)
maxProduct(numbers, n)
# print(*result)
88/24:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0] ," ", arr[1])
        return
 
    posa = 0
    posb = 0
 
    nega = 0
    negb = 0
 
    for i in range(n):
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        print(1)
        print(f'{nega," ",negb if nega < negb else negb," ",nega}')
    else:
        if(posa < negb):
            print(posa," ",posb)
        else:
            print(posb," ",posa)
        
n = len(numbers)
maxProduct(numbers, n)
# print(*result)
88/25:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0] ," ", arr[1])
        return
 
    posa = 0
    posb = 0
 
    nega = 0
    negb = 0
 
    for i in range(n):
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        print(1)
        print(f'{nega," ",negb if nega < negb else negb," ",nega}')
    else:
        if(posa < posb):
            print(posa," ",posb)
        else:
            print(posb," ",posa)
        
n = len(numbers)
maxProduct(numbers, n)
# print(*result)
88/26:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0] ," ", arr[1])
        return
 
    posa = 0
    posb = 0
 
    nega = 0
    negb = 0
 
    for i in range(n):
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        if(nega < negb):
            print(nega," ",negb)
        else:
            print(negb," ",nega)
    else:
        if(posa < posb):
            print(posa," ",posb)
        else:
            print(posb," ",posa)
        
n = len(numbers)
maxProduct(numbers, n)
# print(*result)
88/27:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0] ," " , arr[1])
        return
 
    # Initialize maximum and
    # second maximum
    posa = 0
    posb = 0
 
    # Initialize minimum and
    # second minimum
    nega = 0
    negb = 0
 
    # Traverse given array
    for i in range(n):
     
        # Update maximum and second
        # maximum if needed
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        # Update minimum and second
        # minimum if needed
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        print("Max product pair is {" ,
                nega ,", ", negb , "}")
    else:
        print( "Max product pair is {" ,
                 posa ,", " ,posb , "}")
        
n = len(numbers)
maxProduct(numbers, n)
# print(*result)
88/28:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0] ," " , arr[1])
        return
 
    # Initialize maximum and
    # second maximum
    posa = 0
    posb = 0
 
    # Initialize minimum and
    # second minimum
    nega = 0
    negb = 0
 
    # Traverse given array
    for i in range(n):
     
        # Update maximum and second
        # maximum if needed
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        # Update minimum and second
        # minimum if needed
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        print("Max product pair is {" ,
                nega ,", ", negb , "}")
    else:
        print( "Max product pair is {" ,
                 posa ,", " ,posb , "}")
        
n = len(numbers)
maxProduct(numbers, n)
# print(*result)
88/29:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0] ," " , arr[1])
        return
 
    # Initialize maximum and
    # second maximum
    posa = 0
    posb = 0
 
    # Initialize minimum and
    # second minimum
    nega = 0
    negb = 0
 
    # Traverse given array
    for i in range(n):
     
        # Update maximum and second
        # maximum if needed
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        # Update minimum and second
        # minimum if needed
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        if(nega < negb):
            print(nega, negb)
        else:
            print(negb, nega)
    else:
        if(posa < posb):
            print(posa, posb)
        else:
            print(posb, posa)
        
n = len(numbers)
maxProduct(numbers, n)
# print(*result)
88/30:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0] ," " , arr[1])
        return
 
    # Initialize maximum and
    # second maximum
    posa = 0
    posb = 0
 
    # Initialize minimum and
    # second minimum
    nega = 0
    negb = 0
 
    # Traverse given array
    for i in range(n):
     
        # Update maximum and second
        # maximum if needed
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        # Update minimum and second
        # minimum if needed
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        if(nega < negb):
            print(nega, negb)
        else:
            print(negb, nega)
    else:
        if(posa < posb):
            print(posa, posb)
        else:
            print(posb, posa)
        
n = len(numbers)
maxProduct(numbers, n)
# print(*result)
88/31:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0] ," " , arr[1])
        return
 
    # Initialize maximum and
    # second maximum
    posa = 0
    posb = 0
 
    # Initialize minimum and
    # second minimum
    nega = 0
    negb = 0
 
    # Traverse given array
    for i in range(n):
     
        # Update maximum and second
        # maximum if needed
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        # Update minimum and second
        # minimum if needed
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        if(nega < negb):
            print(nega, negb)
        else:
            print(negb, nega)
    else:
        if(posa < posb):
            print(posa, posb)
        else:
            print(posb, posa)
        
n = len(numbers)
maxProduct(numbers, n)
# print(*result)
88/32:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0] ," " , arr[1])
        return
 
    # Initialize maximum and
    # second maximum
    posa = 0
    posb = 0
 
    # Initialize minimum and
    # second minimum
    nega = 0
    negb = 0
 
    # Traverse given array
    for i in range(n):
     
        # Update maximum and second
        # maximum if needed
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        # Update minimum and second
        # minimum if needed
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        if(nega < negb):
            print(nega, negb)
        else:
            print(negb, nega)
    else:
        if(posa < posb):
            print(posa, posb)
        else:
            print(posb, posa)
        
n = len(numbers)
maxProduct(numbers, n)
# print(*result)
88/33:
numbers = [int(x) for x in input().split()]

def maxProduct(arr, n):
 
    if (n < 2):
        print("No pairs exists")
        return
 
    if (n == 2):
        print(arr[0], arr[1])
        return
 
    # Initialize maximum and
    # second maximum
    posa = 0
    posb = 0
 
    # Initialize minimum and
    # second minimum
    nega = 0
    negb = 0
 
    # Traverse given array
    for i in range(n):
     
        # Update maximum and second
        # maximum if needed
        if (arr[i] > posa):
            posb = posa
            posa = arr[i]
         
        elif (arr[i] > posb):
            posb = arr[i]
 
        # Update minimum and second
        # minimum if needed
        if (arr[i] < 0 and abs(arr[i]) > abs(nega)):
            negb = nega
            nega = arr[i]
         
        elif(arr[i] < 0 and abs(arr[i]) > abs(negb)):
            negb = arr[i]
 
    if (nega * negb > posa * posb):
        if(nega < negb):
            print(nega, negb)
        else:
            print(negb, nega)
    else:
        if(posa < posb):
            print(posa, posb)
        else:
            print(posb, posa)
        
n = len(numbers)
maxProduct(numbers, n)
# print(*result)
88/34:
a = list(map(int, input().split()))

min1 = min(a)
a.pop(a.index(min1))
min2 = min(a)
a.pop(a.index(a))

max1 = max(a)
a.pop(a.index(max1))
max2 = max(a)
a.pop(a.index(a))

if max1*max2 > min1*min2:
    res = [max1, max2]
else:
    res = [min1, min2]
res.sort()
print(*res)
88/35:
a = list(map(int, input().split()))

min1 = min(a)
a.pop(a.index(min1))
min2 = min(a)
a.pop(a.index(a))

max1 = max(a)
a.pop(a.index(max1))
max2 = max(a)
a.pop(a.index(a))

if max1*max2 > min1*min2:
    res = [max1, max2]
    
else:
    res = [min1, min2]
res.sort()
print(*res)
88/36:
a = [int(x) for x in input().split()]

min1 = min(a)
a.pop(a.index(min1))
min2 = min(a)
a.pop(a.index(a))

max1 = max(a)
a.pop(a.index(max1))
max2 = max(a)
a.pop(a.index(a))

if max1*max2 > min1*min2:
    res = [max1, max2]
    
else:
    res = [min1, min2]
res.sort()
print(*res)
88/37:
a = list(map(int, input().split()))

min1 = min(a)
a.pop(a.index(min1))
min2 = min(a)
a.pop(a.index(a))

max1 = max(a)
a.pop(a.index(max1))
max2 = max(a)
a.pop(a.index(a))

if max1*max2 > min1*min2:
    res = [max1, max2]
    
else:
    res = [min1, min2]
res.sort()
print(*res)
88/38:
a = list(map(int, input().split()))

min1 = min(a)
a.pop(a.index(min1))
min2 = min(a)
a.pop(a.index(a))

max1 = max(a)
a.pop(a.index(max1))
max2 = max(a)
a.pop(a.index(a))

if max1*max2 > min1*min2:
    res = [max1, max2]
    
else:
    res = [min1, min2]
res.sort()
print(*res)
88/39:
a = list(map(int, input().split()))

min1 = min(a)
a.pop(a.index(min1))
min2 = min(a)
a.pop(a.index(min2))

max1 = max(a)
a.pop(a.index(max1))
max2 = max(a)
a.pop(a.index(max2))

if max1*max2 > min1*min2:
    res = [max1, max2]
    
else:
    res = [min1, min2]
res.sort()
print(*res)
88/40:
a = list(map(int, input().split()))

min1 = min(a)
a.pop(a.index(min1))
min2 = min(a)
a.pop(a.index(min2))

max1 = max(a)
a.pop(a.index(max1))
max2 = max(a)
a.pop(a.index(max2))

if max1*max2 > min1*min2:
    res = [max1, max2]
    
else:
    res = [min1, min2]
res.sort()
print(*res)
89/1:
# binary search

a = [1,2,13,1121,121212]

def binary_search(arr, item) {
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = (low + high)/2
        guess = arr[mid]
        if guess === item:
            return item
        if guess < item:
            high = mid - 1
        else:
            low = mid + 1
    return None
}

res = binary_search(a, 2)
preint(res)
89/2:
# binary search

a = [1,2,13,1121,121212]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = (low + high)/2
        guess = arr[mid]
        if guess === item:
            return item
        if guess < item:
            high = mid - 1
        else:
            low = mid + 1
    return None

res = binary_search(a, 2)
preint(res)
89/3:
# binary search

a = [1,2,13,1121,121212]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = (low + high)/2
        guess = arr[mid]
        if guess == item:
            return item
        if guess < item:
            high = mid - 1
        else:
            low = mid + 1
    return None

res = binary_search(a, 2)
preint(res)
89/4:
# binary search

a = [1,2,13,1121,121212]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = round((low + high)/2)
        guess = arr[mid]
        if guess == item:
            return item
        if guess < item:
            high = mid - 1
        else:
            low = mid + 1
    return None

res = binary_search(a, 2)
preint(res)
89/5:
# binary search

a = [1,2,13,1121,121212]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = round((low + high)/2)
        guess = arr[mid]
        if guess == item:
            return item
        if guess < item:
            high = mid - 1
        else:
            low = mid + 1
    return None

res = binary_search(a, 2)
print(res)
89/6:
# binary search

a = [1,2,13,1121,121212]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = round((low + high)/2)
        guess = arr[mid]
        if guess == item:
            return item
        if guess < item:
            high = mid - 1
        else:
            low = mid + 1
    return None

res = binary_search(a, 13)
print(res)
89/7:
# binary search

a = [1,2,13,1121,121212]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = round((low + high)/2)
        guess = arr[mid]
        if guess == item:
            return item
        if guess < item:
            high = mid - 1
        else:
            low = mid + 1
    return None

res = binary_search(a, 2)
print(res)
89/8:
# binary search
import math

a = [1,2,13,1121,121212]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = math.floor((low + high)/2)
        guess = arr[mid]
        if guess == item:
            return item
        if guess < item:
            high = mid - 1
        else:
            low = mid + 1
    return None

res = binary_search(a, 2)
print(res)
89/9:
# binary search
import math

a = [1,2,13,1121,121212]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = math.floor((low + high)/2)
        guess = arr[mid]
        if guess == item:
            return item
        if guess < item:
            high = mid - 1
        else:
            low = mid + 1
    return None

res = binary_search(a, 2)
print(res)
89/10:
# binary search
import math

a = [1,2,13,1121,121212]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = math.floor((low + high)/2)
        guess = arr[mid]
        if guess == item:
            return item
        if guess < item:
            high = mid - 1
        else:
            low = mid + 1
    return None

res = binary_search(a, 1)
print(res)
89/11:
# binary search
import math

a = [1,2,13,1121,121212]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = math.floor((low + high)/2)
        guess = arr[mid]
        if guess == item:
            return item
        if guess < item:
            high = mid - 1
        else:
            low = mid + 1
    return None

res = binary_search(a, 13)
print(res)
89/12:
# binary search
import math

a = [1,2,13,1121,121212]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = math.floor((low + high)/2)
        print(mid)
        guess = arr[mid]
        if guess == item:
            return item
        if guess < item:
            high = mid - 1
        else:
            low = mid + 1
    return None

res = binary_search(a, 13)
print(res)
89/13:
# binary search
import math

a = [1,2,13,1121,121212]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = math.floor((low + high)/2)
        print(mid)
        guess = arr[mid]
        if guess == item:
            return item
        if guess < item:
            high = mid - 1
        else:
            low = mid + 1
    return None

res = binary_search(a, 2)
print(res)
89/14:
# binary search
import math

a = [1,2,13,1121,121212]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = math.floor((low + high)/2)

        guess = arr[mid]
        print(guess)
        if guess == item:
            return item
        if guess < item:
            high = mid - 1
        else:
            low = mid + 1
    return None

res = binary_search(a, 2)
# print(res)
89/15:
# binary search
import math

a = [1,2,13,1121,121212]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = math.floor((low + high)/2)
        print
        guess = arr[mid]
        print(guess)
        if guess == item:
            return item
        if guess > item:
            high = mid - 1
        else:
            low = mid + 1
    return None

res = binary_search(a, 2)
# print(res)
89/16:
# binary search
import math

a = [1,2,13,1121,121212]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = math.floor((low + high)/2)
        guess = arr[mid]
        if guess == item:
            return item
        if guess > item:
            high = mid - 1
        else:
            low = mid + 1
    return None

res = binary_search(a, 2)
# print(res)
89/17:
# binary search
import math

a = [1,2,13,1121,121212]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = math.floor((low + high)/2)
        guess = arr[mid]
        if guess == item:
            return item
        if guess > item:
            high = mid - 1
        else:
            low = mid + 1
    return None

res = binary_search(a, 2)
print(res)
90/1:
number = int(input())


def isPrime(n):
 
    if (n < 4):
        return True
    else
        return False


isPrime(number)
90/2:
number = int(input())


def isPrime(n):
 
    if (n < 4):
        return True
    else:
        return False


isPrime(number)
90/3:
number = int(input())


def isPrime(n):
 
    if (n < 4):
        return True
    else:
        return False


isPrime(number)
90/4:
number = int(input())


def isPrime(n):
 
    if (n < 4):
        return True
    else:
        return False


isPrime(number)
90/5:
import math
number = int(input())


def isPrime(n):
    s = math.sqrt(n)
    print(s)
    if (n < 4):
        return True
    else:
        return False


isPrime(number)
90/6:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    print(s)
    if (n < 4):
        return True
    else:
        return False


isPrime(number)
90/7:
import math
number = int(input())


def isPrime(n):
    s = round(sqrt(n))
    print(s)
    if (n < 4):
        return True
    else:
        return False


isPrime(number)
90/8:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    print(s)
    if (n < 4):
        return True
    else:
        return False


isPrime(number)
90/9:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(s)
        print(i)
    if (n < 4):
        return True
    else:
        return False


isPrime(number)
90/10:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(s):
        print(i)
    if (n < 4):
        return True
    else:
        return False


isPrime(number)
90/11:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, 1, s):
        print(i)
    if (n < 4):
        return True
    else:
        return False


isPrime(number)
90/12:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, 1, s):
        print(i)


isPrime(number)
90/13:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        print(i)


isPrime(number)
90/14:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i === 0:
            return True
    return False


isPrime(number)
90/15:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return True
    return False


isPrime(number)
90/16:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return True
    return False


isPrime(number)
90/17:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return True
    return False


isPrime(number)
90/18:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return True
    return False


isPrime(number)
90/19:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i != 0:
            return True
    return False


isPrime(number)
90/20:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i != 0:
            return True
    return False


isPrime(number)
90/21:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return True
    return False


isPrime(number)
90/22:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return False
    return True 


isPrime(number)
90/23:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return False
    return True 


isPrime(number)
90/24:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return False
    return True 


isPrime(number)
90/25:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return False
    return True 


isPrime(number)
90/26:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return True
    return False 


isPrime(number)
90/27:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return True
    return False 


isPrime(number)
90/28:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return True
    return False 


isPrime(number)
90/29:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return False
    return True 


isPrime(number)
90/30:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return False
    return True 


isPrime(number)
90/31:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return False
    return True 


isPrime(number)
90/32:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return False
    return True 


isPrime(number)
90/33:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/34:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/35:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/36:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/37:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/38:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/39:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    print(S)
    for i in range(2, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/40:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    print(s)
    for i in range(2, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/41:
import math
number = int(input())


def isPrime(n):
    s = math.floor(math.sqrt(n))
    print(s)
    for i in range(2, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/42:
import math
number = int(input())


def isPrime(n):
    s = math.floor(math.sqrt(n))
    print(s)
    for i in range(2, s):
#         print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/43:
import math
number = int(input())


def isPrime(n):
    s = math.floor(math.sqrt(n))
#     print(s)
    for i in range(2, s):
#         print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/44:
import math
number = int(input())


def isPrime(n):
    s = math.floor(math.sqrt(n))
    print(s)
    for i in range(2, s):
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/45:
import math
number = int(input())


def isPrime(n):
    s = math.floor(math.sqrt(n))
    for i in range(2, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/46:
import math
number = int(input())


def isPrime(n):
    s = math.floor(math.sqrt(n))
    for i in range(1, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/47:
import math
number = int(input())


def isPrime(n):
    s = math.floor(math.sqrt(n))
    for i in range(1, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/48:
import math
number = int(input())


def isPrime(n):
    s = math.floor(math.sqrt(n))
    for i in range(2, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/49:
import math
number = int(input())


def isPrime(n):
    s = math.floor(math.sqrt(n))
    for i in range(2, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/50:
import math
number = int(input())


def isPrime(n):
    s = math.floor(math.sqrt(n))
    for i in range(2, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/51:
import math
number = int(input())


def isPrime(n):
    s = math.floor(math.sqrt(n))
    for i in range(2, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/52:
import math
number = int(input())


def isPrime(n):
    s = math.floor(math.sqrt(n))
    for i in range(2, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/53:
import math
number = int(input())


def isPrime(n):
    s = math.floor(math.sqrt(n))
    for i in range(2, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/54:
import math
number = int(input())


def isPrime(n):
    s = math.floor(math.sqrt(n))
    for i in range(2, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/55:
import math
number = int(input())


def isPrime(n):
    s = math.floor(math.sqrt(n))
    for i in range(2, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/56:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/57:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/58:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/59:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/60:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s,1):
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/61:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s,1):
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/62:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s,1):
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/63:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s,1):
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/64:
import math
number = int(input())


def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s, 1):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/65:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n))
    for i in range(2, s, 1):
        print(i)
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/66:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n))
    print(s)
    for i in range(2, s, 1):
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/67:
import math
number = int(input())
print()

def isPrime(n):
    s = math.floor(math.sqrt(n))
    print(s)
    for i in range(2, s, 1):
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/68:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    print(s)
    for i in range(2, s, 1):
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/69:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/70:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/71:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/72:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/73:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return 'NO'
    return 'YES' 


isPrime(number)
90/74:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return 'NO'
    return 'YES' 


print(isPrime(number))
92/1: 4/2
92/2:
import math
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if n%2 ==1:
        return bin_pow(n*n, d-1)
    else:
        b = bin_pow(n, d/2)
        return b*b
        


print(isPrime(number, degree))
92/3:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if n%2 ==1:
        return bin_pow(n*n, d-1)
    else:
        b = bin_pow(n, int(d/2)
        return b*b
        


print(bin_pow(number, degree))
92/4:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if n%2 ==1:
        return bin_pow(n*n, d-1)
    else:
        b = bin_pow(n, int(d/2))
        return b*b
        


print(bin_pow(number, degree))
92/5:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if n%2 ==1:
        return bin_pow(n*n, d-1)
    else:
        b = bin_pow(n, int(d/2))
        return b*b
        


print(bin_pow(number, degree))
92/6:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if n%2 ==1:
        return bin_pow(n*n, d-1)
    else:
        b = bin_pow(n, int(d/2))
        return b*b
        


print(bin_pow(number, degree))
92/7:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if n%2 ==1:
        return bin_pow(n*n, d-1)
    else:
        b = bin_pow(n, int(d/2))
        return b*b
        


print(bin_pow(number, degree))
92/8:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if n%2 ==1:
        return bin_pow(n*n, d-1)
    else:
        b = bin_pow(n, int(d/2))
        return b*b
        


print(bin_pow(number, degree))
92/9:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if n%2 ==1:
        return bin_pow(n*n, d-1)
    else:
        b = bin_pow(n, int(d/2))
        return b*b
        

print()
print(bin_pow(number, degree))
92/10:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if n%2 ==1:
        return bin_pow(n, d-1)*n
    else:
        b = bin_pow(n, int(d/2))
        return b*b
        

print()
print(bin_pow(number, degree))
92/11:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if n%2 ==1:
        return bin_pow(n, d-1)*n
    else:
        b = bin_pow(n, int(d/2))
        return b*b
        

print()
print(bin_pow(number, degree))
92/12:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if n%2 ==1:
        return bin_pow(n, d-1)*n
    else:
        b = bin_pow(n, int(d/2))
        return b*b
        

print()
print(bin_pow(number, degree))
92/13:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if n%2 ==1:
        print(bin_pow(n, d-1)*n)
        return bin_pow(n, d-1)*n
    else:
        b = bin_pow(n, int(d/2))
        return b*b
        

print()
print(bin_pow(number, degree))
92/14:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if n%2 ==1:
        return bin_pow(n, d-1)*n
    else:
        b = bin_pow(n, int(d/2))
        return b*b
        

print()
print(bin_pow(number, degree))
92/15:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if n%2 ==1:
        n = n*n
        return bin_pow(n, d-1)
    else:
        b = bin_pow(n, int(d/2))
        return b*b
        

print()
print(bin_pow(number, degree))
92/16:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        return bin_pow(n*n, d-1)
    else:
        b = bin_pow(n, int(d/2))
        return b*b
        

print()
print(bin_pow(number, degree))
92/17:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        return bin_pow(n*n, d-1)
    else:
        b = bin_pow(n, int(d/2))
        return b*b
        

print()
print(bin_pow(number, degree))
92/18:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        return bin_pow(n*n, d-1)
    else:
        b = bin_pow(n, int(d/2))
        return b*b
        

print()
print(bin_pow(number, degree))
92/19:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        return bin_pow(n, d-1)
    else:
        b = bin_pow(n, int(d/2))
        return b*b
        

print()
print(bin_pow(number, degree))
92/20:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        return bin_pow(n, d-1) * n
    else:
        b = bin_pow(n, int(d/2))
        return b*b
        

print()
print(bin_pow(number, degree))
92/21:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        return bin_pow(n, d-1) * n
    else:
        b = bin_pow(n, int(d/2))
        return b*b
        

print()
print(bin_pow(number, degree))
92/22:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        return bin_pow(n, d-1) * n
    else:
        b = bin_pow(n, int(d/2))
        return b*b

print(bin_pow(number, degree))
92/23:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        return bin_pow(n, d-1) * n
    else:
        b = bin_pow(n, int(d/2))
        return b*b

print(bin_pow(number, degree))
92/24:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        return bin_pow(n, d-1) * n
    else:
        b = bin_pow(n, int(d/2))
        return b*b

print(bin_pow(number, degree))
92/25:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        return bin_pow(n, d-1) * n
    else:
        b = bin_pow(n, int(d/2))
        return b*b

print(bin_pow(number, degree))
92/26:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, int(d/2))
        return b*b

print(bin_pow(number, degree))
92/27: int(7/3)
92/28:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, int(d/2))
        return b*b

print(bin_pow(number, degree))
92/29:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, int(d/2))
        res = b*b
        return res

print(bin_pow(number, degree))
92/30:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, int(d/2))
        res = b*b
        return res

print(bin_pow(number, degree))
92/31:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, int(d/2))
        res = b*b
        return res

print(bin_pow(number, degree))
92/32:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, int(d/2))
        res = b*b
        return res

print(bin_pow(number, degree))
92/33:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, int(d/2))
        res = b*b
        return res

print(bin_pow(number, degree))
92/34:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, int(d/2))
        res = b*b
        return res

total = bin_pow(number, degree)
print(total)
92/35:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, int(d/2))
        res = b*b
        return res

bin_pow(number, degree)
92/36:
number = int(input())
degree = int(input())

def Power(a,n):
    if(n==0):
      return 1
    x=power(a,n/2)
    x=x*x
    if(n%2==1):
      x=x*a
    return x

Power(number, degree)
92/37:
number = int(input())
degree = int(input())

def power(a,n):
    if(n==0):
      return 1
    x=power(a,n/2)
    x=x*x
    if(n%2==1):
      x=x*a
    return x

power(number, degree)
92/38:
number = int(input())
degree = int(input())

def power(a,n):
    if(n==0):
      return 1
    x=power(a,n/2)
    x=x*x
    if(n%2==1):
      x=x*a
    return x

power(number, degree)
92/39:
number = int(input())
degree = int(input())

def power(a,n):
    if(n==0):
      return 1
    x=power(a,n/2)
    x=x*x
    if(n%2==1):
      x=x*a
    return x

power(number, degree)
92/40:
number = int(input())
degree = int(input())

def power(a,n):
    if(n==0):
      return 1
    x=power(a,int(n/2))
    x=x*x
    if(n%2==1):
      x=x*a
    return x

power(number, degree)
92/41:
number = int(input())
degree = int(input())

def power(a,n):
    if(n==0):
      return 1
    x=power(a,int(n/2))
    x=x*x
    if(n%2==1):
      x=x*a
    return x

power(number, degree)
92/42:
number = int(input())
degree = int(input())

def power(a,n):
    if(n==0):
      return 1
    x=power(a,int(n/2))
    x=x*x
    if(n%2==1):
      x=x*a
    return x

power(number, degree)
92/43:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, int(d/2))
        res = b*b
        return res

print(bin_pow(number, degree))
92/44:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, int(d/2))
        res = b*b
        return res

print(bin_pow(number, degree))
92/45:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, int(d/2))
        res = b*b
        return res

print(bin_pow(number, degree))
92/46:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, int(d/2))
        res = b*b
        return res

print(bin_pow(number, degree))
92/47:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, int(d/2))
        res = b*b
        return res

print(bin_pow(number, degree))
92/48:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        return bin_pow(n*n, d-1)
    else:
        b = bin_pow(n, d//2)
        res = b*b
        return res

print(bin_pow(number, degree))
92/49:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, d//2)
        res = b*b
        return res

print(bin_pow(number, degree))
92/50:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, d//2)
        res = b*b
        return res

print(bin_pow(number, degree))
92/51:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, d//2)
        res = b*b
        return res

print(bin_pow(number, degree))
92/52:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d < 0:
        return bin_pow(1/n, -d)
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, d//2)
        res = b*b
        return res

print(bin_pow(number, degree))
92/53:
number = int(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d < 0:
        return bin_pow(1/n, -d)
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, d//2)
        res = b*b
        return res

print(bin_pow(number, degree))
92/54:
number = float(input())
degree = int(input())

def bin_pow(n, d):
    if d == 0:
        return 1
    if d == 1:
        return n
    if d < 0:
        return bin_pow(1/n, -d)
    if d%2 == 1:
        res = bin_pow(n, d-1) * n
        return res
    else:
        b = bin_pow(n, d//2)
        res = b*b
        return res

print(bin_pow(number, degree))
93/1:
a = [1,2,13,1121,121212]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)
        if arr[guess] == item
            return item
        if arr[guess] < item:
            low = guess
        else:
            high = guess
        
res = search(a, 2)
print(res)
93/2:
a = [1,2,13,1121,121212]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)
        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess
        else:
            high = guess
        
res = search(a, 2)
print(res)
93/3:
a = [1,2,13,1121,121212]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)
        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess
        else:
            high = guess
        
res = search(a, 13)
print(res)
93/4:
a = [1,2,13,1121,121212]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)
        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess
        else:
            high = guess
    return None
        
res = search(a, 121212)
print(res)
93/5:
a = [1,2,13,1121,121212]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)
        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess
        else:
            high = guess
    return None
        
res = search(a, 1)
print(res)
93/6:
a = [1,2,13,1121,121212]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)
        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess
        else:
            high = guess
    return None
        
res = search(a, 2)
print(res)
93/7:
a = [1,2,13,1121]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)
        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess
        else:
            high = guess
    return None
        
res = search(a, 2)
print(res)
93/8:
a = [1,2,13,1121]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)
        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess
        else:
            high = guess
    return None
        
res = search(a, 1)
print(res)
93/9:
a = [1,2,13,1121]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)
        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess
        else:
            high = guess
    return None
        
res = search(a, 13)
print(res)
93/10:
a = [1,2,13,1121]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)
        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess
        else:
            high = guess
    return None
        
res = search(a, 1121)
print(res)
93/11:
a = [1,2,13,1121]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)
        print(guess)
        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess
        else:
            high = guess
    return None
        
res = search(a, 1121)
print(res)
93/12:
a = [1,2,13,1121]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)
        print(guess)
        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess + 1
        else:
            high = guess
    return None
        
res = search(a, 1121)
print(res)
93/13:
a = [1,2,13,1121]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)
        print(guess)
        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess + 1
        else:
            high = guess
    return None
        
res = search(a, 1)
print(res)
93/14:
a = [1,2,13]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)

        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess + 1
        else:
            high = guess
    return None
        
res = search(a, 1)
print(res)
93/15:
a = [1]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)

        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess + 1
        else:
            high = guess
    return None
        
res = search(a, 1)
print(res)
93/16:
a = [1,2]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)

        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess + 1
        else:
            high = guess
    return None
        
res = search(a, 1)
print(res)
93/17:
a = [1,2,3]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)

        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess + 1
        else:
            high = guess
    return None
        
res = search(a, 1)
print(res)
93/18:
a = [1,2,3]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)

        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess + 1
        else:
            high = guess
    return None
        
res = search(a, 2)
print(res)
93/19:
a = [1,2,3]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)

        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess + 1
        else:
            high = guess
    return None
        
res = search(a, 3)
print(res)
93/20:
a = [1,2,3]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)

        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess + 1
        else:
            high = guess
    return None
        
res = search(a, 3)
print(res)
93/21:
a = [1,2,3]

def search(arr, item):
    low = 0
    high = len(arr) -1
    
    while low <= high:
        guess = round((low+high)/2)

        if arr[guess] == item:
            return item
        if arr[guess] < item:
            low = guess + 1
        else:
            high = guess
    return None
        
res = search(a, 3)
print(res)
94/1:
Cn = int(input())
Ck = int(input())

def c(n, k):
    if k == 0:
        return 1
    else:
        return c(n-1, k-1) + c(n-1, k)
94/2:
Cn = int(input())
Ck = int(input())

def c(n, k):
    if k == 0:
        return 1
    else:
        return c(n-1, k-1) + c(n-1, k)
print(c(Cn, Ck))
94/3:
Cn = int(input())
Ck = int(input())

def c(n, k):
    if k == 0:
        return 1
    else:
        return c(n-1, k-1) + c(n-1, k)
print(c(Cn, Ck))
94/4:
Cn = int(input())
Ck = int(input())

def c(n, k):
    if k == 0:
        return 1
    else:
        res1 = c(n-1, k)
        res2 = c(n-1, k-1)
        return res1 + res2
print(c(Cn, Ck))
94/5:
Cn = int(input())
Ck = int(input())

def c(n, k):
    if k == 0:
        return 1
    else:
        res1 = c(n-1, k)
#         res2 = c(n-1, k-1)
#         return res1 + res2
        return res
print(c(Cn, Ck))
94/6:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while n >= 0 and k >=0:
        if k == 0:
            return 1
        else:
            res1 = c(n-1, k)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res
print(c(Cn, Ck))
94/7:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while n >= 0 and k >=0:
        if k == 0:
            return 1
        else:
            res1 = c(n-1, k)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
print(c(Cn, Ck))
94/8:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while n >= 0 and k >=0:
        if k == 0:
            return 1
        else:
            res1 = c(n-1, k)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
    return None
print(c(Cn, Ck))
94/9:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while n >= 0 and k >=0:
        if k == 0:
            return 1
        else:
            res1 = c(n-1, k)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
    return None
print(c(Cn, Ck))
94/10:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while n >= 0 and k >=0:
        if k == 0:
            return 1
        else:
            res1 = c(n-1, k)
            print(f'res1', res1)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
    return None
print(c(Cn, Ck))
94/11:
Cn = int(input())
Ck = int(input())

def c(n, k):
    if n >= 0 and k >=0:
        if k == 0:
            return 1
        else:
            res1 = c(n-1, k)
            print(f'res1', res1)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
print(c(Cn, Ck))
94/12:
Cn = int(input())
Ck = int(input())

def c(n, k):
    if n >= 0 and k >=0:
        if k == 0:
            return 1
        else:
            res1 = c(n-1, k)
            print('n-1', n-1)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
print(c(Cn, Ck))
94/13:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while n >= 0 and k >=0:
        if k == 0:
            return 1
        else:
            res1 = c(n-1, k)
            print('n-1', n-1)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
print(c(Cn, Ck))
94/14:
Cn = int(input())
Ck = int(input())

def c(n, k):
    if k == 0:
        return 1
    else:
        res1 = c(n-1, k)
        print('n-1', n-1)
#         res2 = c(n-1, k-1)
#         return res1 + res2
        return res1
print(c(Cn, Ck))
94/15:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        else:
            res1 = c(n-1, k)
            print('n-1', n-1)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
print(c(Cn, Ck))
94/16:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        else:
            res1 = c(n-1, k)
            print('res1', res1)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
print(c(Cn, Ck))
94/17:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        if j == 1:
            return n
        else:
            res1 = c(n-1, k)
            print('res1', res1)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
print(c(Cn, Ck))
94/18:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        if k == 1:
            return n
        else:
            res1 = c(n-1, k)
            print('res1', res1)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
print(c(Cn, Ck))
94/19:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        if k == 1:
            return n
        else:
            res1 = c(n-1, k) + 1
            print('res1', res1)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
print(c(Cn, Ck))
94/20:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        if k == 1:
            return n
        else:
            res1 = 1
            print('res1', res1)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
print(c(Cn, Ck))
94/21:
## Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        if k == 1:
            return n
        else:
            res1 = 1
            print('res1', res1)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
print(c(Cn, Ck))
94/22:
## Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        if k == 1:
            return n
        else:
            res1 = 1
            print('res1', res1)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
print(c(Cn, Ck))
94/23:
### Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        if k == 1:
            return n
        else:
            res1 = 1
            print('res1', res1)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
print(c(Cn, Ck))
94/24:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        if k == 1:
            return n
        else:
            res1 = 1
            print('res1', res1)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
print(c(Cn, Ck))
94/25:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        if k == 1:
            return n
        else:
            res1 = 1
            print('res1', res1)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
print(c(Cn, Ck))
94/26:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        if k == 1:
            return n
        if n == k:
            return 1
        else:
            res1 = c(n-1, k)
            print('res1', res1)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
print(c(Cn, Ck))
94/27:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        if k == 1:
            return n
        if n == k:
            return 1
        else:
            res1 = c(n-1, k)
            print('res1', res1)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
print(c(Cn, Ck))
94/28:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        if k == 1:
            return n
        if n == k:
            return 1
        else:
            res1 = c(n-1, k)
            print('res1', res1)
    #         res2 = c(n-1, k-1)
    #         return res1 + res2
            return res1
print(c(Cn, Ck))
94/29:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        if k == 1:
            return n
        if n == k:
            return 1
        else:
            res1 = c(n-1, k)
            res2 = c(n-1, k-1)
            return res1 + res2
print(c(Cn, Ck))
94/30:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        if k == 1:
            return n
        if n == k:
            return 1
        else:
            res1 = c(n-1, k)
            res2 = c(n-1, k-1)
            return res1 + res2
print(c(Cn, Ck))
94/31:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        if k == 1:
            return n
        if n == k:
            return 1
        else:
            res1 = c(n-1, k)
            res2 = c(n-1, k-1)
            return res1 + res2
print(c(Cn, Ck))
94/32:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        if k == 1:
            return n
        if n == k:
            return 1
        else:
            res1 = c(n-1, k)
            res2 = c(n-1, k-1)
            return res1 + res2
print(c(Cn, Ck))
94/33:
Cn = int(input())
Ck = int(input())

def c(n, k):
    while k <= n:
        if k == 0:
            return 1
        if k == 1:
            return n
        if n == k:
            return 1
        else:
            res1 = c(n-1, k)
            res2 = c(n-1, k-1)
            return res1 + res2
print(c(Cn, Ck))
95/1:
n = int(input())
m = int(input())

def gcd(a, b):
    if a < b:
        a, b = b, a
    
    if b != 0:
        return gcd(b, a % b)
    else:
        return a
    
print(gcd(n, m))
95/2:
n = int(input())
m = int(input())

def gcd(a, b):
    if a < b:
        a, b = b, a
    
    if b != 0:
        return gcd(b, a % b)
    else:
        return a
    
print(gcd(n, m))
95/3:
n = int(input())
m = int(input())

def gcd(a, b):
    if a < b:
        a, b = b, a
    
    if b != 0:
        return gcd(b, a % b)
    else:
        return a
    
print(gcd(n, m))
95/4:
n = int(input())
m = int(input())

def gcd(a, b):
    if a < b:
        a, b = b, a
    
    if b != 0:
        return gcd(b, a % b)
    else:
        return a
    
print(gcd(n, m))
95/5:
n = int(input())
m = int(input())

def gcd(a, b):
    if a < b:
        a, b = b, a
    
    if b != 0:
        return gcd(b, a % b)
    else:
        return a
    
print(gcd(n, m))
95/6:
n = int(input())
m = int(input())

def gcd(a, b):
    if a < b:
        a, b = b, a
    
    if b != 0:
        return gcd(b, a % b)
    else:
        return a
    
print(gcd(n, m))
95/7:
n = int(input())
m = int(input())

def gcd(a, b):
    if a < b:
        a, b = b, a
    
    if b != 0:
        return gcd(b, a % b)
    else:
        return a
    
print(gcd(n, m))
95/8:
n = int(input())
m = int(input())

def gcd(a, b):
    if a < b:
        a, b = b, a
    
    if b != 0:
        return gcd(b, a % b)
    else:
        return a
    
print(gcd(n, m))
95/9:
n = int(input())
m = int(input())

def gcd(a, b):
    if a < b:
        a, b = b, a
    
    if b != 0:
        return gcd(b, a % b)
    else:
        return a
    
print(gcd(n, m))
96/1:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return n
    return


print(isPrime(number))
96/2:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return n
    return


print(isPrime(number))
96/3:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n


print(isPrime(number))
96/4:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n


print(isPrime(number))
96/5:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(2, number, 1):
        return isPrime(n)
    

print(getSegment(number))
96/6:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(3, number, 1):
        return isPrime(n)
    

print(getSegment(number))
96/7:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(3, number, 1):
        return isPrime(n)
    

print(getSegment(number))
96/8:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(2, number, 1):
        return isPrime(n)
    

print(getSegment(number))
96/9:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(2, number):
        return isPrime(n)
    

print(getSegment(number))
96/10:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(2, number):
        print(n)
        return isPrime(n)
    
print()
print(getSegment(number))
96/11:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(2, number):
        print(n)
        return isPrime(n)
    
print()
print(getSegment(number))
96/12:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(2, number):
        print(n)
        return isPrime(n)
    
print()
print(getSegment(number))
96/13:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(2, number):
        print(n)
        return isPrime(n)
    
print()
print(getSegment(number))
96/14:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(2, number):
        print(n)
        isPrime(n)
    
print()
print(getSegment(number))
96/15:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(2, number):
#         print(n)
        isPrime(n)
    
print()
print(getSegment(number))
96/16:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    i = 2
    while i <= number:
        isPrime(n)
        i++
    
print()
print(getSegment(number))
96/17:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    i = 2
    while i <= number:
        isPrime(n)
        i+=i
    
print()
print(getSegment(number))
96/18:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    i = 2
    while i <= number:
        isPrime(i)
        i+=i
    
print()
print(getSegment(number))
96/19:
import math
number = int(input())
print()

def isPrime(n):
    print(n)
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(2, number):
        isPrime(n)
    
print()
print(getSegment(number))
96/20:
import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(2, number):
        res = isPrime(n)
        if res !== None:
            return res
    
print()
print(getSegment(number))
96/21:
# import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(2, number):
        res = isPrime(n)
        if res !== None:
            return res
    
print()
print(getSegment(number))
96/22:
# import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(2, number):
        res = isPrime(n)
        if res != None:
            return res
    
print()
print(getSegment(number))
96/23:
# import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(2, number):
        res = isPrime(n)
        print(res)
        if res != None:
            return res
    
print()
print(getSegment(number))
96/24:
# import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    print(n)
    return n

def getSegment(number):
    for n in range(2, number):
        res = isPrime(n)
        if res != None:
            return res
    
print()
print(getSegment(number))
96/25:
# import math
number = int(input())
print()

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    print(n)
    return n

def getSegment(number):
    for n in range(2, number):
        res = isPrime(n)
        if res != None:
            return res
    
print()
print(getSegment(number))
96/26:
# import math
number = int(input())
print()

def isPrime(n):
    print(n)
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(2, number):
        res = isPrime(n)
        if res != None:
            return res
    
print()
print(getSegment(number))
96/27:
# import math
number = int(input())
print()

def isPrime(n):
    print(n)
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(2, number):
        res = isPrime(n)
        return res
    
print()
print(getSegment(number))
96/28:
# import math
number = int(input())
print()

def isPrime(n):
    print(n)
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(2, number):
        print(n)
        return isPrime(n)
    
print()
print(getSegment(number))
96/29:
# import math
number = int(input())

def isPrime(n):
    print(n)
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    for n in range(2, number):
        print(n)
        isPrime(n)
    
print()
print(getSegment(number))
96/30:
# import math
number = int(input())

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    ans = []
    for n in range(2, number):
        res = isPrime(n)
        print(res)
    
print()
print(getSegment(number))
96/31:
# import math
number = int(input())

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    ans = []
    for n in range(2, number):
        res = isPrime(n)
        if res != None:
            ans.append(res)
    return ans
    
print()
print(getSegment(number))
96/32:
# import math
number = int(input())

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    ans = []
    for n in range(2, number):
        res = isPrime(n)
        if res != None:
            ans.append(res)
    return ans
    
print()
print(getSegment(number))
96/33:
# import math
number = int(input())

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    ans = []
    for n in range(2, number):
        res = isPrime(n)
        if res != None:
            ans.append(res)
    return ans
    
print()
print(getSegment(number))
96/34:
# import math
number = int(input())

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    ans = []
    for n in range(2, number+1):
        res = isPrime(n)
        if res != None:
            ans.append(res)
    return ans
    
print()
print(getSegment(number))
96/35:
# import math
number = int(input())

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    ans = []
    for n in range(2, number + 1):
        res = isPrime(n)
        if res != None:
            ans.append(res)
    return ans.join()
    
print()
print(getSegment(number))
96/36:
# import math
number = int(input())

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    ans = []
    for n in range(2, number + 1):
        res = isPrime(n)
        if res != None:
            ans.append(res)
    return "".join(ans)
    
print()
print(getSegment(number))
96/37:
# import math
number = int(input())

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    ans = []
    for n in range(2, number + 1):
        res = isPrime(n)
        if res != None:
            ans.append(res)
    return ''.join(ans)
    
print()
print(getSegment(number))
96/38:
# import math
number = int(input())

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    ans = []
    for n in range(2, number + 1):
        res = isPrime(n)
        if res != None:
            ans.append(res)
    str = ''
    return str.join(ans)
    
print()
print(getSegment(number))
96/39:
# import math
number = int(input())

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    ans = []
    for n in range(2, number + 1):
        res = isPrime(n)
        if res != None:
            ans.append(res)
    return ', '.join(str(x) for x in list) 
    
print()
print(getSegment(number))
96/40:
# import math
number = int(input())

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    ans = []
    for n in range(2, number + 1):
        res = isPrime(n)
        if res != None:
            ans.append(res)
    return ', '.join(str(x) for x in ans) 
    
print()
print(getSegment(number))
96/41:
# import math
number = int(input())

def isPrime(n):
    s = round(math.sqrt(n)) + 1
    for i in range(2, s, 1):
        if n % i == 0:
            return
    return n

def getSegment(number):
    ans = []
    for n in range(2, number + 1):
        res = isPrime(n)
        if res != None:
            ans.append(res)
    return ' '.join(str(x) for x in ans) 
    
print()
print(getSegment(number))
98/1:
a = [1,2,13,1121,121212]
b = [1,2,13,1121]

def search(arr, item):
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = int((low + high)/2)
        guess = arr[mid]
        if(guess == item):
            return guess
        if(guess > item):
            high = mid - 1
        else:
            low = mid
    return None

res = binary_search(a, 1)
print(res)
res1 = binary_search(a, 121212)
print(res1)
res2 = binary_search(a, 13)
print(res2)

print()
res3 = binary_search(b, 1)
print(res3)
res4 = binary_search(b, 1121)
print(res4)
res5 = binary_search(b, 13)
print(res5)
99/1:
# binary search
import math

a = [1,2,13,1121,121212]
b = [1,2,13,1121]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = math.floor((low + high)/2)
        guess = arr[mid]
        if guess == item:
            return item
        if guess > item:
            high = mid - 1
        else:
            low = mid + 1
    return None

res = binary_search(a, 1)
print(res)
res1 = binary_search(a, 121212)
print(res1)
res2 = binary_search(a, 13)
print(res2)

print()
res3 = binary_search(b, 1)
print(res3)
res4 = binary_search(b, 1121)
print(res4)
res5 = binary_search(b, 13)
print(res5)
99/2:
# binary search
import math

a = [1,2,13,1121,121212]
b = [1,2,13,1121]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = math.floor((low + high)/2)
        guess = arr[mid]
        if guess == item:
            return item
        if guess > item:
            high = mid - 1
        else:
            low = mid
    return None

res = binary_search(a, 1)
print(res)
res1 = binary_search(a, 121212)
print(res1)
res2 = binary_search(a, 13)
print(res2)

print()
res3 = binary_search(b, 1)
print(res3)
res4 = binary_search(b, 1121)
print(res4)
res5 = binary_search(b, 13)
print(res5)
99/3:
# binary search
import math

a = [1,2,13,1121,121212]
b = [1,2,13,1121]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = math.floor((low + high)/2)
        guess = arr[mid]
        if guess == item:
            return item
        if guess > item:
            high = mid - 1
        else:
            low = mid + 1
    return None

res = binary_search(a, 1)
print(res)
res1 = binary_search(a, 121212)
print(res1)
res2 = binary_search(a, 13)
print(res2)

print()
res3 = binary_search(b, 1)
print(res3)
res4 = binary_search(b, 1121)
print(res4)
res5 = binary_search(b, 13)
print(res5)
99/4:
# binary search
import math

a = [1,2,13,1121,121212]
b = [1,2,13,1121]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = math.floor((low + high)/2)
        guess = arr[mid]
        if guess == item:
            return item
        if guess > item:
            high = mid
        else:
            low = mid + 1
    return None

res = binary_search(a, 1)
print(res)
res1 = binary_search(a, 121212)
print(res1)
res2 = binary_search(a, 13)
print(res2)

print()
res3 = binary_search(b, 1)
print(res3)
res4 = binary_search(b, 1121)
print(res4)
res5 = binary_search(b, 13)
print(res5)
99/5:
# binary search
import math

a = [1,2,13,1121,121212]
b = [1,2,13,1121]

def binary_search(arr, item):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = math.floor((low + high)/2)
        guess = arr[mid]
        if guess == item:
            return item
        if guess > item:
            high = mid
        else:
            low = mid + 1
    return None

res = binary_search(a, 1)
print(res)
res1 = binary_search(a, 121212)
print(res1)
res2 = binary_search(a, 13)
print(res2)

print()
res3 = binary_search(b, 1)
print(res3)
res4 = binary_search(b, 1121)
print(res4)
res5 = binary_search(b, 13)
print(res5)
98/2:
a = [1,2,13,1121,121212]
b = [1,2,13,1121]

def search(arr, item):
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = int((low + high)/2)
        guess = arr[mid]
        if(guess == item):
            return guess
        if(guess > item):
            high = mid - 1
        else:
            low = mid
    return None

res = search(a, 1)
print(res)
res1 = search(a, 121212)
print(res1)
res2 = search(a, 13)
print(res2)

print()
res3 = search(b, 1)
print(res3)
res4 = search(b, 1121)
print(res4)
res5 = search(b, 13)
print(res5)
98/3:
a = [1,2,13,1121,121212]
b = [1,2,13,1121]

def search(arr, item):
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = int((low + high)/2)
        guess = arr[mid]
        if(guess == item):
            return guess
        if(guess >= item):
            high = mid - 1
        else:
            low = mid
    return None

res = search(a, 1)
print(res)
res1 = search(a, 121212)
print(res1)
res2 = search(a, 13)
print(res2)

print()
res3 = search(b, 1)
print(res3)
res4 = search(b, 1121)
print(res4)
res5 = search(b, 13)
print(res5)
98/4:
a = [1,2,13,1121,121212]
b = [1,2,13,1121]

def search(arr, item):
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = int((low + high)/2)
        guess = arr[mid]
        if(guess == item):
            return guess
        if(guess > item):
            high = mid 
        else:
            low = mid + 1
    return None

res = search(a, 1)
print(res)
res1 = search(a, 121212)
print(res1)
res2 = search(a, 13)
print(res2)

print()
res3 = search(b, 1)
print(res3)
res4 = search(b, 1121)
print(res4)
res5 = search(b, 13)
print(res5)
100/1:
# сложность сортировки выбором O(n2)
def find_smallest(arr):
    i_sm = 0
    elem_sm = arr[i_sm]
    for i in range(len(arr)):
        if elem_sm > arr[i]:
                i_sm = i
                elem_sm = arr[i]
    return i_sm

def selection_sort(arr):
    new_arr = []
    for i in range(len(arr)):
        smallest_index = find_smallest(arr)
        new_arr.append(arr.pop(smallest_index))
    return new_arr

print(selection_sort([5, 3, 6, 2, 10]))
print(selection_sort([0, 0, 1]))
print(selection_sort([-1, -2, 1]))
100/2:
# сложность сортировки выбором O(n2)
def find_smallest(arr):
    i_sm = 0
    elem_sm = arr[i_sm]
    for i in range(len(arr)):
        if elem_sm > arr[i]:
                i_sm = i
                elem_sm = arr[i]
    return i_sm

def selection_sort(arr):
    new_arr = []
    for i in range(len(arr)):
        smallest_index = find_smallest(arr)
        new_arr.append(arr.pop(smallest_index))
    return new_arr

print(selection_sort([5, 3, 6, 2, 10]))
print(selection_sort([0, 1000, 1]))
print(selection_sort([-1, -2, 1]))
101/1:
# f(n) = f(n-1) + f(n-2)
# n 0,1 ...

number = int(input())

def fibonacci(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    return fibonacci(n-1) + fibonacci(n-2)
101/2:
# f(n) = f(n-1) + f(n-2)
# n 0,1 ...

number = int(input())

def fibonacci(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    return fibonacci(n-1) + fibonacci(n-2)
        
print(fibonacci(number))
101/3:
# f(n) = f(n-1) + f(n-2)
# n 0,1 ...

number = int(input())

def fibonacci(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    return fibonacci(n-1) + fibonacci(n-2)
        
print(fibonacci(number))
101/4:
# f(n) = f(n-1) + f(n-2)
# n 0,1 ...

number = int(input())

def fibonacci(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    return fibonacci(n-1) + fibonacci(n-2)
        
print(fibonacci(number))
101/5:
# f(n) = f(n-1) + f(n-2)
# n 0,1 ...
# f(n-1) = f(n-2) + f(n-3)

number = int(input())
memo = [0] * number

def fibonacci(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    if memo[n] > 0:
        return memo[n]
    else:
        memo[n] = fibonacci(n-1) + fibonacci(n-2)
        print(memo[n])
    return memo[n]

print()
print(fibonacci(number))
101/6:
# f(n) = f(n-1) + f(n-2)
# n 0,1 ...
# f(n-1) = f(n-2) + f(n-3)

number = int(input())
memo = [0] * (number+1)

def fibonacci(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    if memo[n] > 0:
        return memo[n]
    else:
        memo[n] = fibonacci(n-1) + fibonacci(n-2)
        print(memo[n])
    return memo[n]

print()
print(fibonacci(number))
101/7:
number = int(input())
memo = [0] * (number+1)

def fibonacci(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    return fibonacci(n-1) + fibonacci(n-2)

print()
print(fibonacci(number))
101/8:
number = int(input())

def fibonacci(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    return fibonacci(n-1) + fibonacci(n-2)

print()
print(fibonacci(number))
101/9:
number = int(input())

def fibonacci(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    print(fibonacci(n-1) + fibonacci(n-2))
    return fibonacci(n-1) + fibonacci(n-2)

print()
print(fibonacci(number))
101/10:
# f(n) = f(n-1) + f(n-2)
# n 0,1 ...
# f(n-1) = f(n-2) + f(n-3)

number = int(input())
memo = [0] * (number+1)

def fibonacci(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    if memo[n] > 0:
        return memo[n]
    else:
        memo[n] = fibonacci(n-1) + fibonacci(n-2)
    print(memo)
    return memo[n]

print()
print(fibonacci(number))
102/1:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]


def binary_search(low, high):
102/2:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]


def binary_search(low, high):
    return
102/3:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]


def binary_search(low, high):
    return
    
print(a)
print(b)
print(numbers)
102/4:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

arr = [10, 10, 10, 10, 10, 10, 10]
numbers = [3, 10]

def binary_search(low, high, item):
    while low <= high:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] > item:
            low = mid + 1
        else:
            high = mid - 1
    diff_low = item - arr[low]
    diff_high = item - arr[high]
    if diff_high < diff_low:
        return arr[high]
    return arr[low]
    
    
    
for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i])
  
    
# 5 5
# 1 3 5 7 9 
# 2 4 8 1 6
102/5:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

# arr = [10, 10, 10, 10, 10, 10, 10]
# numbers = [3, 10]

def binary_search(low, high, item):
    while low <= high:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] > item:
            low = mid + 1
        else:
            high = mid - 1
    diff_low = item - arr[low]
    diff_high = item - arr[high]
    if diff_high < diff_low:
        return arr[high]
    return arr[low]
    
    
    
for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i])
  
    
# 5 5
# 1 3 5 7 9 
# 2 4 8 1 6
102/6:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

# arr = [10, 10, 10, 10, 10, 10, 10]
# numbers = [3, 10]

def binary_search(low, high, item):
    while low <= high:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] > item:
            low = mid + 1
        else:
            high = mid - 1
    diff_low = item - arr[low]
    diff_high = item - arr[high]
    if diff_high < diff_low:
        return arr[high]
    return arr[low]
    
    
    
for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i])
  
    
# 5 5
# 1 3 5 7 9 
# 2 4 8 1 6
102/7:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

# arr = [10, 10, 10, 10, 10, 10, 10]
# numbers = [3, 10]

def binary_search(low, high, item):
    while low <= high:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] > item:
            low = mid + 1
        else:
            high = mid - 1
    diff_low = item - arr[low]
    diff_high = item - arr[high]
    if diff_high < diff_low:
        return arr[high]
    return arr[low]
    
    
    
for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i])
102/8:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

# arr = [10, 10, 10, 10, 10, 10, 10]
# numbers = [3, 10]

def binary_search(low, high, item):
    while low <= high:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] > item:
            low = mid + 1
        else:
            high = mid - 1
    diff_low = item - arr[low]
    diff_high = item - arr[high]
    if diff_high < diff_low:
        return arr[high]
    return arr[low]
    
    
    
for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i])
102/9:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

# arr = [10, 10, 10, 10, 10, 10, 10]
# numbers = [3, 10]

def binary_search(low, high, item):
    while low <= high:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] > item:
            low = mid + 1
        else:
            high = mid - 1
    diff_low = item - arr[low]
    diff_high = item - arr[high]
    if diff_high < diff_low:
        return arr[high]
    return arr[low]
    
    
    
for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i])
102/10:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

# arr = [10, 10, 10, 10, 10, 10, 10]
# numbers = [3, 10]
# 5 5
# 1 3 5 7 9 
# 2 4 8 1 6 

def binary_search(low, high, item):
    while low <= high:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] > item:
            low = mid + 1
        else:
            high = mid - 1
    diff_low = item - arr[low]
    diff_high = item - arr[high]
    if diff_high < diff_low:
        return arr[high]
    return arr[low]
    

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
102/11:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

# arr = [10, 10, 10, 10, 10, 10, 10]
# numbers = [3, 10]
# 5 5
# 1 3 5 7 9 
# 2 4 8 1 6 

def binary_search(low, high, item):
    while low <= high:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] > item:
            low = mid + 1
        else:
            high = mid - 1
    print('low', low)
    print('high', high)
    diff_low = item - arr[low]
    diff_high = item - arr[high]
    if diff_high < diff_low:
        return arr[high]
    return arr[low]
    

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
102/12:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

# arr = [10, 10, 10, 10, 10, 10, 10]
# numbers = [3, 10]
# 5 5
# 1 3 5 7 9 
# 2 4 8 1 6 

def binary_search(low, high, item):
    while low < high:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] > item:
            low = mid + 1
        else:
            high = mid - 1
    print('low', low)
    print('high', high)
    diff_low = item - arr[low]
    diff_high = item - arr[high]
    if diff_high < diff_low:
        return arr[high]
    return arr[low]
    

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
102/13:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

# arr = [10, 10, 10, 10, 10, 10, 10]
# numbers = [3, 10]
# 5 5
# 1 3 5 7 9 
# 2 4 8 1 6 

def binary_search(low, high, item):
    while low < high:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] < item:
            low = mid + 1
        else:
            high = mid - 1
    print('low', low)
    print('high', high)
    diff_low = item - arr[low]
    diff_high = item - arr[high]
    if diff_high < diff_low:
        return arr[high]
    return arr[low]
    

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
102/14:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

# arr = [10, 10, 10, 10, 10, 10, 10]
# numbers = [3, 10]
# 5 5
# 1 3 5 7 9 
# 2 4 8 1 6 

def binary_search(low, high, item):
    while low < high:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] < item:
            low = mid
        else:
            high = mid - 1
    print('low', low)
    print('high', high)
    diff_low = item - arr[low]
    diff_high = item - arr[high]
    if diff_high < diff_low:
        return arr[high]
    return arr[low]
    

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
102/15:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

# arr = [10, 10, 10, 10, 10, 10, 10]
# numbers = [3, 10]
# 5 5
# 1 3 5 7 9 
# 2 4 8 1 6 

def binary_search(low, high, item):
    while low < high:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] < item:
            low = mid + 1
        else:
            high = mid - 1
    low -= 1
    print('low', low)
    print('high', high)
    diff_low = item - arr[low]
    diff_high = item - arr[high]
    if diff_high < diff_low:
        return arr[high]
    return arr[low]
    

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
102/16:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

# arr = [10, 10, 10, 10, 10, 10, 10]
# numbers = [3, 10]
# 5 5
# 1 3 5 7 9 
# 2 4 8 1 6 

def binary_search(low, high, item):
    while low < high:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] < item:
            low = mid + 1
        else:
            high = mid - 1
    low -= 1
    print('low', low)
    print('high', high)
    diff_low = item - arr[low]
    diff_high = arr[high] - item
    if diff_high < diff_low:
        return arr[high]
    return arr[low]
    

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
102/17:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

# arr = [10, 10, 10, 10, 10, 10, 10]
# numbers = [3, 10]
# 5 5
# 1 3 5 7 9 
# 2 4 8 1 6

# 10 10
# -5 1 1 3 5 5 8 12 13 16 
# 0 3 7 -17 23 11 0 11 15 7 

def binary_search(low, high, item):
    while low < high:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] < item:
            low = mid + 1
        else:
            high = mid - 1
    low -= 1
    diff_low = item - arr[low]
    diff_high = arr[high] - item
    if diff_high < diff_low:
        return arr[high]
    return arr[low]
    

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
102/18:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

# arr = [10, 10, 10, 10, 10, 10, 10]
# numbers = [3, 10]
# 5 5
# 1 3 5 7 9 
# 2 4 8 1 6

# 10 10
# -5 1 1 3 5 5 8 12 13 16 
# 0 3 7 -17 23 11 0 11 15 7 

def binary_search(low, high, item):
    while low < high:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] < item:
            low = mid + 1
        else:
            high = mid - 1
    low -= 1
    diff_low = item - arr[low]
    diff_high = arr[high] - item
    if abs(diff_high) < abs(diff_low):
        return arr[high]
    return arr[low]
    

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
    
# 1
# 3
# 8
# -5
# 16
# 12
# 1
# 12
# 16
# 8
102/19:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

# arr = [10, 10, 10, 10, 10, 10, 10]
# numbers = [3, 10]
# 5 5
# 1 3 5 7 9 
# 2 4 8 1 6

# 10 10
# -5 1 1 3 5 5 8 12 13 16 
# 0 3 7 -17 23 11 0 11 15 7 

def binary_search(low, high, item):
    while low < high:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] < item:
            low = mid + 1
        else:
            high = mid - 1
    low -= 1
    diff_low = item - arr[low]
    diff_high = arr[high] - item
    print('diff_low', diff_low)
    print('diff_hig',diff_high)
    if abs(diff_high) < abs(diff_low):
        return arr[high]
    return arr[low]
    

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
    
# 1
# 3
# 8
# -5
# 16
# 12
# 1
# 12
# 16
# 8
102/20:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

# arr = [10, 10, 10, 10, 10, 10, 10]
# numbers = [3, 10]
# 5 5
# 1 3 5 7 9 
# 2 4 8 1 6

# 10 10
# -5 1 1 3 5 5 8 12 13 16 
# 0 3 7 -17 23 11 0 11 15 7 

def binary_search(low, high, item):
    while low < high:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] < item:
            low = mid + 1
        else:
            high = mid - 1
    if low > 0:
        low -= 1
    diff_low = item - arr[low]
    diff_high = arr[high] - item
    print('diff_low', diff_low)
    print('diff_hig',diff_high)
    if abs(diff_high) < abs(diff_low):
        return arr[high]
    return arr[low]
    

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
    
# 1
# 3
# 8
# -5
# 16
# 12
# 1
# 12
# 16
# 8
102/21:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

# arr = [10, 10, 10, 10, 10, 10, 10]
# numbers = [3, 10]
# 5 5
# 1 3 5 7 9 
# 2 4 8 1 6

# 10 10
# -5 1 1 3 5 5 8 12 13 16 
# 0 3 7 -17 23 11 0 11 15 7 

def binary_search(low, high, item):
    while low < high:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] < item:
            low = mid + 1
        else:
            high = mid - 1
    print('low', low)
    print('high',high)
    if low > 0:
        low -= 1
    diff_low = item - arr[low]
    diff_high = arr[high] - item
    if abs(diff_high) < abs(diff_low):
        return arr[high]
    return arr[low]
    

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
    
# 1
# 3
# 8
# -5
# 16
# 12
# 1
# 12
# 16
# 8
102/22:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

# arr = [10, 10, 10, 10, 10, 10, 10]
# numbers = [3, 10]
# 5 5
# 1 3 5 7 9 
# 2 4 8 1 6

# 10 10
# -5 1 1 3 5 5 8 12 13 16 
# 0 3 7 -17 23 11 0 11 15 7 

def binary_search(low, high, item):
    while low < (high-1):
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] < item:
            low = mid + 1
        else:
            high = mid - 1
    print('low', low)
    print('high',high)

#     low -= 1
    diff_low = item - arr[low]
    diff_high = arr[high] - item
    if abs(diff_high) < abs(diff_low):
        return arr[high]
    return arr[low]
    

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
    
# 1
# 3
# 8
# -5
# 16
# 12
# 1
# 12
# 16
# 8
105/1:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]


def binary_search(low, high, item):
        while low <= high - 1:
            mid = (low + high)//2
            if arr[mid] == item:
                return arr[mid]
            if arr[mid] < item:
                low = mid + 1
            else:
                high = mid

        if (low == high) & (low > 0):
            low -= 1
            diff_low = item - arr[low],
            diff_high = arr[high] - item,
        if abs(diff_high) < abs(diff_low):
            return arr[high]
        return arr[low]

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
105/2:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]


def binary_search(low, high, item):
    while low <= high - 1:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] < item:
            low = mid + 1
        else:
            high = mid
    if (low == high) & (low > 0):
        low -= 1
        diff_low = item - arr[low],
        diff_high = arr[high] - item,
    if abs(diff_high) < abs(diff_low):
        return arr[high]
    return arr[low]

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
105/3:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]


def binary_search(low, high, item):
    while low <= high - 1:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] < item:
            low = mid + 1
        else:
            high = mid
    if (low == high) & (low > 0):
        low -= 1
        diff_low = item - arr[low],
        diff_high = arr[high] - item,
    if abs(diff_high) < abs(diff_low):
        return arr[high]
    return arr[low]

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
105/4:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]


def binary_search(low, high, item):
    while low <= high - 1:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] < item:
            low = mid + 1
        else:
            high = mid
    if (low == high) & (low > 0):
        low -= 1
        diff_low = item - arr[low],
        diff_high = arr[high] - item,
    if abs(diff_high) < abs(diff_low):
        return arr[high]
    return arr[low]

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
105/5:
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]


def binary_search(low, high, item):
    while low <= high - 1:
        mid = (low + high)//2
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] < item:
            low = mid + 1
        else:
            high = mid
    if (low == high) & (low > 0):
        low -= 1
    diff_low = item - arr[low],
    diff_high = arr[high] - item,
    if abs(diff_high) < abs(diff_low):
        return arr[high]
    return arr[low]

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
107/1:
import math
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

def binary_search(low, high, item):
    while low <= high - 1:
        mid = math.floor((low + high)/2)
        if arr[mid] == item:
            return arr[mid]
        if arr[mid] < item:
            low = mid + 1
        else:
            high = mid
            
    if (low == high) & (low > 0):
        low -= 1
    #print (low, high)
    
    diff_low = item - arr[low]
    diff_high = arr[high] - item
    if abs(diff_high) < abs(diff_low):
        return arr[high]
    return arr[low]
    

for i in range(len(numbers)):
    print(binary_search(0, len(numbers)-1, numbers[i]))
107/2:
import math
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

def binary_search(my_list, key):
    large = len(my_list) -1
    small = 0

    while (small <= large):
        mid = (small + large) // 2 )
        # print small, mid, large, " - ", my_list[mid], "~", key
        if my_list[mid] < key:
            small = mid + 1
        elif my_list[mid] > key:
            large = mid - 1
        else:
            value = my_list[mid]
            lower = mid if value < key else mid-1
            return lower

    return None

for i in range(len(numbers)):
    print(binary_search(arr, numbers[i]))
107/3:
import math
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

def binary_search(my_list, key):
    large = len(my_list) -1
    small = 0

    while (small <= large):
        mid = ((small + large) // 2 )
        # print small, mid, large, " - ", my_list[mid], "~", key
        if my_list[mid] < key:
            small = mid + 1
        elif my_list[mid] > key:
            large = mid - 1
        else:
            value = my_list[mid]
            lower = mid if value < key else mid-1
            return lower

    return None

for i in range(len(numbers)):
    print(binary_search(arr, numbers[i]))
107/4:
import math
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

def binary_search(my_list, key):
    large = len(my_list) -1
    small = 0

    while (small <= large):
        mid = ((small + large) // 2 )
        # print small, mid, large, " - ", my_list[mid], "~", key
        if my_list[mid] < key:
            small = mid + 1
        elif my_list[mid] > key:
            large = mid - 1
        else:
            value = my_list[mid]
            lower = (my_list[mid] < key ? my_list[mid] : my_list[mid - 1]);
            return lower

    return None

for i in range(len(numbers)):
    print(binary_search(arr, numbers[i]))
107/5:
import math
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

def binary_search(my_list, key):
    large = len(my_list) -1
    small = 0

    while (small <= large):
        mid = ((small + large) // 2 )
        # print small, mid, large, " - ", my_list[mid], "~", key
        if my_list[mid] < key:
            small = mid + 1
        elif my_list[mid] > key:
            large = mid - 1
        else:
            value = my_list[mid]
            lower =  my_list[mid] if my_list[mid] < key else my_list[mid - 1]
            return value

    return None

for i in range(len(numbers)):
    print(binary_search(arr, numbers[i]))
107/6:
import math
a, b = [int(x) for x in input().split()]
arr = [int(x) for x in input().split()]
numbers = [int(x) for x in input().split()]

def binary_search(numbers, length, searchnum):
    answer = -1  #If the number is not in the list it will return -1
    start = 0    #Starting point of the list
    end = length - 1     #Ending point of the list
    while start <= end:
        middle = (start + end)//2    #Finding the middle point of the list
        
        if numbers[middle] == searchnum:
            answer = middle
            end = middle - 1
        elif numbers[middle] > searchnum:
            end = middle - 1    
        else:
            start = middle + 1
    
    return answer

for i in range(len(numbers)):
    print(binary_search(arr, len(arr), numbers[i]))
107/7:
n, k = map(int, input().split())
 
a = list(map(int, input().split()))
b = list(map(int, input().split()))
 
for i in b:
    L = 0
    R = n - 1
    while R - L > 1:
        M = (R + L) // 2
        if a[M] < i:
            L = M
        else:
            R = M
    if i - a[L] <= a[R] - i:
        print(a[L])
    else:
        print(a[R])
108/1:
commands = list(map(ыек, text.split()))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': add,
            'EXTRACT': extract,
            'CLEAR': clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

for c in range(len(commands)):
    [command, payload] = c.split()
    print('command', command)
    print('payload', payload)
108/2:
commands = list(map(str, text.split()))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': add,
            'EXTRACT': extract,
            'CLEAR': clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

for c in range(len(commands)):
    [command, payload] = c.split()
    print('command', command)
    print('payload', payload)
108/3:
commands = list(map(str, text.split()))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': add,
            'EXTRACT': extract,
            'CLEAR': clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

for c in range(len(commands)):
    [command, payload] = c.split()
    print('command', command)
    print('payload', payload)
108/4:
commands = list(map(str))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': add,
            'EXTRACT': extract,
            'CLEAR': clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

for c in range(len(commands)):
    [command, payload] = c.split()
    print('command', command)
    print('payload', payload)
108/5:
commands = list(map(str, input().split()))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': add,
            'EXTRACT': extract,
            'CLEAR': clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

for c in range(len(commands)):
    [command, payload] = c.split()
    print('command', command)
    print('payload', payload)
108/6:
commands = list(map(str, input().split()))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

for c in range(len(commands)):
    [command, payload] = c.split()
    print('command', command)
    print('payload', payload)
108/7:
commands = list(map(str, input().split()))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

for c in range(len(commands)):
    [command, payload] = c.split()
    print('command', command)
    print('payload', payload)
108/8:
commands = list(map(str, input().split()))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

for c in range(len(commands)):
    print(c)
#     [command, payload] = c.split()
#     print('command', command)
#     print('payload', payload)
108/9:
commands = list(map(str, input().split('\n')))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

for c in range(len(commands)):
    print(c)
#     [command, payload] = c.split()
#     print('command', command)
#     print('payload', payload)
108/10:
commands = list(map(str, input().split('\n')))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

for c in range(len(commands)):
    print(commands)
#     [command, payload] = c.split()
#     print('command', command)
#     print('payload', payload)
108/11:
commands = list(map(str, input().split('\n')))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

for c in commands:
    print(commands)
#     [command, payload] = c.split()
#     print('command', command)
#     print('payload', payload)
108/12:
commands = list(map(str, input().split('\n')))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

for c in commands:
    print(c)
#     [command, payload] = c.split()
#     print('command', command)
#     print('payload', payload)
108/13:
commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

for c in commands:
    print(c)
#     [command, payload] = c.split()
#     print('command', command)
#     print('payload', payload)
108/14:
commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

for c in commands:
    print(c)
#     [command, payload] = c.split()
#     print('command', command)
#     print('payload', payload)
108/15:
commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

for c in commands:
    print(c)
#     [command, payload] = c.split()
#     print('command', command)
#     print('payload', payload)
108/16:
commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

for c in commands:
    print(c)
#     [command, payload] = c.split()
#     print('command', command)
#     print('payload', payload)
108/17:
commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """
ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
for c in data:
    print(c)
    
#     [command, payload] = c.split()
#     print('command', command)
#     print('payload', payload)
108/18:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """
ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
print(data)
# for c in data:
#     print(c)
    
#     [command, payload] = c.split()
#     print('command', command)
#     print('payload', payload)
108/19:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
print(data)
# for c in data:
#     print(c)
    
#     [command, payload] = c.split()
#     print('command', command)
#     print('payload', payload)
108/20:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
print(data)
for c in data:
    print(c)
    
#     [command, payload] = c.split()
#     print('command', command)
#     print('payload', payload)
108/21:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()

for c in data:
    print(c)
    
#     [command, payload] = c.split()
#     print('command', command)
#     print('payload', payload)
108/22:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
# for c in data:
    [command, payload] = c.split()
    print('command', command)
    print('payload', payload)
108/23:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
# for c in data:
    command, payload = c.split()
    print('command', command)
    print('payload', payload)
108/24:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, payload = c.split()
    print('command', command)
    print('payload', payload)
108/25:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *rest = c.split()
    print('command', command)
    print('rest', v)
108/26:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
         return getattr(self, self.functions[arg])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    print('command', command)
    print('payload', payload)
108/27:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, name, arg):
         return getattr(self, self.functions[name])(arg)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_me(command)
    print('command', command)
    print('payload', payload)
108/28:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg, payload):
         return getattr(self, self.functions[name])(payload)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_me(command)
    print('command', command)
    print('payload', payload)
108/29:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg, payload):
         return getattr(self, self.functions[name])(payload)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_me(command)
    print('command', command)
    print('payload', payload)
108/30:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg, payload):
         return getattr(self, self.functions[name])(payload)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_me(command)
    print('command', command)
    print('payload', payload)
108/31:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg, payload = None):
         return getattr(self, self.functions[name])(payload)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_me(command)
    print('command', command)
    print('payload', payload)
108/32:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg, payload = None):
         return getattr(self, self.functions[arg])(payload)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_me(command)
108/33:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg, payload = None):
        print(arg)
#          return getattr(self, self.functions[arg])(payload)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_me(command)
108/34:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg, payload = None):
        print( self.functions[arg])
#          return getattr(self, self.functions[arg])(payload)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_me(command)
108/35:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg, payload = None):
        print( self.functions[arg]())
#          return getattr(self, self.functions[arg])(payload)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_me(command)
108/36:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.add,
            'EXTRACT': self.extract,
            'CLEAR': self.clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg, payload = None):
        print( self.functions[arg](payload))
#          return getattr(self, self.functions[arg])(payload)

    def add(self, k):
        print(k)

    def extract(self):
        print('extract')

    def clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_me(command)
108/37:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        print(k)

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
108/38:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        print(k)

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/1:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_me(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        print(k)

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/2:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        print(k)

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/3:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.pointer = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(k)
#         current_child is current_size
#         parent is [current_size/2]
        child = self.pointer
        parent = int(child/2)
        while self.pointer > 1 && self.h_list[child] > self.h_list[parent]:
             self.h_list[child], self.h_list[parent] = self.h_list[parent], self.h_list[child]
             self.pointer = parent

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/4:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.pointer = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(k)
#         current_child is current_size
#         parent is [current_size/2]
        child = self.pointer
        parent = int(child/2)
        while self.pointer > 1 and self.h_list[child] > self.h_list[parent]:
             self.h_list[child], self.h_list[parent] = self.h_list[parent], self.h_list[child]
             self.pointer = parent

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/5:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.pointer = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(k)
#         current_child is current_size
#         parent is [current_size/2]
        child = self.pointer
        parent = int(child/2)
        while self.pointer > 1 and self.h_list[child] > self.h_list[parent]:
             self.h_list[child], self.h_list[parent] = self.h_list[parent], self.h_list[child]
             self.pointer = parent

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/6:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.pointer = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(k)
#         current_child is current_size
#         parent is [current_size/2]
        child = self.pointer
        parent = int(child/2)
        while self.pointer > 1 and self.h_list[child] > self.h_list[parent]:
             self.h_list[child], self.h_list[parent] = self.h_list[parent], self.h_list[child]
             self.pointer = parent

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap)
109/7:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.pointer = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(k)
#         current_child is current_size
#         parent is [current_size/2]
        child = self.pointer
        parent = int(child/2)
        while self.pointer > 1 and self.h_list[child] > self.h_list[parent]:
             self.h_list[child], self.h_list[parent] = self.h_list[parent], self.h_list[child]
             self.pointer = parent

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/8:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.pointer = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(k)
#         current_child is current_size
#         parent is [current_size/2]
        child = self.pointer
        parent = int(child/2)
        while self.pointer > 1 and self.h_list[child] > self.h_list[parent]:
            self.h_list[child], self.h_list[parent] = self.h_list[parent], self.h_list[child]
            self.pointer = parent
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/9:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.pointer = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(k)
#         current_child is current_size
#         parent is [current_size/2]
        child = self.pointer
        parent = int(child/2)
        while self.pointer > 1 and self.h_list[child] > self.h_list[parent]:
            self.h_list[child], self.h_list[parent] = self.h_list[parent], self.h_list[child]
            self.pointer = parent
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/10:
"""
Min Heap Implementation in Python
"""
class MinHeap:
    def __init__(self):
        """
        On this implementation the heap list is initialized with a value
        """
        self.heap_list = [0]
        self.current_size = 0
 
    def sift_up(self, i):
        """
        Moves the value up in the tree to maintain the heap property.
        """
        # While the element is not the root or the left element
        while i // 2 > 0:
            # If the element is less than its parent swap the elements
            if self.heap_list[i] < self.heap_list[i // 2]:
                self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i]
            # Move the index to the parent to keep the properties
            i = i // 2
 
    def insert(self, k):
        """
        Inserts a value into the heap
        """
        # Append the element to the heap
        self.heap_list.append(k)
        # Increase the size of the heap.
        self.current_size += 1
        # Move the element to its position from bottom to the top
        self.sift_up(self.current_size)
 
    def sift_down(self, i):
        # if the current node has at least one child
        while (i * 2) <= self.current_size:
            # Get the index of the min child of the current node
            mc = self.min_child(i)
            # Swap the values of the current element is greater than its min child
            if self.heap_list[i] > self.heap_list[mc]:
                self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i]
            i = mc
 
    def min_child(self, i):
        # If the current node has only one child, return the index of the unique child
        if (i * 2)+1 > self.current_size:
            return i * 2
        else:
            # Herein the current node has two children
            # Return the index of the min child according to their values
            if self.heap_list[i*2] < self.heap_list[(i*2)+1]:
                return i * 2
            else:
                return (i * 2) + 1
 
    def delete_min(self):
        # Equal to 1 since the heap list was initialized with a value
        if len(self.heap_list) == 1:
            return 'Empty heap'
 
        # Get root of the heap (The min value of the heap)
        root = self.heap_list[1]
 
        # Move the last value of the heap to the root
        self.heap_list[1] = self.heap_list[self.current_size]
 
        # Pop the last value since a copy was set on the root
        *self.heap_list, _ = self.heap_list
 
        # Decrease the size of the heap
        self.current_size -= 1
 
        # Move down the root (value at index 1) to keep the heap property
        self.sift_down(1)
 
        # Return the min value of the heap
        return root
"""
Driver program
"""
# Same tree as above example.
my_heap = MinHeap()
my_heap.insert(5)
my_heap.insert(6)
my_heap.insert(7)
my_heap.insert(9)
my_heap.insert(13)
my_heap.insert(11)
my_heap.insert(10)

print(my_heap)
109/11:
"""
Min Heap Implementation in Python
"""
class MinHeap:
    def __init__(self):
        """
        On this implementation the heap list is initialized with a value
        """
        self.heap_list = [0]
        self.current_size = 0
 
    def sift_up(self, i):
        """
        Moves the value up in the tree to maintain the heap property.
        """
        # While the element is not the root or the left element
        while i // 2 > 0:
            # If the element is less than its parent swap the elements
            if self.heap_list[i] < self.heap_list[i // 2]:
                self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i]
            # Move the index to the parent to keep the properties
            i = i // 2
 
    def insert(self, k):
        """
        Inserts a value into the heap
        """
        # Append the element to the heap
        self.heap_list.append(k)
        # Increase the size of the heap.
        self.current_size += 1
        # Move the element to its position from bottom to the top
        self.sift_up(self.current_size)
 
    def sift_down(self, i):
        # if the current node has at least one child
        while (i * 2) <= self.current_size:
            # Get the index of the min child of the current node
            mc = self.min_child(i)
            # Swap the values of the current element is greater than its min child
            if self.heap_list[i] > self.heap_list[mc]:
                self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i]
            i = mc
 
    def min_child(self, i):
        # If the current node has only one child, return the index of the unique child
        if (i * 2)+1 > self.current_size:
            return i * 2
        else:
            # Herein the current node has two children
            # Return the index of the min child according to their values
            if self.heap_list[i*2] < self.heap_list[(i*2)+1]:
                return i * 2
            else:
                return (i * 2) + 1
 
    def delete_min(self):
        # Equal to 1 since the heap list was initialized with a value
        if len(self.heap_list) == 1:
            return 'Empty heap'
 
        # Get root of the heap (The min value of the heap)
        root = self.heap_list[1]
 
        # Move the last value of the heap to the root
        self.heap_list[1] = self.heap_list[self.current_size]
 
        # Pop the last value since a copy was set on the root
        *self.heap_list, _ = self.heap_list
 
        # Decrease the size of the heap
        self.current_size -= 1
 
        # Move down the root (value at index 1) to keep the heap property
        self.sift_down(1)
 
        # Return the min value of the heap
        return root
"""
Driver program
"""
# Same tree as above example.
my_heap = MinHeap()
my_heap.insert(5)
my_heap.insert(6)
my_heap.insert(7)
my_heap.insert(9)
my_heap.insert(13)
my_heap.insert(11)
my_heap.insert(10)

print(my_heap.heap_list)
109/12:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.pointer = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(k)
#         current_child is current_size
#         parent is [current_size/2]
        child = self.pointer
        parent = int(child/2)
        while self.pointer > 1 and self.h_list[child] > self.h_list[parent]:
            self.h_list[child], self.h_list[parent] = self.h_list[parent], self.h_list[child]
            self.pointer = parent
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
ADD 7
ADD 555
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/13:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.pointer = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(k)
#         current_child is current_size
#         parent is [current_size/2]
        child = self.pointer
        parent = int(child/2)
        while self.pointer > 1 and self.h_list[child] > self.h_list[parent]:
            self.h_list[child], self.h_list[parent] = self.h_list[parent], self.h_list[child]
            self.pointer = parent
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
ADD 7
ADD 555
ADD 192168814
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/14:
"""
Min Heap Implementation in Python
"""
class MinHeap:
    def __init__(self):
        """
        On this implementation the heap list is initialized with a value
        """
        self.heap_list = [0]
        self.current_size = 0
 
    def sift_up(self, i):
        """
        Moves the value up in the tree to maintain the heap property.
        """
        # While the element is not the root or the left element
        while i // 2 > 0:
            # If the element is less than its parent swap the elements
            if self.heap_list[i] < self.heap_list[i // 2]:
                self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i]
            # Move the index to the parent to keep the properties
            i = i // 2
 
    def insert(self, k):
        """
        Inserts a value into the heap
        """
        # Append the element to the heap
        self.heap_list.append(k)
        # Increase the size of the heap.
        self.current_size += 1
        # Move the element to its position from bottom to the top
        self.sift_up(self.current_size)
 
    def sift_down(self, i):
        # if the current node has at least one child
        while (i * 2) <= self.current_size:
            # Get the index of the min child of the current node
            mc = self.min_child(i)
            # Swap the values of the current element is greater than its min child
            if self.heap_list[i] > self.heap_list[mc]:
                self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i]
            i = mc
 
    def min_child(self, i):
        # If the current node has only one child, return the index of the unique child
        if (i * 2)+1 > self.current_size:
            return i * 2
        else:
            # Herein the current node has two children
            # Return the index of the min child according to their values
            if self.heap_list[i*2] < self.heap_list[(i*2)+1]:
                return i * 2
            else:
                return (i * 2) + 1
 
    def delete_min(self):
        # Equal to 1 since the heap list was initialized with a value
        if len(self.heap_list) == 1:
            return 'Empty heap'
 
        # Get root of the heap (The min value of the heap)
        root = self.heap_list[1]
 
        # Move the last value of the heap to the root
        self.heap_list[1] = self.heap_list[self.current_size]
 
        # Pop the last value since a copy was set on the root
        *self.heap_list, _ = self.heap_list
 
        # Decrease the size of the heap
        self.current_size -= 1
 
        # Move down the root (value at index 1) to keep the heap property
        self.sift_down(1)
 
        # Return the min value of the heap
        return root
"""
Driver program
"""
# Same tree as above example.
my_heap = MinHeap()
my_heap.insert(5)
my_heap.insert(6)
my_heap.insert(7)
my_heap.insert(9)
my_heap.insert(13)
my_heap.insert(11)
my_heap.insert(192168812)

print(my_heap.heap_list)
109/15:
"""
Min Heap Implementation in Python
"""
class MinHeap:
    def __init__(self):
        """
        On this implementation the heap list is initialized with a value
        """
        self.heap_list = [0]
        self.current_size = 0
 
    def sift_up(self, i):
        """
        Moves the value up in the tree to maintain the heap property.
        """
        # While the element is not the root or the left element
        while i // 2 > 0:
            # If the element is less than its parent swap the elements
            if self.heap_list[i] < self.heap_list[i // 2]:
                self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i]
            # Move the index to the parent to keep the properties
            i = i // 2
 
    def insert(self, k):
        """
        Inserts a value into the heap
        """
        # Append the element to the heap
        self.heap_list.append(k)
        # Increase the size of the heap.
        self.current_size += 1
        # Move the element to its position from bottom to the top
        self.sift_up(self.current_size)
 
    def sift_down(self, i):
        # if the current node has at least one child
        while (i * 2) <= self.current_size:
            # Get the index of the min child of the current node
            mc = self.min_child(i)
            # Swap the values of the current element is greater than its min child
            if self.heap_list[i] > self.heap_list[mc]:
                self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i]
            i = mc
 
    def min_child(self, i):
        # If the current node has only one child, return the index of the unique child
        if (i * 2)+1 > self.current_size:
            return i * 2
        else:
            # Herein the current node has two children
            # Return the index of the min child according to their values
            if self.heap_list[i*2] < self.heap_list[(i*2)+1]:
                return i * 2
            else:
                return (i * 2) + 1
 
    def delete_min(self):
        # Equal to 1 since the heap list was initialized with a value
        if len(self.heap_list) == 1:
            return 'Empty heap'
 
        # Get root of the heap (The min value of the heap)
        root = self.heap_list[1]
 
        # Move the last value of the heap to the root
        self.heap_list[1] = self.heap_list[self.current_size]
 
        # Pop the last value since a copy was set on the root
        *self.heap_list, _ = self.heap_list
 
        # Decrease the size of the heap
        self.current_size -= 1
 
        # Move down the root (value at index 1) to keep the heap property
        self.sift_down(1)
 
        # Return the min value of the heap
        return root
"""
Driver program
"""
# Same tree as above example.
my_heap = MinHeap()
my_heap.insert(0)
my_heap.insert(6)
my_heap.insert(7)
my_heap.insert(9)
my_heap.insert(13)
my_heap.insert(11)
my_heap.insert(0)

print(my_heap.heap_list)
109/16:
"""
Min Heap Implementation in Python
"""
class MinHeap:
    def __init__(self):
        """
        On this implementation the heap list is initialized with a value
        """
        self.heap_list = [0]
        self.current_size = 0
 
    def sift_up(self, i):
        """
        Moves the value up in the tree to maintain the heap property.
        """
        # While the element is not the root or the left element
        while i // 2 > 0:
            # If the element is less than its parent swap the elements
            if self.heap_list[i] < self.heap_list[i // 2]:
                self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i]
            # Move the index to the parent to keep the properties
            i = i // 2
 
    def insert(self, k):
        """
        Inserts a value into the heap
        """
        # Append the element to the heap
        self.heap_list.append(k)
        # Increase the size of the heap.
        self.current_size += 1
        # Move the element to its position from bottom to the top
        self.sift_up(self.current_size)
 
    def sift_down(self, i):
        # if the current node has at least one child
        while (i * 2) <= self.current_size:
            # Get the index of the min child of the current node
            mc = self.min_child(i)
            # Swap the values of the current element is greater than its min child
            if self.heap_list[i] > self.heap_list[mc]:
                self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i]
            i = mc
 
    def min_child(self, i):
        # If the current node has only one child, return the index of the unique child
        if (i * 2)+1 > self.current_size:
            return i * 2
        else:
            # Herein the current node has two children
            # Return the index of the min child according to their values
            if self.heap_list[i*2] < self.heap_list[(i*2)+1]:
                return i * 2
            else:
                return (i * 2) + 1
 
    def delete_min(self):
        # Equal to 1 since the heap list was initialized with a value
        if len(self.heap_list) == 1:
            return 'Empty heap'
 
        # Get root of the heap (The min value of the heap)
        root = self.heap_list[1]
 
        # Move the last value of the heap to the root
        self.heap_list[1] = self.heap_list[self.current_size]
 
        # Pop the last value since a copy was set on the root
        *self.heap_list, _ = self.heap_list
 
        # Decrease the size of the heap
        self.current_size -= 1
 
        # Move down the root (value at index 1) to keep the heap property
        self.sift_down(1)
 
        # Return the min value of the heap
        return root
"""
Driver program
"""
# Same tree as above example.
my_heap = MinHeap()
my_heap.insert(0)
my_heap.insert(6)
my_heap.insert(7)
my_heap.insert(9)
my_heap.insert(13)
my_heap.insert(11)
my_heap.insert(0)

print(my_heap.heap_list)
109/17:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.pointer = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(k)
#         current_child is current_size
#         parent is [current_size/2]
        child = self.pointer
        parent = int(child/2)
        while self.pointer > 1 and self.h_list[child] > self.h_list[parent]:
            self.h_list[child], self.h_list[parent] = self.h_list[parent], self.h_list[child]
            self.pointer = parent
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
ADD 7
ADD 555
ADD 192168812
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/18:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.pointer = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(k)
#         current_child is current_size
#         parent is [current_size/2]
        child = self.pointer
        parent = self.pointer // 2
        while self.pointer > 1 and self.h_list[child] > self.h_list[parent]:
            self.h_list[child], self.h_list[parent] = self.h_list[parent], self.h_list[child]
            self.pointer = parent
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
ADD 7
ADD 555
ADD 192168812
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/19:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(k)
#         current_child is current_size
#         parent is [current_size/2]
        self.current_size += 1
        i = current_size
        while i > 1 and self.h_list[i] > self.h_list[i//2]:
            self.h_list[i], self.h_list[i//2] = self.h_list[i//2], self.h_list[i]
            i = i//2
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
ADD 7
ADD 555
ADD 192168812
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/20:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(k)
#         current_child is current_size
#         parent is [current_size/2]
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i//2]:
            self.h_list[i], self.h_list[i//2] = self.h_list[i//2], self.h_list[i]
            i = i//2
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
ADD 7
ADD 555
ADD 192168812
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/21:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(k)
#         current_child is current_size
#         parent is [current_size/2]
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i//2
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
ADD 7
ADD 555
ADD 192168813
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/22:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [1921688129]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(k)
#         current_child is current_size
#         parent is [current_size/2]
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
ADD 7
ADD 555
ADD 192168813
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/23:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [1921688129]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k)
#         current_child is current_size
#         parent is [current_size/2]
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
ADD 7
ADD 555
ADD 192168813
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/24:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [1921688129]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
#         current_child is current_size
#         parent is [current_size/2]
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
ADD 7
ADD 555
ADD 192168813
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/25:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [1921688129]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
#         current_child is current_size
#         parent is [current_size/2]
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
ADD 7
ADD 555
ADD 192168813
ADD 192168813
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/26:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [1921688129]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
#         current_child is current_size
#         parent is [current_size/2]
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
ADD 7
ADD 555
ADD 192168813
ADD 192168813
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/27:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = []
        self.current_size = 1
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
#         current_child is current_size
#         parent is [current_size/2]
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
ADD 7
ADD 555
ADD 192168813
ADD 192168813
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/28:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = ['1']
        self.current_size = 1
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
#         current_child is current_size
#         parent is [current_size/2]
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
ADD 7
ADD 555
ADD 192168813
ADD 192168813
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/29:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = []
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
#         current_child is current_size
#         parent is [current_size/2]
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
ADD 7
ADD 555
ADD 192168813
ADD 192168813
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/30:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [0]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
#         current_child is current_size
#         parent is [current_size/2]
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
ADD 7
ADD 555
ADD 192168813
ADD 192168813
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/31:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
#         current_child is current_size
#         parent is [current_size/2]
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
                

    def __extract(self):
        print('extract')

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
ADD 7
ADD 555
ADD 192168813
ADD 192168813
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/32:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h__list) == 1:
            return 'CANNOT'
        root = self.h__list[1]
        self.current_size -= 1
        
        i = 1
        while i <= self.current_size:
            #index of max Node max child             
            mc_index = self.max_child_index(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
                i = mc
        return root

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/33:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while i <= self.current_size:
            #index of max Node max child             
            mc_index = self.max_child_index(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
                i = mc
        return root

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/34:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while i <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
                i = mc
        return root

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/35:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while i <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
                i = mc
        return root

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        print(my_heap.call_without_payload(command))
    else:
        print(my_heap.call_with_payload(command, payload[0]))
# print(my_heap.h_list)
109/36:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while i <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
                i = mc
        return root

    def __clear(self):
        print('clear')
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        print(my_heap.call_without_payload(command))
    else:
        my_heap.call_with_payload(command, payload[0])
# print(my_heap.h_list)
109/37:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while i <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
                i = mc
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        print(my_heap.call_without_payload(command))
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/38:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while i <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
                i = mc
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        print(my_heap.call_without_payload(command))
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/39:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while i <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
                i = mc
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        print(my_heap.call_without_payload(command))
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/40:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while i <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            print('mc_index', mc_index)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
                i = mc
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        print(my_heap.call_without_payload(command))
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/41:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while i*2 <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            print('mc_index', mc_index)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
                i = mc
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        print(my_heap.call_without_payload(command))
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/42:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while (i - 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            print('mc_index', mc_index)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
                i = mc
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        print(my_heap.call_without_payload(command))
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/43:
"""
Min Heap Implementation in Python
"""
class MinHeap:
    def __init__(self):
        """
        On this implementation the heap list is initialized with a value
        """
        self.heap_list = [0]
        self.current_size = 0
 
    def sift_up(self, i):
        """
        Moves the value up in the tree to maintain the heap property.
        """
        # While the element is not the root or the left element
        while i // 2 > 0:
            # If the element is less than its parent swap the elements
            if self.heap_list[i] < self.heap_list[i // 2]:
                self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i]
            # Move the index to the parent to keep the properties
            i = i // 2
 
    def insert(self, k):
        """
        Inserts a value into the heap
        """
        # Append the element to the heap
        self.heap_list.append(k)
        # Increase the size of the heap.
        self.current_size += 1
        # Move the element to its position from bottom to the top
        self.sift_up(self.current_size)
 
    def sift_down(self, i):
        # if the current node has at least one child
        while (i * 2) <= self.current_size:
            # Get the index of the min child of the current node
            mc = self.min_child(i)
            # Swap the values of the current element is greater than its min child
            if self.heap_list[i] > self.heap_list[mc]:
                self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i]
            i = mc
 
    def min_child(self, i):
        # If the current node has only one child, return the index of the unique child
        if (i * 2)+1 > self.current_size:
            return i * 2
        else:
            # Herein the current node has two children
            # Return the index of the min child according to their values
            if self.heap_list[i*2] < self.heap_list[(i*2)+1]:
                return i * 2
            else:
                return (i * 2) + 1
 
    def delete_min(self):
        # Equal to 1 since the heap list was initialized with a value
        if len(self.heap_list) == 1:
            return 'Empty heap'
 
        # Get root of the heap (The min value of the heap)
        root = self.heap_list[1]
 
        # Move the last value of the heap to the root
        self.heap_list[1] = self.heap_list[self.current_size]
 
        # Pop the last value since a copy was set on the root
        *self.heap_list, _ = self.heap_list
 
        # Decrease the size of the heap
        self.current_size -= 1
 
        # Move down the root (value at index 1) to keep the heap property
        self.sift_down(1)
 
        # Return the min value of the heap
        return root
"""
Driver program
"""
# Same tree as above example.
my_heap = MinHeap()
my_heap.insert(0)
my_heap.insert(6)
my_heap.delete_min()
my_heap.insert(9)
my_heap.insert(13)
my_heap.insert(11)
my_heap.insert(0)

print(my_heap.heap_list)
109/44:
"""
Min Heap Implementation in Python
"""
class MinHeap:
    def __init__(self):
        """
        On this implementation the heap list is initialized with a value
        """
        self.heap_list = [0]
        self.current_size = 0
 
    def sift_up(self, i):
        """
        Moves the value up in the tree to maintain the heap property.
        """
        # While the element is not the root or the left element
        while i // 2 > 0:
            # If the element is less than its parent swap the elements
            if self.heap_list[i] < self.heap_list[i // 2]:
                self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i]
            # Move the index to the parent to keep the properties
            i = i // 2
 
    def insert(self, k):
        """
        Inserts a value into the heap
        """
        # Append the element to the heap
        self.heap_list.append(k)
        # Increase the size of the heap.
        self.current_size += 1
        # Move the element to its position from bottom to the top
        self.sift_up(self.current_size)
 
    def sift_down(self, i):
        # if the current node has at least one child
        while (i * 2) <= self.current_size:
            # Get the index of the min child of the current node
            mc = self.min_child(i)
            # Swap the values of the current element is greater than its min child
            if self.heap_list[i] > self.heap_list[mc]:
                self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i]
            i = mc
 
    def min_child(self, i):
        # If the current node has only one child, return the index of the unique child
        if (i * 2)+1 > self.current_size:
            return i * 2
        else:
            # Herein the current node has two children
            # Return the index of the min child according to their values
            if self.heap_list[i*2] < self.heap_list[(i*2)+1]:
                return i * 2
            else:
                return (i * 2) + 1
 
    def delete_min(self):
        # Equal to 1 since the heap list was initialized with a value
        if len(self.heap_list) == 1:
            return 'Empty heap'
 
        # Get root of the heap (The min value of the heap)
        root = self.heap_list[1]
 
        # Move the last value of the heap to the root
        self.heap_list[1] = self.heap_list[self.current_size]
 
        # Pop the last value since a copy was set on the root
        *self.heap_list, _ = self.heap_list
 
        # Decrease the size of the heap
        self.current_size -= 1
 
        # Move down the root (value at index 1) to keep the heap property
        self.sift_down(1)
 
        # Return the min value of the heap
        return root
"""
Driver program
"""
# Same tree as above example.
my_heap = MinHeap()
my_heap.insert(0)
my_heap.insert(6)
my_heap.delete_min()
my_heap.insert(9)
my_heap.insert(13)
my_heap.insert(11)
my_heap.insert(0)

print(my_heap.heap_list)
109/45:
"""
Min Heap Implementation in Python
"""
class MinHeap:
    def __init__(self):
        """
        On this implementation the heap list is initialized with a value
        """
        self.heap_list = [0]
        self.current_size = 0
 
    def sift_up(self, i):
        """
        Moves the value up in the tree to maintain the heap property.
        """
        # While the element is not the root or the left element
        while i // 2 > 0:
            # If the element is less than its parent swap the elements
            if self.heap_list[i] < self.heap_list[i // 2]:
                self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i]
            # Move the index to the parent to keep the properties
            i = i // 2
 
    def insert(self, k):
        """
        Inserts a value into the heap
        """
        # Append the element to the heap
        self.heap_list.append(k)
        # Increase the size of the heap.
        self.current_size += 1
        # Move the element to its position from bottom to the top
        self.sift_up(self.current_size)
 
    def sift_down(self, i):
        # if the current node has at least one child
        while (i * 2) <= self.current_size:
            # Get the index of the min child of the current node
            mc = self.min_child(i)
            # Swap the values of the current element is greater than its min child
            if self.heap_list[i] > self.heap_list[mc]:
                self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i]
            i = mc
 
    def min_child(self, i):
        # If the current node has only one child, return the index of the unique child
        if (i * 2)+1 > self.current_size:
            return i * 2
        else:
            # Herein the current node has two children
            # Return the index of the min child according to their values
            if self.heap_list[i*2] < self.heap_list[(i*2)+1]:
                return i * 2
            else:
                return (i * 2) + 1
 
    def delete_min(self):
        # Equal to 1 since the heap list was initialized with a value
        if len(self.heap_list) == 1:
            return 'Empty heap'
 
        # Get root of the heap (The min value of the heap)
        root = self.heap_list[1]
 
        # Move the last value of the heap to the root
        self.heap_list[1] = self.heap_list[self.current_size]
 
        # Pop the last value since a copy was set on the root
        *self.heap_list, _ = self.heap_list
 
        # Decrease the size of the heap
        self.current_size -= 1
 
        # Move down the root (value at index 1) to keep the heap property
        self.sift_down(1)
 
        # Return the min value of the heap
        return root
"""
Driver program
"""
# Same tree as above example.
my_heap = MinHeap()
my_heap.insert(1)
my_heap.insert(6)
my_heap.delete_min()
my_heap.insert(9)
my_heap.insert(13)
my_heap.insert(11)
my_heap.insert(2)

print(my_heap.heap_list)
109/46:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            print('mc_index', mc_index)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
                i = mc
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        print(my_heap.call_without_payload(command))
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/47:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            print('mc_index', mc_index)
            print('self.h_list[i]', self.h_list[i])
            print('self.h_list[mc_index]', self.h_list[mc_index])
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
                i = mc
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        print(my_heap.call_without_payload(command))
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/48:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            print('mc_index', mc_index)
            print('self.h_list[i]', self.h_list[i])
            print('self.h_list[mc_index]', self.h_list[mc_index])
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
                i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        print(my_heap.call_without_payload(command))
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/49:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            print('mc_index', mc_index)
            print('self.h_list[i]', self.h_list[i])
            print('self.h_list[mc_index]', self.h_list[mc_index])
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
                i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        print(my_heap.call_without_payload(command))
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/50:
"""
Min Heap Implementation in Python
"""
class MinHeap:
    def __init__(self):
        """
        On this implementation the heap list is initialized with a value
        """
        self.heap_list = [0]
        self.current_size = 0
 
    def sift_up(self, i):
        """
        Moves the value up in the tree to maintain the heap property.
        """
        # While the element is not the root or the left element
        while i // 2 > 0:
            # If the element is less than its parent swap the elements
            if self.heap_list[i] < self.heap_list[i // 2]:
                self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i]
            # Move the index to the parent to keep the properties
            i = i // 2
 
    def insert(self, k):
        """
        Inserts a value into the heap
        """
        # Append the element to the heap
        self.heap_list.append(k)
        # Increase the size of the heap.
        self.current_size += 1
        # Move the element to its position from bottom to the top
        self.sift_up(self.current_size)
 
    def sift_down(self, i):
        # if the current node has at least one child
        while (i * 2) <= self.current_size:
            # Get the index of the min child of the current node
            mc = self.min_child(i)
            # Swap the values of the current element is greater than its min child
            if self.heap_list[i] > self.heap_list[mc]:
                self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i]
            i = mc
 
    def min_child(self, i):
        # If the current node has only one child, return the index of the unique child
        if (i * 2)+1 > self.current_size:
            return i * 2
        else:
            # Herein the current node has two children
            # Return the index of the min child according to their values
            if self.heap_list[i*2] < self.heap_list[(i*2)+1]:
                return i * 2
            else:
                return (i * 2) + 1
 
    def delete_min(self):
        # Equal to 1 since the heap list was initialized with a value
        if len(self.heap_list) == 1:
            return 'Empty heap'
 
        # Get root of the heap (The min value of the heap)
        root = self.heap_list[1]
 
        # Move the last value of the heap to the root
        self.heap_list[1] = self.heap_list[self.current_size]
 
        # Pop the last value since a copy was set on the root
        *self.heap_list, _ = self.heap_list
 
        # Decrease the size of the heap
        self.current_size -= 1
 
        # Move down the root (value at index 1) to keep the heap property
        self.sift_down(1)
 
        # Return the min value of the heap
        return root
"""
Driver program
"""
# Same tree as above example.
my_heap = MinHeap()
my_heap.insert(1)
my_heap.insert(6)
my_heap.insert(9)
my_heap.delete_min()

print(my_heap.heap_list)
109/51:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            print('mc_index', mc_index)
            print('self.h_list[i]', self.h_list[i])
            print('self.h_list[mc_index]', self.h_list[mc_index])
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        print(my_heap.call_without_payload(command))
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/52:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        print(my_heap.call_without_payload(command))
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/53:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
print(my_heap.h_list)
109/54:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
# print(my_heap.h_list)
109/55:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.current_size -= 1
        
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        print(my_heap.h_list)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
# print(my_heap.h_list)
109/56:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        self.h_list[1], self.h_list[current_size] = self.h_list[current_size], self.h_list[1]
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        print(my_heap.h_list)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
# print(my_heap.h_list)
109/57:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        print(my_heap.h_list)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
# print(my_heap.h_list)
109/58:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.heap_list, _ = self.heap_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        print(my_heap.h_list)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
# print(my_heap.h_list)
109/59:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        print(my_heap.h_list)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
# print(my_heap.h_list)
109/60:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        print(my_heap.h_list)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
# print(my_heap.h_list)
109/61:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
# print(my_heap.h_list)
109/62:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
# print(my_heap.h_list)
109/63:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        print(my_heap.call_without_payload(command))
    else:
        my_heap.call_with_payload(command, payload[0])
109/64:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        print(my_heap.call_without_payload(command))
    else:
        my_heap.call_with_payload(command, payload[0])
109/65:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/66:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/67:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/68:
commands = list(map(str, input().splitlines()))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

for c in commands:
    command, *payload = c.split()
    if len(payload) == 0:
        res = my_heap.call_without_payload(command)
        if res !== None:
            print(res)
    else:
        my_heap.call_with_payload(command, payload[0])
109/69:
commands = list(map(str, input().splitlines()))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

for c in commands:
    command, *payload = c.split()
    if len(payload) == 0:
        res = my_heap.call_without_payload(command)
        if res != None:
            print(res)
    else:
        my_heap.call_with_payload(command, payload[0])
109/70:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        res = my_heap.call_without_payload(command)
        if res != None:
            print(res)
    else:
        my_heap.call_with_payload(command, payload[0])
109/71:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        res = my_heap.call_without_payload(command)
        if res != None:
            print(res)
    else:
        my_heap.call_with_payload(command, payload[0])
109/72:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        res = my_heap.call_without_payload(command)
        if res != None:
            print(res)
    else:
        my_heap.call_with_payload(command, payload[0])
109/73:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        res = my_heap.call_without_payload(command)
        if res != None:
            print(res)
    else:
        my_heap.call_with_payload(command, payload[0])
109/74:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command))
    else:
        my_heap.call_with_payload(command, payload[0])
109/75:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/76:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()



from sys import stdin
text = stdin.read()
commands = list(map(str, text.splitlines()))

for c in commands:
    command, *payload = c.split()
    if len(payload) == 0:
        res = my_heap.call_without_payload(command)
        if res != None:
            print(res)
    else:
        my_heap.call_with_payload(command, payload[0])
109/77:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD -555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/78:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/79:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD -555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/80:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        print('self.h_list', self.h_list)
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD -125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD -555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/81:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        print('self.h_list', self.h_list)
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD -192168812
ADD -125
ADD -321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD -555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/82:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        print('self.h_list', self.h_list)
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD -192168812
ADD 0
ADD 0
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD -555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/83:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        print('self.h_list', self.h_list)
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 0
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/84:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        print('self.h_list', self.h_list)
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/85:
# commands = list(map(str, input().splitlines() ))

class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        print('self.h_list', self.h_list)
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
ADD 1
ADD 1
ADD 2
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/86:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        print('self.h_list', self.h_list)
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
ADD 1
ADD 1
ADD 2
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/87:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        print('self.h_list', self.h_list)
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list = [None]
        *self.h_list, _ = self.h_list
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/88:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        print('self.h_list', self.h_list)
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/89:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/90:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/91:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD -192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/92:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/93:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD -1
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/94:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD -1
ADD -1
ADD -1
ADD -1
ADD -1
ADD -2
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/95:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD -1
ADD -1
ADD -1
ADD -1
ADD -1
ADD -2
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/96:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD -1
CLEAR
ADD -1
ADD -1
ADD -1
ADD -1
ADD -2
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/97:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """
CLEAR
ADD -1
ADD -1
ADD -1
ADD -1
ADD -2
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/98:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """CLEAR
ADD -1
ADD -1
ADD -1
ADD -1
ADD -2
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/99:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """CLEAR
ADD -1
ADD -1
ADD -1
ADD -1
ADD -2
CLEAR
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/100:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """CLEAR
ADD -1
ADD 2
ADD -1
ADD -1
ADD -2
CLEAR
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/101:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """CLEAR
ADD -1
ADD 2
ADD -1
ADD -1
ADD -2
CLEAR
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/102:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """CLEAR
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/103:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """CLEAR
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/104:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 7
ADD 555
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/105:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 7
ADD 7
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/106:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD -1
ADD 0
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/107:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD -1
ADD 0
ADD 0
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/108:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD -1
ADD 0
ADD -1
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/109:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD -1
ADD -1
ADD -1
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/110:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
ADD -1
ADD -1
ADD -1
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/111:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
ADD -1
ADD 0
ADD -1
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/112:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
ADD -1
ADD -1
ADD -1
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
109/113:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        *self.h_list, _ = self.h_list
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
ADD -1
ADD 0

ADD -1
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/1:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
ADD -1
ADD 0

ADD -1
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/2:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
ADD -1
ADD 1
ADD -1
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/3:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/4:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
ADD -1
ADD 0

ADD -1
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/5:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
ADD -1
ADD 0

ADD -1
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/6:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
ADD -1
ADD 0

ADD -1
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/7:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
ADD -1
ADD 0
ADD -1
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/8:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/9:
"""
Min Heap Implementation in Python
"""
class MinHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.insert,
            'EXTRACT': self.delete_min,
            'CLEAR': self.__clear,
        }
        """
        On this implementation the heap list is initialized with a value
        """
        self.heap_list = [0]
        self.current_size = 0
 
    def sift_up(self, i):
        """
        Moves the value up in the tree to maintain the heap property.
        """
        # While the element is not the root or the left element
        while i // 2 > 0:
            # If the element is less than its parent swap the elements
            if self.heap_list[i] > self.heap_list[i // 2]:
                self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i]
            # Move the index to the parent to keep the properties
            i = i // 2
 
    def insert(self, k):
        """
        Inserts a value into the heap
        """
        # Append the element to the heap
        self.heap_list.append(int(k))
        # Increase the size of the heap.
        self.current_size += 1
        # Move the element to its position from bottom to the top
        self.sift_up(self.current_size)
 
    def sift_down(self, i):
        # if the current node has at least one child
        while (i * 2) <= self.current_size:
            # Get the index of the min child of the current node
            mc = self.min_child(i)
            # Swap the values of the current element is greater than its min child
            if self.heap_list[i] < self.heap_list[mc]:
                self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i]
            i = mc
 
    def min_child(self, i):
        # If the current node has only one child, return the index of the unique child
        if (i * 2)+1 > self.current_size:
            return i * 2
        else:
            # Herein the current node has two children
            # Return the index of the min child according to their values
            if self.heap_list[i*2] > self.heap_list[(i*2)+1]:
                return i * 2
            else:
                return (i * 2) + 1
 
    def delete_min(self):
        # Equal to 1 since the heap list was initialized with a value
        if len(self.heap_list) == 1:
            return 'Empty heap'
 
        # Get root of the heap (The min value of the heap)
        root = self.heap_list[1]
 
        # Move the last value of the heap to the root
        self.heap_list[1] = self.heap_list[self.current_size]
 
        # Pop the last value since a copy was set on the root
        *self.heap_list, _ = self.heap_list
 
        # Decrease the size of the heap
        self.current_size -= 1
 
        # Move down the root (value at index 1) to keep the heap property
        self.sift_down(1)
 
        # Return the min value of the heap
        return root
    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
"""
Driver program
"""
# Same tree as above example.
my_heap = MinHeap()
data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/10:
"""
Min Heap Implementation in Python
"""
class MinHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.insert,
            'EXTRACT': self.delete_min,
            'CLEAR': self.__clear,
        }
        """
        On this implementation the heap list is initialized with a value
        """
        self.heap_list = [0]
        self.current_size = 0

    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
 
    def sift_up(self, i):
        """
        Moves the value up in the tree to maintain the heap property.
        """
        # While the element is not the root or the left element
        while i // 2 > 0:
            # If the element is less than its parent swap the elements
            if self.heap_list[i] > self.heap_list[i // 2]:
                self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i]
            # Move the index to the parent to keep the properties
            i = i // 2
 
    def insert(self, k):
        """
        Inserts a value into the heap
        """
        # Append the element to the heap
        self.heap_list.append(int(k))
        # Increase the size of the heap.
        self.current_size += 1
        # Move the element to its position from bottom to the top
        self.sift_up(self.current_size)
 
    def sift_down(self, i):
        # if the current node has at least one child
        while (i * 2) <= self.current_size:
            # Get the index of the min child of the current node
            mc = self.min_child(i)
            # Swap the values of the current element is greater than its min child
            if self.heap_list[i] < self.heap_list[mc]:
                self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i]
            i = mc
 
    def min_child(self, i):
        # If the current node has only one child, return the index of the unique child
        if (i * 2)+1 > self.current_size:
            return i * 2
        else:
            # Herein the current node has two children
            # Return the index of the min child according to their values
            if self.heap_list[i*2] > self.heap_list[(i*2)+1]:
                return i * 2
            else:
                return (i * 2) + 1
 
    def delete_min(self):
        # Equal to 1 since the heap list was initialized with a value
        if len(self.heap_list) == 1:
            return 'Empty heap'
 
        # Get root of the heap (The min value of the heap)
        root = self.heap_list[1]
 
        # Move the last value of the heap to the root
        self.heap_list[1] = self.heap_list[self.current_size]
 
        # Pop the last value since a copy was set on the root
        *self.heap_list, _ = self.heap_list
 
        # Decrease the size of the heap
        self.current_size -= 1
 
        # Move down the root (value at index 1) to keep the heap property
        self.sift_down(1)
 
        # Return the min value of the heap
        return root
    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
"""
Driver program
"""
# Same tree as above example.
my_heap = MinHeap()
data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/11:
"""
Min Heap Implementation in Python
"""
class MinHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.insert,
            'EXTRACT': self.delete_min,
            'CLEAR': self.__clear,
        }
        """
        On this implementation the heap list is initialized with a value
        """
        self.heap_list = [0]
        self.current_size = 0

    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
 
    def sift_up(self, i):
        """
        Moves the value up in the tree to maintain the heap property.
        """
        # While the element is not the root or the left element
        while i // 2 > 0:
            # If the element is less than its parent swap the elements
            if self.heap_list[i] > self.heap_list[i // 2]:
                self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i]
            # Move the index to the parent to keep the properties
            i = i // 2
 
    def insert(self, k):
        """
        Inserts a value into the heap
        """
        # Append the element to the heap
        self.heap_list.append(int(k))
        # Increase the size of the heap.
        self.current_size += 1
        # Move the element to its position from bottom to the top
        self.sift_up(self.current_size)
 
    def sift_down(self, i):
        # if the current node has at least one child
        while (i * 2) <= self.current_size:
            # Get the index of the min child of the current node
            mc = self.min_child(i)
            # Swap the values of the current element is greater than its min child
            if self.heap_list[i] < self.heap_list[mc]:
                self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i]
            i = mc
 
    def min_child(self, i):
        # If the current node has only one child, return the index of the unique child
        if (i * 2)+1 > self.current_size:
            return i * 2
        else:
            # Herein the current node has two children
            # Return the index of the min child according to their values
            if self.heap_list[i*2] > self.heap_list[(i*2)+1]:
                return i * 2
            else:
                return (i * 2) + 1
 
    def delete_min(self):
        # Equal to 1 since the heap list was initialized with a value
        if len(self.heap_list) == 1:
            return 'Empty heap'
 
        # Get root of the heap (The min value of the heap)
        root = self.heap_list[1]
 
        # Move the last value of the heap to the root
        self.heap_list[1] = self.heap_list[self.current_size]
 
        # Pop the last value since a copy was set on the root
        *self.heap_list, _ = self.heap_list
 
        # Decrease the size of the heap
        self.current_size -= 1
 
        # Move down the root (value at index 1) to keep the heap property
        self.sift_down(1)
 
        # Return the min value of the heap
        return root
    def __clear(self):
        self.heap_list.clear()
        self.heap_list.append(None)
        self.current_size = 0
"""
Driver program
"""
# Same tree as above example.
my_heap = MinHeap()
data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/12:
"""
Min Heap Implementation in Python
"""
class MinHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.insert,
            'EXTRACT': self.delete_min,
            'CLEAR': self.__clear,
        }
        """
        On this implementation the heap list is initialized with a value
        """
        self.heap_list = [0]
        self.current_size = 0

    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
 
    def sift_up(self, i):
        """
        Moves the value up in the tree to maintain the heap property.
        """
        # While the element is not the root or the left element
        while i // 2 > 0:
            # If the element is less than its parent swap the elements
            if self.heap_list[i] > self.heap_list[i // 2]:
                self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i]
            # Move the index to the parent to keep the properties
            i = i // 2
 
    def insert(self, k):
        """
        Inserts a value into the heap
        """
        # Append the element to the heap
        self.heap_list.append(int(k))
        # Increase the size of the heap.
        self.current_size += 1
        # Move the element to its position from bottom to the top
        self.sift_up(self.current_size)
 
    def sift_down(self, i):
        # if the current node has at least one child
        while (i * 2) <= self.current_size:
            # Get the index of the min child of the current node
            mc = self.min_child(i)
            # Swap the values of the current element is greater than its min child
            if self.heap_list[i] < self.heap_list[mc]:
                self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i]
            i = mc
 
    def min_child(self, i):
        # If the current node has only one child, return the index of the unique child
        if (i * 2)+1 > self.current_size:
            return i * 2
        else:
            # Herein the current node has two children
            # Return the index of the min child according to their values
            if self.heap_list[i*2] > self.heap_list[(i*2)+1]:
                return i * 2
            else:
                return (i * 2) + 1
 
    def delete_min(self):
        # Equal to 1 since the heap list was initialized with a value
        if len(self.heap_list) == 1:
            return 'Empty heap'
 
        # Get root of the heap (The min value of the heap)
        root = self.heap_list[1]
 
        # Move the last value of the heap to the root
        self.heap_list[1] = self.heap_list[self.current_size]
 
        # Pop the last value since a copy was set on the root
        *self.heap_list, _ = self.heap_list
 
        # Decrease the size of the heap
        self.current_size -= 1
 
        # Move down the root (value at index 1) to keep the heap property
        self.sift_down(1)
 
        # Return the min value of the heap
        return root
    def __clear(self):
        self.heap_list.clear()
        self.heap_list.append(None)
        self.current_size = 0
"""
Driver program
"""
# Same tree as above example.
my_heap = MinHeap()
data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/13:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/14:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/15:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i - 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/16:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i - 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/17:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/18:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
ADD 555
ADD 555
ADD 555
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/19:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
ADD 555
ADD 555
ADD 555
ADD 555
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/20:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 555
ADD 555
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
110/21:
import sys
  
class MaxHeap:
  
    def __init__(self, maxsize):
          
        self.maxsize = maxsize
        self.size = 0
        self.Heap = [0] * (self.maxsize + 1)
        self.Heap[0] = sys.maxsize
        self.FRONT = 1
  
    # Function to return the position of
    # parent for the node currently
    # at pos
    def parent(self, pos):
          
        return pos // 2
  
    # Function to return the position of
    # the left child for the node currently
    # at pos
    def leftChild(self, pos):
          
        return 2 * pos
  
    # Function to return the position of
    # the right child for the node currently
    # at pos
    def rightChild(self, pos):
          
        return (2 * pos) + 1
  
    # Function that returns true if the passed
    # node is a leaf node
    def isLeaf(self, pos):
          
        if pos >= (self.size//2) and pos <= self.size:
            return True
        return False
  
    # Function to swap two nodes of the heap
    def swap(self, fpos, spos):
          
        self.Heap[fpos], self.Heap[spos] = (self.Heap[spos], 
                                            self.Heap[fpos])
  
    # Function to heapify the node at pos
    def maxHeapify(self, pos):
  
        # If the node is a non-leaf node and smaller
        # than any of its child
        if not self.isLeaf(pos):
            if (self.Heap[pos] < self.Heap[self.leftChild(pos)] or
                self.Heap[pos] < self.Heap[self.rightChild(pos)]):
  
                # Swap with the left child and heapify
                # the left child
                if (self.Heap[self.leftChild(pos)] > 
                    self.Heap[self.rightChild(pos)]):
                    self.swap(pos, self.leftChild(pos))
                    self.maxHeapify(self.leftChild(pos))
  
                # Swap with the right child and heapify
                # the right child
                else:
                    self.swap(pos, self.rightChild(pos))
                    self.maxHeapify(self.rightChild(pos))
  
    # Function to insert a node into the heap
    def insert(self, element):
          
        if self.size >= self.maxsize:
            return
        self.size += 1
        self.Heap[self.size] = element
  
        current = self.size
  
        while (self.Heap[current] > 
               self.Heap[self.parent(current)]):
            self.swap(current, self.parent(current))
            current = self.parent(current)
  
    # Function to print the contents of the heap
    def Print(self):
          
        for i in range(1, (self.size // 2) + 1):
            print(" PARENT : " + str(self.Heap[i]) + 
                  " LEFT CHILD : " + str(self.Heap[2 * i]) +
                  " RIGHT CHILD : " + str(self.Heap[2 * i + 1]))
  
    # Function to remove and return the maximum
    # element from the heap
    def extractMax(self):
  
        popped = self.Heap[self.FRONT]
        self.Heap[self.FRONT] = self.Heap[self.size]
        self.size -= 1
        self.maxHeapify(self.FRONT)
          
        return popped
  
# Driver Code
if __name__ == "__main__":
      
    print('The maxHeap is ')
      
    maxHeap = MaxHeap(15)
    maxHeap.insert(5)
    maxHeap.insert(3)
    maxHeap.insert(17)
    maxHeap.insert(10)
    maxHeap.insert(84)
    maxHeap.insert(19)
    maxHeap.insert(6)
    maxHeap.insert(22)
    maxHeap.insert(9)
  
    maxHeap.Print()
      
    print("The Max val is " + str(maxHeap.extractMax()))
111/1:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        print(self.h_list)
        if len(self.h_list) == 1:
#             print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
#         print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 555
ADD 555
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/2:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        print(self.h_list)
        if len(self.h_list) == 1:
#             print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
#         print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 555
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/3:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        print(self.h_list)
        if len(self.h_list) == 1:
#             print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
#         print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/4:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        print(self.h_list)
        if len(self.h_list) == 1:
#             print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
#         self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
#         print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/5:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        print(self.h_list)
        if len(self.h_list) == 1:
#             print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
#         self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
#         print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/6:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
        print(self.h_list)
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/7:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
              
    def __extract(self):
#         print(self.h_list)
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/8: [1, 2, 3].pop()
111/9:
ls = [1, 2, 3]
ls.pop()
111/10:
ls = [1, 2, 3]
ls.pop()
111/11:
ls = [1, 2, 3]
ls.pop()
print(ls)
111/12:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        if lc_index >= self.current_size:
            return;
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
            
    def __extract(self):
#         print(self.h_list)
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
         # Pop the last value since a copy was set on the root
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/13:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        if lc_index >= self.current_size:
            return;
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
            
    def __extract(self):
#         print(self.h_list)
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
                i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/14:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        if lc_index >= self.current_size:
            return;
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
            
    def __extract(self):
#         print(self.h_list)
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/15:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
            
    def __extract(self):
#         print(self.h_list)
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/16:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
            
    def __extract(self):
#         print(self.h_list)
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) <= self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(self.h_list)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/17:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
            
    def __extract(self):
#         print(self.h_list)
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) < self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            print('self.h_list[i]', self.h_list[i])
            print('self.h_list[mc_index]', self.h_list[mc_index])
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/18:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        if lc_index <= self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
            
    def __extract(self):
        print(self.h_list)
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) < self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            print('self.h_list[i]', self.h_list[i])
            print('self.h_list[mc_index]', self.h_list[mc_index])
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/19:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        if lc_index <= self.current_size:
            return lc_index
        print('self.h_list[lc_index]', self.h_list[lc_index])
        print('self.h_list[rc_index]', self.h_list[rc_index])
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
            
    def __extract(self):
        print(self.h_list)
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) < self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/20:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        if lc_index <= self.current_size:
            return lc_index
        print('self.h_list[lc_index]', self.h_list[lc_index])
        print('self.h_list[rc_index]', self.h_list[rc_index])
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
            
    def __extract(self):
        print(self.h_list)
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) < self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/21:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        if rc_index > self.current_size:
            return lc_index
        print('self.h_list[lc_index]', self.h_list[lc_index])
        print('self.h_list[rc_index]', self.h_list[rc_index])
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
            
    def __extract(self):
        print(self.h_list)
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) < self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/22:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        if rc_index > self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
            
    def __extract(self):
        print(self.h_list)
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) < self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/23:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]
        self.current_size = 0
        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.current_size += 1
        i = self.current_size
        while i > 1 and self.h_list[i] > self.h_list[i // 2]:
            self.h_list[i], self.h_list[i // 2] = self.h_list[i // 2], self.h_list[i]
            i = i // 2
            
    def find_max_child(self, index):        
        lc_index = 2 * index
        rc_index = 2 * index + 1
        if rc_index > self.current_size:
            return lc_index
        return lc_index if self.h_list[lc_index] >= self.h_list[rc_index] else rc_index
        
            
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        root = self.h_list[1]
        last_ch = self.current_size
        self.h_list[1], self.h_list[last_ch] = self.h_list[last_ch], self.h_list[1]
        self.h_list.pop()
        self.current_size -= 1
        i = 1
        while (i * 2) < self.current_size:
            #index of max Node max child             
            mc_index = self.find_max_child(i)
            if self.h_list[i] < self.h_list[mc_index]:
                self.h_list[i], self.h_list[mc_index] = self.h_list[mc_index], self.h_list[i]
            i = mc_index
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/24:
"""
Min Heap Implementation in Python
"""
class MinHeap:
    def __init__(self):
        """
        On this implementation the heap list is initialized with a value
        """
        self.heap_list = [0]
        self.current_size = 0
 
    def sift_up(self, i):
        """
        Moves the value up in the tree to maintain the heap property.
        """
        # While the element is not the root or the left element
        while i // 2 > 0:
            # If the element is less than its parent swap the elements
            if self.heap_list[i] < self.heap_list[i // 2]:
                self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i]
            # Move the index to the parent to keep the properties
            i = i // 2
 
    def insert(self, k):
        """
        Inserts a value into the heap
        """
        # Append the element to the heap
        self.heap_list.append(k)
        # Increase the size of the heap.
        self.current_size += 1
        # Move the element to its position from bottom to the top
        self.sift_up(self.current_size)
 
    def sift_down(self, i):
        # if the current node has at least one child
        while (i * 2) <= self.current_size:
            # Get the index of the min child of the current node
            mc = self.min_child(i)
            # Swap the values of the current element is greater than its min child
            if self.heap_list[i] > self.heap_list[mc]:
                self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i]
            i = mc
 
    def min_child(self, i):
        # If the current node has only one child, return the index of the unique child
        if (i * 2)+1 > self.current_size:
            return i * 2
        else:
            # Herein the current node has two children
            # Return the index of the min child according to their values
            if self.heap_list[i*2] < self.heap_list[(i*2)+1]:
                return i * 2
            else:
                return (i * 2) + 1
 
    def delete_min(self):
        # Equal to 1 since the heap list was initialized with a value
        if len(self.heap_list) == 1:
            return 'Empty heap'
 
        # Get root of the heap (The min value of the heap)
        root = self.heap_list[1]
 
        # Move the last value of the heap to the root
        self.heap_list[1] = self.heap_list[self.current_size]
 
        # Pop the last value since a copy was set on the root
        *self.heap_list, _ = self.heap_list
 
        # Decrease the size of the heap
        self.current_size -= 1
 
        # Move down the root (value at index 1) to keep the heap property
        self.sift_down(1)
 
        # Return the min value of the heap
        return root
"""
Driver program
"""
# Same tree as above example.
my_heap = MinHeap()
my_heap.insert(5)
my_heap.insert(6)
my_heap.insert(7)
my_heap.insert(9)
my_heap.insert(13)
my_heap.insert(11)
my_heap.insert(10)

print(my_heap.delete_min()) # removing min node i.e 5
111/25:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        elif self.h_list[v * 2] >= self.h_list[v * 2 + 1]
            max_idx = v * 2
        else:
            max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        self.h_list[1], self.h_list[size] = self.h_list[size], self.h_list[1]
        self.h_list.pop()
        self.shift_down(1)
        

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/26:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        elif self.h_list[v * 2] >= self.h_list[v * 2 + 1]:
            max_idx = v * 2
        else:
            max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) == 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        root = self.h_list[1]
        self.h_list[1], self.h_list[size] = self.h_list[size], self.h_list[1]
        self.h_list.pop()
        self.shift_down(1)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/27:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        elif self.h_list[v * 2] >= self.h_list[v * 2 + 1]:
            max_idx = v * 2
        else:
            max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) <= 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        root = self.h_list[1]
        self.h_list[1], self.h_list[size] = self.h_list[size], self.h_list[1]
        self.h_list.pop()
        self.shift_down(1)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/28:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        elif self.h_list[v * 2] >= self.h_list[v * 2 + 1]:
            max_idx = v * 2
        else:
            max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) <= 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        root = self.h_list[1]
        self.h_list[1], self.h_list[size] = self.h_list[size], self.h_list[1]
        self.h_list.pop()
        self.shift_down(1)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/29:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        elif self.h_list[v * 2] >= self.h_list[v * 2 + 1]:
            max_idx = v * 2
        else:
            max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) <= 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        root = self.h_list[1]
        print(self.h_list)
        self.h_list[1], self.h_list[size] = self.h_list[size], self.h_list[1]
        self.h_list.pop()
        self.shift_down(1)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/30:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        elif self.h_list[v * 2] >= self.h_list[v * 2 + 1]:
            max_idx = v * 2
        else:
            max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) <= 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        root = self.h_list[1]
        print(self.h_list)
        self.h_list[1], self.h_list[size] = self.h_list[size], self.h_list[1]
        self.h_list.pop()
        self.shift_down(1)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/31:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        elif self.h_list[v * 2] >= self.h_list[v * 2 + 1]:
            max_idx = v * 2
        else:
            max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) <= 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        root = self.h_list[1]
        print(self.h_list)
        self.h_list[1], self.h_list[size] = self.h_list[size], self.h_list[1]
        self.h_list.pop()
        self.shift_down(1)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/32:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        elif self.h_list[v * 2] >= self.h_list[v * 2 + 1]:
            max_idx = v * 2
        else:
            max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) <= 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        root = self.h_list[1]
        print(self.h_list)
#         self.h_list[1], self.h_list[size] = self.h_list[size], self.h_list[1]
#         self.h_list.pop()
#         self.shift_down(1)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/33:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            self.shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        elif self.h_list[v * 2] >= self.h_list[v * 2 + 1]:
            max_idx = v * 2
        else:
            max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            self.shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) <= 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        root = self.h_list[1]
        print(self.h_list)
#         self.h_list[1], self.h_list[size] = self.h_list[size], self.h_list[1]
#         self.h_list.pop()
#         self.shift_down(1)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/34:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            self.shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        elif self.h_list[v * 2] >= self.h_list[v * 2 + 1]:
            max_idx = v * 2
        else:
            max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            self.shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) <= 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        root = self.h_list[1]
        print(self.h_list)
        self.h_list[1], self.h_list[size] = self.h_list[size], self.h_list[1]
        self.h_list.pop()
        self.shift_down(1)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/35:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            self.shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        elif self.h_list[v * 2] >= self.h_list[v * 2 + 1]:
            max_idx = v * 2
        else:
            max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            self.shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) <= 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        root = self.h_list[1]
        print(self.h_list)
        self.h_list[1], self.h_list[size - 1] = self.h_list[size - 1], self.h_list[1]
        self.h_list.pop()
        self.shift_down(1)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/36:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            self.shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        elif self.h_list[v * 2] >= self.h_list[v * 2 + 1]:
            max_idx = v * 2
        else:
            max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            self.shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) <= 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        root = self.h_list[1]
        self.h_list[1], self.h_list[size - 1] = self.h_list[size - 1], self.h_list[1]
        self.h_list.pop()
        self.shift_down(1)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """ADD 192168812
ADD 125
ADD 321
EXTRACT
EXTRACT
CLEAR
ADD 7
ADD 555
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/37:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            self.shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        elif self.h_list[v * 2] >= self.h_list[v * 2 + 1]:
            max_idx = v * 2
        else:
            max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            self.shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) <= 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        root = self.h_list[1]
        self.h_list[1], self.h_list[size - 1] = self.h_list[size - 1], self.h_list[1]
        self.h_list.pop()
        self.shift_down(1)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        self.current_size = 0
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/38:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            self.shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        elif self.h_list[v * 2] >= self.h_list[v * 2 + 1]:
            max_idx = v * 2
        max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            self.shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) <= 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        root = self.h_list[1]
        self.h_list[1], self.h_list[size - 1] = self.h_list[size - 1], self.h_list[1]
        self.h_list.pop()
        self.shift_down(1)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/39:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            self.shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        elif self.h_list[v * 2] >= self.h_list[v * 2 + 1]:
            max_idx = v * 2
        else:
            max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            self.shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) <= 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        root = self.h_list[1]
        self.h_list[1], self.h_list[size - 1] = self.h_list[size - 1], self.h_list[1]
        self.h_list.pop()
        self.shift_down(1)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/40:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            self.shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        if self.h_list[v * 2] >= self.h_list[v * 2 + 1]:
            max_idx = v * 2
        max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            self.shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) <= 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        root = self.h_list[1]
        self.h_list[1], self.h_list[size - 1] = self.h_list[size - 1], self.h_list[1]
        self.h_list.pop()
        self.shift_down(1)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/41:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            self.shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        elif self.h_list[v * 2] >= self.h_list[v * 2 + 1]:
            max_idx = v * 2
        else:
            max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            self.shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) <= 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        root = self.h_list[1]
        self.h_list[1], self.h_list[size - 1] = self.h_list[size - 1], self.h_list[1]
        self.h_list.pop()
        self.shift_down(1)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
111/42:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            self.shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        elif self.h_list[v * 2] >= self.h_list[v * 2 + 1]:
            max_idx = v * 2
        else:
            max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            self.shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) <= 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        root = self.h_list[1]
        self.h_list[1], self.h_list[size - 1] = self.h_list[size - 1], self.h_list[1]
        self.h_list.pop()
        self.shift_down(1)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
112/1: number = int(input())
112/2:
number = int(input())

def lagrangeFourSquare(n):
    a, b, c, d = 0, 0, 0, 0
    if n == 0:
        return a, b, c, d
    if n == 1:
        return 1, 1, 1, 1
    
    
lagrangeFourSquare(number)
112/3:
number = int(input())

def lagrangeFourSquare(n):
    if n == 0:
        return (*0, 0, 0, 0)
    if n == 1:
        return (*1, 1, 1, 1)
    
    
lagrangeFourSquare(number)
112/4:
number = int(input())

def lagrangeFourSquare(n):
    a, b, c, d = 0, 0, 0, 0
    if n == 0:
        return (*a, b, c, d)
    if n == 1:
        return 1, 1, 1, 1
    
    
lagrangeFourSquare(number)
112/5:
number = int(input())

def lagrangeFourSquare(n):
    a, b, c, d = 0, 0, 0, 0
    if n == 0:
        return f'{a},b, c, d '
    if n == 1:
        return 1, 1, 1, 1
    
    
lagrangeFourSquare(number)
112/6:
number = int(input())

def lagrangeFourSquare(n):
    a, b, c, d = 0, 0, 0, 0
    if n == 0:
        return a
    if n == 1:
        return 1, 1, 1, 1
    
    
lagrangeFourSquare(number)
112/7:
number = int(input())

def lagrangeFourSquare(n):
    a, b, c, d = 0, 0, 0, 0
    if n == 0:
        ans = [*a]
        return ans
    if n == 1:
        return 1, 1, 1, 1
    
    
lagrangeFourSquare(number)
112/8:
number = int(input())

def lagrangeFourSquare(n):
    a, b, c, d = 0, 0, 0, 0
    if n == 0:
#         ans = [*a]
        return a b c
    if n == 1:
        return 1, 1, 1, 1
    
    
lagrangeFourSquare(number)
112/9:
number = int(input())

def lagrangeFourSquare(n):
    a, b, c, d = 0, 0, 0, 0
    if n == 0:
        return f'{a} {b} {c}'
    if n == 1:
        return 1, 1, 1, 1
    
    
lagrangeFourSquare(number)
112/10:
number = int(input())

def lagrangeFourSquare(n):
    a, b, c, d = 0, 0, 0, 0
    if n == 0:
        a = 1
        return f'{a} {b} {c}'
    if n == 1:
        return 1, 1, 1, 1
    
    
lagrangeFourSquare(number)
112/11:
from math import sqrt
number = int(input())

def lagrangeFourSquare(n):
    if n == 0:
        return 0
    a = int(sqrt(n))
    return a

    
    
lagrangeFourSquare(number)
112/12:
for i in range (a):
    print(i)
112/13:
for i in range (10):
    print(i)
112/14:
from math import sqrt
number = int(input())

def lagrangeFourSquare(n):
    if n == 0:
        return 0
    a = int(sqrt(n)) + a
    for i in range (a):
        for j in range (a):
            for k in range (a):
                for l in range (a):
                    if i*i + j*j + k*k +l*l == n:
                        return i, j, k, l

lagrangeFourSquare(number)
112/15:
from math import sqrt
number = int(input())

def lagrangeFourSquare(n):
    if n == 0:
        return 0
    a = int(sqrt(n)) + 1
    for i in range (a):
        for j in range (a):
            for k in range (a):
                for l in range (a):
                    if i*i + j*j + k*k +l*l == n:
                        return i, j, k, l

lagrangeFourSquare(number)
112/16:
from math import sqrt
number = int(input())

def lagrangeFourSquare(n):
    if n == 0:
        return 0
    a = int(sqrt(n)) + 1
    for i in range (a):
        for j in range (a):
            for k in range (a):
                for l in range (a):
                    if i*i + j*j + k*k +l*l == n:
                        return i, j, k, l

res = lagrangeFourSquare(number)
res.sort()
for res_n in res:
    if res_n !== 0
        print res_n
112/17:
from math import sqrt
number = int(input())

def lagrangeFourSquare(n):
    if n == 0:
        return 0
    a = int(sqrt(n)) + 1
    for i in range (a):
        for j in range (a):
            for k in range (a):
                for l in range (a):
                    if i*i + j*j + k*k +l*l == n:
                        return i, j, k, l

res = lagrangeFourSquare(number)
res.sort()
for res_n in res:
    if res_n != 0
        print res_n
112/18:
from math import sqrt
number = int(input())

def lagrangeFourSquare(n):
    if n == 0:
        return 0
    a = int(sqrt(n)) + 1
    for i in range (a):
        for j in range (a):
            for k in range (a):
                for l in range (a):
                    if i*i + j*j + k*k +l*l == n:
                        return i, j, k, l

res = lagrangeFourSquare(number)
res.sort()
for res_n in res:
    if res_n != 0:
        print res_n
112/19:
from math import sqrt
number = int(input())

def lagrangeFourSquare(n):
    if n == 0:
        return 0
    a = int(sqrt(n)) + 1
    for i in range (a):
        for j in range (a):
            for k in range (a):
                for l in range (a):
                    if i*i + j*j + k*k +l*l == n:
                        return i, j, k, l

res = lagrangeFourSquare(number)
res.sort()
for res_n in res:
    if res_n != 0:
        print (res_n)
112/20:
from math import sqrt
number = int(input())

def lagrangeFourSquare(n):
    if n == 0:
        return 0
    a = int(sqrt(n)) + 1
    for i in range (a):
        for j in range (a):
            for k in range (a):
                for l in range (a):
                    if i*i + j*j + k*k +l*l == n:
                        return [i, j, k, l]

res = lagrangeFourSquare(number)
res.sort()
for res_n in res:
    if res_n != 0:
        print (res_n)
112/21:
from math import sqrt
number = int(input())

def lagrangeFourSquare(n):
    if n == 0:
        return 0
    a = int(sqrt(n)) + 1
    for i in range (a):
        for j in range (a):
            for k in range (a):
                for l in range (a):
                    if i*i + j*j + k*k +l*l == n:
                        return [i, j, k, l]

res = lagrangeFourSquare(number)
res.sort()
for res_n in res:
    if res_n != 0:
        print (res_n,  end=' ')
112/22:
from math import sqrt
number = int(input())

def lagrangeFourSquare(n):
    if n == 0:
        return 0
    a = int(sqrt(n)) + 1
    for i in range (a):
        for j in range (a):
            for k in range (a):
                for l in range (a):
                    if i*i + j*j + k*k +l*l == n:
                        return [i, j, k, l]

res = lagrangeFourSquare(number)
for res_n in res:
    if res_n != 0:
        print (res_n,  end=' ')
112/23:
from math import sqrt
number = int(input())

def lagrangeFourSquare(n):
    if n == 0:
        return 0
    a = int(sqrt(n)) + 1
    for i in range (a):
        for j in range (a):
            for k in range (a):
                for l in range (a):
                    if i*i + j*j + k*k +l*l == n:
                        return [i, j, k, l]

res = lagrangeFourSquare(number)
res.sort(reverse=True)
for res_n in res:
    if res_n != 0:
        print (res_n,  end=' ')
112/24:
from math import sqrt
number = int(input())

def lagrangeFourSquare(n):
    if n == 0:
        return 0
    a = int(sqrt(n)) + 1
    for i in range (a):
        for j in range (a):
            for k in range (a):
                for l in range (a):
                    if i*i + j*j + k*k +l*l == n:
                        return [i, j, k, l]

res = lagrangeFourSquare(number)
for res_n in res:
    if res_n != 0:
        print (res_n,  end=' ')
112/25:
from math import sqrt
number = int(input())

def lagrangeFourSquare(n):
    if n == 0:
        return 0
    a = int(sqrt(n)) + 1
    for i in range (a):
        for j in range (a):
            for k in range (a):
                for l in range (a):
                    if i*i + j*j + k*k +l*l == n:
                        return [i, j, k, l]

res = lagrangeFourSquare(number)
for res_n in res:
    if res_n != 0:
        print (res_n,  end=' ')
112/26:
from math import sqrt
number = int(input())

def lagrangeFourSquare(n):
    if n == 0:
        return 0
    a = int(sqrt(n)) + 1
    for i in range (a):
        for j in range (a):
            for k in range (a):
                for l in range (a):
                    if i*i + j*j + k*k +l*l == n:
                        return [i, j, k, l]

res = lagrangeFourSquare(number)
for res_n in res:
    if res_n != 0:
        print (res_n,  end=' ')
112/27:
from math import sqrt
number = int(input())

def lagrangeFourSquare(n):
    if n == 0:
        return [0]
    a = int(sqrt(n)) + 1
    for i in range (a):
        for j in range (a):
            for k in range (a):
                for l in range (a):
                    if i*i + j*j + k*k +l*l == n:
                        return [i, j, k, l]

res = lagrangeFourSquare(number)
for res_n in res:
    if res_n != 0:
        print (res_n,  end=' ')
113/1:
class MaxHeap:
    def __init__(self):
        self.functions = {
            'ADD': self.__add,
            'EXTRACT': self.__extract,
            'CLEAR': self.__clear,
        }
        self.h_list = [None]

        
    def call_without_payload(self, arg):
        self.functions[arg]()

    def call_with_payload(self, arg, payload):
        self.functions[arg](payload)
        
    def shift_up(self, v):
        if v == 1:
            return
        if self.h_list[v // 2] < self.h_list[v]:
            self.h_list[v // 2], self.h_list[v] = self.h_list[v], self.h_list[v // 2]
            self.shift_up(v // 2)
    
    def shift_down(self, v):
        size = len(self.h_list)
        if v * 2 >= size:
            return
        max_idx = 1
        if (v * 2 + 1) == size:
            max_idx = v * 2
        elif self.h_list[v * 2] >= self.h_list[v * 2 + 1]:
            max_idx = v * 2
        else:
            max_idx = v * 2 + 1
        
        if self.h_list[v] < self.h_list[max_idx]:
            self.h_list[v], self.h_list[max_idx] = self.h_list[max_idx], self.h_list[v]
            self.shift_down(max_idx)
        
    
    def __add(self, k):
        self.h_list.append(int(k))
        self.shift_up(len(self.h_list) - 1)
            
    def __extract(self):
        if len(self.h_list) <= 1:
            print('CANNOT')
            return 'CANNOT'
        size = len(self.h_list)
        root = self.h_list[1]
        self.h_list[1], self.h_list[size - 1] = self.h_list[size - 1], self.h_list[1]
        self.h_list.pop()
        self.shift_down(1)
        print(root)
        return root

    def __clear(self):
        self.h_list.clear()
        self.h_list.append(None)
        
my_heap = MaxHeap()

data = """EXTRACT
EXTRACT
CLEAR
ADD 0
ADD 555
ADD 555
ADD 555
ADD 1045
ADD 1034
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
EXTRACT
"""
data = data.splitlines()
# for c in commands:
for c in data:
    command, *payload = c.split()
    if len(payload) == 0:
        my_heap.call_without_payload(command)
    else:
        my_heap.call_with_payload(command, payload[0])
115/1: n, window = int(input().split)
115/2: n, window = int(input().split())
115/3: n, k = [int(x) for x in input().split()]
115/4: n, k = [int(x) for x in input().split()]
115/5:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

def getMinOnIterval(interval):
    return interval

for i in range(n-3):
    getMinOnIterval(seq[i, i + 2])
115/6:
n, k = [int(x) for x in input().split()]
seq = list(map(int,input().split()))

def getMinOnIterval(interval):
    return interval

for i in range(n-3):
    getMinOnIterval(seq[i, i + 2])
115/7:
n, k = [int(x) for x in input().split()]
seq = list(map(int,input().split()))
print(type(seq))

def getMinOnIterval(interval):
    return interval

# 7 3
# 1 3 2 4 5 3 1


for i in range(n-3):
    getMinOnIterval(seq[i, i + 2])
115/8:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]
print( type(seq))

def getMinOnIterval(interval):
    return interval

for i in range(n-3):
    getMinOnIterval(seq[i, i + 2])
115/9:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]
def getMinOnIterval(interval):
    return interval

for i in range(n-3):
    getMinOnIterval(seq[i:i + 2])
115/10:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

def getMinOnIterval(interval):
    return interval

for i in range(n-3):
    print(getMinOnIterval(seq[i:i + 2])
115/11:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

def getMinOnIterval(interval):
    return interval

for i in range(n-3):
    print(getMinOnIterval(seq[i:i + 2]))
115/12:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

def getMinOnIterval(interval):
    return interval

for i in range(n-3):
    print(getMinOnIterval(seq[i:i + 3]))
115/13:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

def getMinOnIterval(interval):
    return interval

for i in range(n-2):
    print(getMinOnIterval(seq[i:i + 3]))
115/14:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence

    def getMin(self, interval):
        print(interval)

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/15:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        print(self.list)

    def getMin(self, interval):
        pass

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
120/1:
from math import sqrt
number = int(input())

def lagrangeFourSquare(n):
    if n == 0:
        return [0]
    a = int(sqrt(n)) + 1
    for i in range (a):
        for j in range (i+1):
            for k in range (j+1):
                for l in range (k+1):
                    if i*i + j*j + k*k +l*l == n:
                        return [i, j, k, l]

res = lagrangeFourSquare(number)
for res_n in res:
    if res_n != 0:
        print (res_n,  end=' ')
115/16:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
        print(self.list)


    def getMin(self, interval):
        pass

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/17:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
        print(self.list)


    def getMin(self, interval):
        pass

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/18:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
        print(self.list)


    def getMin(self, interval):
        pass

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/19:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(self.base):
            self.heap.append(0)
        for i in range(self.base, self.base - len(self.list), -1):
            self.heap[i] = self.list[self.base - i]
        print(self.heap)

    def getMin(self, interval):
        pass

    

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/20:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(self.base):
            self.heap.append(0)
        for i in range(self.base - 1, self.base - len(self.list), -1):
            self.heap[i] = self.list[(self.base - 1) - i]
        print(self.heap)

    def getMin(self, interval):
        pass

    

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/21:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(self.base):
            self.heap.append(0)
        for i in range(self.base - 1, self.base - len(self.list), -1):
            self.heap[i] = self.list[(self.base - 1)]
        print(self.heap)

    def getMin(self, interval):
        pass

    

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/22:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(self.base):
            self.heap.append(0)
        for i in range(self.base - 1, self.base - len(self.list), -1):
            self.heap[i] = self.list[i - (self.base - 1)]
        print(self.heap)

    def getMin(self, interval):
        pass

    

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/23:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(self.base):
            self.heap.append(0)
        for i in range(self.base - 1, self.base - len(self.list), -1):
            self.heap[i] = self.list[(self.base - 1) - i]
        print(self.heap)

    def getMin(self, interval):
        pass

    

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/24:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(self.base):
            self.heap.append(0)
        for i in range(self.base - 1, self.base - len(self.list), -1):
            self.heap[(self.base - 1) - i] = self.list[(self.base - 1) - i]
        print(self.heap)

    def getMin(self, interval):
        pass

    

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/25:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]
        print(self.heap)

    def getMin(self, interval):
        pass


my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/26:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(len(self.list)):
            self.heap[self.base/2 + i] = self.list[i]
        print(self.heap)

    def getMin(self, interval):
        pass


my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/27:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(len(self.list)):
            self.heap[self.base/2 + i - 1] = self.list[i]
        print(self.heap)

    def getMin(self, interval):
        pass


my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/28:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(self.base):
            self.heap[i] = 0
            
        for i in range(len(self.list)):
            self.heap[self.base/2 + i - 1] = self.list[i]
        print(self.heap)

    def getMin(self, interval):
        pass


my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/29:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(self.base):
            self.heap.append(0)
            
        for i in range(len(self.list)):
            self.heap[self.base/2 + i - 1] = self.list[i]
        print(self.heap)

    def getMin(self, interval):
        pass


my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/30:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(self.base):
            self.heap.append(0)
            
#         for i in range(len(self.list)):
#             self.heap[self.base/2 + i - 1] = self.list[i]
        print(self.heap)

    def getMin(self, interval):
        pass


my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/31:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(0)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]
        print(self.heap)

    def getMin(self, interval):
        pass


my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/32:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(0)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*self.base - i], self.heap[2*self.base - i - 1])
        print(self.heap)
            
            
    def getMin(self, interval):
        pass


my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/33:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(0)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, interval):
        pass


my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/34:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, interval):
        pass


my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/35:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , -1, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, interval):
        pass


my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/36:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 1, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, interval):
        pass


my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/37:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, interval):
        pass


my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(seq[i:i + 3]))
115/38:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)/2 
        if pl >= ser:
             return rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        if pr =< ser:
            return rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = rercMin(pl, pr, lvl*2, seg_L, ser)
        right_value = rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/39:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)/2 
        if pl >= ser:
             return rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        if pr <= ser:
            return rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = rercMin(pl, pr, lvl*2, seg_L, ser)
        right_value = rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/40:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)/2 
        if pl >= ser:
             return self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, pr, lvl*2, seg_L, ser)
        right_value = self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/41:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)/2 
        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, pr, lvl*2, seg_L, ser)
        right_value = self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/42:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        print(pl, pr, lvl, seg_L, seg_R)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)/2
    
        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, pr, lvl*2, seg_L, ser)
        right_value = self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/43:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(0)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        print(pl, pr, lvl, seg_L, seg_R)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)//2
    
        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, pr, lvl*2, seg_L, ser)
        right_value = self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/44:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        print(pl, pr, lvl, seg_L, seg_R)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)//2
    
        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, pr, lvl*2, seg_L, ser)
        right_value = self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/45:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        print(pl, pr, lvl, seg_L, seg_R)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)//2
    
        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, pr, lvl*2, seg_L, ser)
        right_value = self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/46:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
        print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, pr, lvl*2, seg_L, ser)
        right_value = self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/47:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
        print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2, ser + 1, seg_R)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/48:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
#         print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
#         print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2, ser + 1, seg_R)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/49:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
#         print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
#         print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2 + 1, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2, ser + 1, seg_R)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/50:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
#         print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
#         print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2 + 1, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2, ser + 1, seg_R)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/51:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
#         print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
#         print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2 + 1, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2, ser + 1, seg_R)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/52:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
        print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2 + 1, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2, ser + 1, seg_R)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/53:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
        print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2 + 1, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2, ser + 1, seg_R)
        print('left_value', left_value)
        print('right_value', right_value)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/54:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
        print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2 + 1, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2, ser + 1, seg_R)
        print('left_value', left_value)
        print('right_value', right_value)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/55:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
        print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2 + 1, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
        print('left_value', left_value)
        print('right_value', right_value)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/56:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
        print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
        print('left_value', left_value)
        print('right_value', right_value)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/57:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
#         print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
#         print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/58:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
        print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
        print('left_value', left_value)
        print('right_value', right_value)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 3))
115/59:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
#         print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
#         print('left_value', left_value)
#         print('right_value', right_value)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 2))
115/60:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
#         print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
#         print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
#         print('left_value', left_value)
#         print('right_value', right_value)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + 2))
115/61:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
        print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
        print('left_value', left_value)
        print('right_value', right_value)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + k))
115/62:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
        print(self.heap)
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
#         print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
#         print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
#         print('left_value', left_value)
#         print('right_value', right_value)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(i + k)
    print(my_tree.getMin(i, i + k - 1))
115/63:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
#         print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
#         print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
#         print('left_value', left_value)
#         print('right_value', right_value)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(i + k)
    print(my_tree.getMin(i, i + k - 1))
115/64:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
#         print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
#         print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
#         print('left_value', left_value)
#         print('right_value', right_value)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(k)
    print(my_tree.getMin(i, i + k - 1))
115/65:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
#         print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
#         print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
#         print('left_value', left_value)
#         print('right_value', right_value)
        return min(self.list[left_value], self.list[right_value])

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + k - 1))
122/1:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])
            
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
#         print(pl, pr, lvl, seg_L, seg_R)
        ser = (seg_L + seg_R)//2
#         print('ser', ser)
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать

        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
#         print('left_value', left_value)
#         print('right_value', right_value)
        return min(left_value, right_value)

my_tree = Tree(seq)

for i in range(n-2):

    print(my_tree.getMin(i, i + k - 1))
122/2:
# Python3 program for range minimum
# query using segment tree
import sys;
from math import ceil,log2;

INT_MAX = sys.maxsize;

# A utility function to get
# minimum of two numbers
def minVal(x, y) :
    return x if (x < y) else y;

# A utility function to get the
# middle index from corner indexes.
def getMid(s, e) :
    return s + (e - s) // 2;

""" A recursive function to get the
minimum value in a given range
of array indexes. The following
are parameters for this function.

    st --> Pointer to segment tree
    index --> Index of current node in the
        segment tree. Initially 0 is
        passed as root is always at index 0
    ss & se --> Starting and ending indexes
                of the segment represented
                by current node, i.e., st[index]
    qs & qe --> Starting and ending indexes of query range """
def RMQUtil( st, ss, se, qs, qe, index) :

    # If segment of this node is a part
    # of given range, then return
    # the min of the segment
    if (qs <= ss and qe >= se) :
        return st[index];

    # If segment of this node
    # is outside the given range
    if (se < qs or ss > qe) :
        return INT_MAX;

    # If a part of this segment
    # overlaps with the given range
    mid = getMid(ss, se);
    return minVal(RMQUtil(st, ss, mid, qs,
                        qe, 2 * index + 1),
                RMQUtil(st, mid + 1, se,
                        qs, qe, 2 * index + 2));

# Return minimum of elements in range
# from index qs (query start) to
# qe (query end). It mainly uses RMQUtil()
def RMQ( st, n, qs, qe) :

    # Check for erroneous input values
    if (qs < 0 or qe > n - 1 or qs > qe) :
    
        print("Invalid Input");
        return -1;
    
    return RMQUtil(st, 0, n - 1, qs, qe, 0);

# A recursive function that constructs
# Segment Tree for array[ss..se].
# si is index of current node in segment tree st
def constructSTUtil(arr, ss, se, st, si) :

    # If there is one element in array,
    # store it in current node of
    # segment tree and return
    if (ss == se) :

        st[si] = arr[ss];
        return arr[ss];

    # If there are more than one elements,
    # then recur for left and right subtrees
    # and store the minimum of two values in this node
    mid = getMid(ss, se);
    st[si] = minVal(constructSTUtil(arr, ss, mid,
                                    st, si * 2 + 1),
                    constructSTUtil(arr, mid + 1, se,
                                    st, si * 2 + 2));
    
    return st[si];

"""Function to construct segment tree
from given array. This function allocates
memory for segment tree and calls constructSTUtil()
to fill the allocated memory """
def constructST( arr, n) :

    # Allocate memory for segment tree

    # Height of segment tree
    x = (int)(ceil(log2(n)));

    # Maximum size of segment tree
    max_size = 2 * (int)(2**x) - 1;

    st = [0] * (max_size);

    # Fill the allocated memory st
    constructSTUtil(arr, 0, n - 1, st, 0);

    # Return the constructed segment tree
    return st;

# Driver Code
if __name__ == "__main__" :

    arr = [1, 3, 2, 7, 9, 11];
    n = len(arr);

    # Build segment tree from given array
    st = constructST(arr, n);

    qs = 1; # Starting index of query range
    qe = 5; # Ending index of query range

    # Print minimum value in arr[qs..qe]
    print("Minimum of values in range [", qs,
        ",", qe, "]", "is =", RMQ(st, n, qs, qe));

# This code is contributed by AnkitRai01
122/3:
import sys;
from math import ceil,log2;
 
INT_MAX = sys.maxsize;
 
# A utility function to get
# minimum of two numbers
def minVal(x, y) :
    return x if (x < y) else y;
 
# A utility function to get the
# middle index from corner indexes.
def getMid(s, e) :
    return s + (e - s) // 2;
 
def RMQUtil( st, ss, se, qs, qe, index) :
 
    # If segment of this node is a part
    # of given range, then return
    # the min of the segment
    if (qs <= ss and qe >= se) :
        return st[index];
 
    # If segment of this node
    # is outside the given range
    if (se < qs or ss > qe) :
        return INT_MAX;
 
    # If a part of this segment
    # overlaps with the given range
    mid = getMid(ss, se);
    return minVal(RMQUtil(st, ss, mid, qs,
                          qe, 2 * index + 1),
                  RMQUtil(st, mid + 1, se,
                          qs, qe, 2 * index + 2));
 
# Return minimum of elements in range
# from index qs (query start) to
# qe (query end). It mainly uses RMQUtil()
def RMQ( st, n, qs, qe) :
 
    # Check for erroneous input values
    if (qs < 0 or qe > n - 1 or qs > qe) :
     
        print("Invalid Input");
        return -1;
     
    return RMQUtil(st, 0, n - 1, qs, qe, 0);
 
# A recursive function that constructs
# Segment Tree for array[ss..se].
# si is index of current node in segment tree st
def constructSTUtil(arr, ss, se, st, si) :
 
    # If there is one element in array,
    # store it in current node of
    # segment tree and return
    if (ss == se) :
 
        st[si] = arr[ss];
        return arr[ss];
 
    # If there are more than one elements,
    # then recur for left and right subtrees
    # and store the minimum of two values in this node
    mid = getMid(ss, se);
    st[si] = minVal(constructSTUtil(arr, ss, mid,
                                    st, si * 2 + 1),
                    constructSTUtil(arr, mid + 1, se,
                                    st, si * 2 + 2));
     
    return st[si];
 
"""Function to construct segment tree
from given array. This function allocates
memory for segment tree and calls constructSTUtil()
to fill the allocated memory """
def constructST( arr, n) :
 
    # Allocate memory for segment tree
 
    # Height of segment tree
    x = (int)(ceil(log2(n)));
 
    # Maximum size of segment tree
    max_size = 2 * (int)(2**x) - 1;
  
    st = [0] * (max_size);
 
    # Fill the allocated memory st
    constructSTUtil(arr, 0, n - 1, st, 0);
 
    # Return the constructed segment tree
    return st;
 
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]
st = constructST(seq, n);
    
for i in range(n-2):
    print(RMQ(st, n, i, i+k-1))
122/4:
import sys;
from math import ceil,log2;
 
INT_MAX = sys.maxsize;
 
# A utility function to get
# minimum of two numbers
def minVal(x, y) :
    return x if (x < y) else y;
 
# A utility function to get the
# middle index from corner indexes.
def getMid(s, e) :
    return s + (e - s) // 2;
 
def RMQUtil( st, ss, se, qs, qe, index) :
 
    # If segment of this node is a part
    # of given range, then return
    # the min of the segment
    if (qs <= ss and qe >= se) :
        return st[index];
 
    # If segment of this node
    # is outside the given range
    if (se < qs or ss > qe) :
        return INT_MAX;
 
    # If a part of this segment
    # overlaps with the given range
    mid = getMid(ss, se);
    return minVal(RMQUtil(st, ss, mid, qs,
                          qe, 2 * index + 1),
                  RMQUtil(st, mid + 1, se,
                          qs, qe, 2 * index + 2));
 
# Return minimum of elements in range
# from index qs (query start) to
# qe (query end). It mainly uses RMQUtil()
def RMQ( st, n, qs, qe) :
 
    # Check for erroneous input values
    if (qs < 0 or qe > n - 1 or qs > qe) :
     
        print("Invalid Input");
        return -1;
     
    return RMQUtil(st, 0, n - 1, qs, qe, 0);
 
# A recursive function that constructs
# Segment Tree for array[ss..se].
# si is index of current node in segment tree st
def constructSTUtil(arr, ss, se, st, si) :
 
    # If there is one element in array,
    # store it in current node of
    # segment tree and return
    if (ss == se) :
 
        st[si] = arr[ss];
        return arr[ss];
 
    # If there are more than one elements,
    # then recur for left and right subtrees
    # and store the minimum of two values in this node
    mid = getMid(ss, se);
    st[si] = minVal(constructSTUtil(arr, ss, mid,
                                    st, si * 2 + 1),
                    constructSTUtil(arr, mid + 1, se,
                                    st, si * 2 + 2));
     
    return st[si];
 
"""Function to construct segment tree
from given array. This function allocates
memory for segment tree and calls constructSTUtil()
to fill the allocated memory """
def constructST( arr, n) :
 
    # Allocate memory for segment tree
 
    # Height of segment tree
    x = (int)(ceil(log2(n)));
 
    # Maximum size of segment tree
    max_size = 2 * (int)(2**x) - 1;
  
    st = [0] * (max_size);
 
    # Fill the allocated memory st
    constructSTUtil(arr, 0, n - 1, st, 0);
 
    # Return the constructed segment tree
    return st;
 
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]
st = constructST(seq, n);
    
for i in range(n-2):
    print(RMQ(st, n, i, i+k-1))
122/5:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])          
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)//2
        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
        return min(left_value, right_value)

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + k - 1))
122/6:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])          
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)//2
        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
        return min(left_value, right_value)

my_tree = Tree(seq)

for i in range(n-2):
    print(my_tree.getMin(i, i + k - 1))
122/7:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])          
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)//2
        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
        return min(left_value, right_value)

my_tree = Tree(seq)

for i in range(n-2):
    print('i, n-2', i, n-2)
    print(my_tree.getMin(i, i + k - 1))
122/8:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])          
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)//2
        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
        return min(left_value, right_value)

my_tree = Tree(seq)
0 5
1-6
for i in range(0, i + k - 1,):
    print('i, n-2', i + k - 1)
    print(my_tree.getMin(i, i + k - 1))
122/9:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])          
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)//2
        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
        return min(left_value, right_value)

my_tree = Tree(seq)
# 0 5
# 1-6
for i in range(0, i + k - 1,):
    print('i, n-2', i + k - 1)
    print(my_tree.getMin(i, i + k - 1))
122/10:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])          
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)//2
        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
        return min(left_value, right_value)

my_tree = Tree(seq)
# 0 5
# 1-6
for i in range(i, n//k):
    print('i, i + k - 1', i, i + k - 1)
    print(my_tree.getMin(i, i + k - 1))
122/11:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])          
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)//2
        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
        return min(left_value, right_value)

my_tree = Tree(seq)
# 0 5
# 1-6
for i in range(i, n//k):
    print('i, i + k - 1', i, i + k - 1)
    print(my_tree.getMin(i, i + k - 1))
122/12:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])          
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)//2
        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
        return min(left_value, right_value)

my_tree = Tree(seq)
end = n//k
# 0 5
# 1-6
for i in range(end):
    print('i, i + k - 1', i, i + k - 1)
    print(my_tree.getMin(i, i + k - 1))
122/13:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])          
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)//2
        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
        return min(left_value, right_value)

my_tree = Tree(seq)

from math import ceil
end = ceil(n/k)
# 0 5
# 1-6

for i in range(end):
    print('i, i + k - 1', i, i + k - 1)
    print(my_tree.getMin(i, i + k - 1))
122/14:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])          
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)//2
        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
        return min(left_value, right_value)

my_tree = Tree(seq)

from math import ceil
end = ceil(n/k)
# 0 5
# 1-6

for i in range(end):
    print('i, i + k - 1', i, i + k - 1)
    print(my_tree.getMin(i, i + k - 1))
122/15:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])          
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)//2
        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
        return min(left_value, right_value)

my_tree = Tree(seq)

from math import ceil
end = n - k + 1
# 0 5
# 1-6

for i in range(end):
    print('i, i + k - 1', i, i + k - 1)
    print(my_tree.getMin(i, i + k - 1))
122/16:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])          
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)//2
        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
        return min(left_value, right_value)

my_tree = Tree(seq)

from math import ceil
end = n - k + 1
# 0 5
# 1-6

for i in range(end):
    print('i, i + k - 1', i, i + k - 1)
    print(my_tree.getMin(i, i + k - 1))
122/17:
n, k = [int(x) for x in input().split()]
seq = [int(x) for x in input().split()]

class Tree:
    def __init__(self, sequence):
        self.list = sequence
        self.base = 1
        while self.base < len(self.list):
            self.base = self.base * 2
        for _ in range(len(self.list), self.base):
            self.list.append(150001)
            
        self.heap = []
        for i in range(2*self.base):
            self.heap.append(None)
            
        for i in range(len(self.list)):
            self.heap[self.base + i] = self.list[i]

        for i in range(self.base - 1 , 0, -1):
            self.heap[i] = min(self.heap[2*i], self.heap[2*i + 1])          
            
    def getMin(self, pl, pr):  
        return self.rercMin(pl, pr, 1, 0, self.base - 1)
        
    def rercMin(self, pl, pr, lvl, seg_L, seg_R):
        if pl == seg_L and pr == seg_R:
            return self.heap[lvl]
#       какую границу будем увеличивать/уменьшать
        ser = (seg_L + seg_R)//2
        if pl >= (ser + 1):
             return self.rercMin(pl, pr, lvl*2 + 1, ser + 1, seg_R)
        if pr <= ser:
            return self.rercMin(pl, pr, lvl*2, seg_L, ser)
#     когда левая и правая границы меньше середины
        left_value = self.rercMin(pl, ser, lvl*2, seg_L, ser)
        right_value = self.rercMin(ser + 1, pr, lvl*2 + 1, ser + 1, seg_R)
        return min(left_value, right_value)

my_tree = Tree(seq)

from math import ceil
end = n - k + 1
# 0 5
# 1-6

for i in range(end):
    print('i, i + k - 1', i, i + k - 1)
    print(my_tree.getMin(i, i + k - 1))
123/1:
from math import sqrt

x = sqrt((302/115)**2 + (232/115)**2 + (417/115)**2 + (182/115)**2)
123/2:
from math import sqrt

x = sqrt((302/115)**2 + (232/115)**2 + (417/115)**2 + (182/115)**2)
x
124/1:


class Heap_Max:
    '''
    Куча невозрастающая, или очередь с приоритетами
    '''


    def __init__(self):
        self.list_Heap = []
        self.len = 0
        pass

    def Add(self, KEY):
        '''
        Добавить в очередь ключ KEY_ (в данном задании это
        число n).
        - в конец добавляется ключ-число
        - ключ-число проталкивается наверх
        :return: ничего не выводиться, в памяти меняется
        взаиморасположение чисел в массиве. В результате
        число занимает правильное место.
        '''
        if self.len == 0:
            self.list_Heap.append(0)
            self.len += 1
        self.list_Heap.append(KEY)
        self._key_up_(self.len)
        self.len += 1

    def Extract_Max(self):
        '''
        извлекает "корень" кучи,
        возвращает самый приоритетный элемент, и удаляет
        его из кучи
        :return: возврщает элемент и удаляет его из кучи
        '''
        l = self.len-1
        if l <= 0:
            return "CANNOT"
        if l == 1:
            self.len -= 1
            return self.list_Heap.pop()
        self.list_Heap[1], self.list_Heap[l] = self.list_Heap[l], self.list_Heap[1]
        self.len -= 1
        key_max = self.list_Heap.pop()
        self._key_down_(1)
        return key_max



    def Clear(self):
        '''
        сделать очередь с приоритетами пустой (если в
        очереди уже были какие-то элементы, удалить все).
        Действие происходит только с данными в памяти,
        на экран ничего не выводится.
        :return:
        '''
        self.list_Heap.clear()
        self.list_Heap = []
        self.len = 0

    def _key_down_(self, i):
        '''
        __проталкивание ключа вниз__
        Процедура восстанавливает свойства невозрастающей кучи.
        Применяется в случае когда элемент с индексом i нарушает свойство невозрастания кучи,
        при этом все остальные элементы сохраняют свойство невозрастания кучи.
        :param self.list_Heap: Массив в виде одномерного списка , в котором лежит куча
        :param i: (начинается с 1)
                индекс элемента нарушающего свойство невозрастания кучи
        :param stop_end: индекс элемента ограничевающего доступ процедуры к списку-массиву,
                    т.е. до этого элемента (включая его) функция будет востанавливать свойства кучи.
                    Этот элемент введен для осуществления сортировки, по умолчанию,
                    по умолчанию он всегда равен длине массива.
        :return: меняет массив list_Heap, ничего не возвратив.
        '''
        indx_l = 2*i
        indx_r = 2*i + 1
        indx_point = i
        stop_end = self.len - 1

        if indx_l <= stop_end and self.list_Heap[indx_l] > self.list_Heap[indx_point]:
            indx_point = indx_l
        if indx_r <= stop_end and self.list_Heap[indx_r] > self.list_Heap[indx_point]:
            indx_point = indx_r
        if indx_point != i:
            self.list_Heap[i], self.list_Heap[indx_point] = self.list_Heap[indx_point], self.list_Heap[i]
            self._key_down_(indx_point)

    def _key_up_(self, i):
        '''
        __проталкивание ключа вверх__
        Процедура восстанавливает свойства невозрастающей кучи.
        Применяется в случае когда элемент с индексом i нарушает свойство невозрастания кучи,
        при этом все остальные элементы сохраняют свойство невозрастания кучи.
        :param self.list_Heap: Массив в виде одномерного списка , в котором лежит куча
        :param i: (начинается с 1)
                индекс элемента нарушающего свойство невозрастания кучи
        :param stop_begin: индекс начального элемента ограничевающего доступ процедуры к списку-массиву,
                    т.е. до этого элемента (не включая его) функция будет востанавливать свойства кучи.
                    Этот элемент введен для осуществления сортировки, по умолчанию,
                    по умолчанию он всегда равен 1.
        :return: меняет массив list_Heap, ничего не возвратив.
        '''

        indx_parent = (i//2)
        indx_point = i
        stop_begin = 1

        if indx_parent >= stop_begin and self.list_Heap[indx_point] > self.list_Heap[indx_parent]:
            indx_point = indx_parent

        if indx_point != i:
            self.list_Heap[i], self.list_Heap[indx_point] = self.list_Heap[indx_point], self.list_Heap[i]
            self._key_up_(indx_point)




heap = Heap_Max()

# for line in fileinput.input():
#     lst = line.split()
#     lena = len(lst)
#
#     if lena >= 1: comm = lst[0].strip()
#
#     if comm == 'CLEAR': heap.Clear()
#     if comm == 'ADD' and lena >= 2:
#         n = int(lst[1].strip())
#         heap.Add(n)
#     if comm == 'EXTRACT':
#         print(heap.Extract_Max())


fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for line in fin:
        lst = line.split()
        lena = len(lst)
        comm = ''

        if lena >= 1: comm = lst[0].strip()

        if comm == 'CLEAR': heap.Clear()
        if comm == 'ADD' and lena >= 2:
            n = int(lst[1].strip())
            heap.Add(n)
        if comm == 'EXTRACT':
            print(heap.Extract_Max(), file=fout)

fout.close()
125/1: print('hello')
125/2:
graph = [[]]

n = 5
m - 8

for i in range(n):
    graph.append([])
125/3:
graph = []

n = 5
m = 8

edges = [{0, 1, 2}, {0, 1, 2}, {0, 1, 2}, {0, 1, 2}, {0, 1, 2}, {0, 1, 2} ]
127/1: print(1)
127/2: print()
127/3: print('hello')
127/4: print('hello')
127/5: print('hello')
127/6:
input = [2, 3, 1, 4, 2]

def make_partition(input, l, r):
    m = (r + l) // 2
    x = input[m]

    l_pointer = l, r_pointer = r
    while l_pointer < r_pointer:
        while input[l_pointer] < x:
            l_pointer += 1
        while input[r_pointer] > x:
            r_pointer -= 1
        input[l_pointer], input[r_pointer] = input[r_pointer], input[l_pointer]
        l_pointer += 1
        r_pointer -= 1
    
    return r_pointer

def sort (input, l, r):
    if l + 1 >= r:
        return
    partition = make_partition(input, l, r)
    sort(input, l, partition)
    sort(input, partition+1, r)
127/7:
input = [2, 3, 1, 4, 2]

def make_partition(input, l, r):
    m = (r + l) // 2
    x = input[m]

    l_pointer = l, r_pointer = r
    while l_pointer < r_pointer:
        while input[l_pointer] < x:
            l_pointer += 1
        while input[r_pointer] > x:
            r_pointer -= 1
        input[l_pointer], input[r_pointer] = input[r_pointer], input[l_pointer]
        l_pointer += 1
        r_pointer -= 1
    
    return r_pointer

def sort (input, l, r):
    if l + 1 >= r:
        return
    partition = make_partition(input, l, r)
    sort(input, l, partition)
    sort(input, partition+1, r)
127/8:
input = [2, 3, 1, 4, 2]

def make_partition(input, l, r):
    m = (r + l) // 2
    x = input[m]

    l_pointer = l, r_pointer = r
    while l_pointer < r_pointer:
        while input[l_pointer] < x:
            l_pointer += 1
        while input[r_pointer] > x:
            r_pointer -= 1
        input[l_pointer], input[r_pointer] = input[r_pointer], input[l_pointer]
        l_pointer += 1
        r_pointer -= 1
    
    return r_pointer

def sort (input, l, r):
    if l + 1 >= r:
        return
    partition = make_partition(input, l, r)
    sort(input, l, partition)
    sort(input, partition+1, r)
127/9:
input = [2, 3, 1, 4, 2]

def make_partition(input, l, r):
    m = (r + l) // 2
    x = input[m]

    l_pointer = l, r_pointer = r
    while l_pointer < r_pointer:
        while input[l_pointer] < x:
            l_pointer += 1
        while input[r_pointer] > x:
            r_pointer -= 1
        input[l_pointer], input[r_pointer] = input[r_pointer], input[l_pointer]
        l_pointer += 1
        r_pointer -= 1
    
    return r_pointer

def sort (input, l, r):
    if l + 1 >= r:
        return
    partition = make_partition(input, l, r)
    sort(input, l, partition)
    sort(input, partition+1, r)
127/10:
input = [2, 3, 1, 4, 2]

def make_partition(input, l, r):
    m = (r + l) // 2
    x = input[m]

    l_pointer = l, r_pointer = r
    while l_pointer < r_pointer:
        while input[l_pointer] < x:
            l_pointer += 1
        while input[r_pointer] > x:
            r_pointer -= 1
        input[l_pointer], input[r_pointer] = input[r_pointer], input[l_pointer]
        l_pointer += 1
        r_pointer -= 1
    
    return r_pointer

def sort (input, l, r):
    if l + 1 >= r:
        return
    partition = make_partition(input, l, r)
    sort(input, l, partition)
    sort(input, partition+1, r)
127/11:
input = [2, 3, 1, 4, 2]

def make_partition(input, l, r):
    m = (r + l) // 2
    x = input[m]

    l_pointer = l
    r_pointer = r
    while l_pointer < r_pointer:
        while input[l_pointer] < x:
            l_pointer += 1
        while input[r_pointer] > x:
            r_pointer -= 1
        input[l_pointer], input[r_pointer] = input[r_pointer], input[l_pointer]
        l_pointer += 1
        r_pointer -= 1
    
    return r_pointer

def sort (input, l, r):
    if l + 1 >= r:
        return
    partition = make_partition(input, l, r)
    sort(input, l, partition)
    sort(input, partition+1, r)

sort(input, 0, len(input) - 1)
print(input)
127/12:
input = [2, 3, 1, 4, 2]

def make_partition(input, l, r):
    m = (r + l) // 2
    x = input[m]


    l_pointer = l
    r_pointer = r
    while l_pointer < r_pointer:
        while input[l_pointer] < x:
            l_pointer += 1
        while input[r_pointer] > x:
            r_pointer -= 1
        input[l_pointer], input[r_pointer] = input[r_pointer], input[l_pointer]
        l_pointer += 1
        r_pointer -= 1
    
    return r_pointer

def sort (input, l, r):
    if l + 1 >= r:
        return
    partition = make_partition(input, l, r)
    sort(input, l, partition)
    sort(input, partition+1, r)

sort(input, 0, len(input) - 1)
print(input)
127/13:
input = [2, 3, 1, 4, 2]

def make_partition(input, l, r):
    m = (r + l) // 2
    x = input[m]

    l_pointer = l
    r_pointer = r
    while l_pointer < r_pointer:
        while input[l_pointer] < x:
            l_pointer += 1
        while input[r_pointer] > x:
            r_pointer -= 1
        input[l_pointer], input[r_pointer] = input[r_pointer], input[l_pointer]
        l_pointer += 1
        r_pointer -= 1
    
    return r_pointer

def sort (input, l, r):
    if l + 1 > r:
        return
    partition = make_partition(input, l, r)
    sort(input, l, partition)
    sort(input, partition+1, r)

sort(input, 0, len(input) - 1)
print(input)
127/14:
input = [2, 3, 1, 4, 2]

def make_partition(input, l, r):
    m = (r + l) // 2
    x = input[m]

    l_pointer = l
    r_pointer = r
    while l_pointer < r_pointer:
        while input[l_pointer] < x:
            l_pointer += 1
        while input[r_pointer] > x:
            r_pointer -= 1
        input[l_pointer], input[r_pointer] = input[r_pointer], input[l_pointer]
        l_pointer += 1
        r_pointer -= 1
    
    return r_pointer

def sort (input, l, r):
    if l + 1 >= r:
        return
    partition = make_partition(input, l, r)
    sort(input, l, partition)
    sort(input, partition+1, r)

sort(input, 0, len(input) - 1)
print(input)
127/15:
input = [2, 3, 1, 4, 2]

def make_partition(input, l, r):
    m = (r + l) // 2
    x = input[m]

    l_pointer = l
    r_pointer = r
    while l_pointer < r_pointer:
        while input[l_pointer] < x:
            l_pointer += 1
        while input[r_pointer] > x:
            r_pointer -= 1
        input[l_pointer], input[r_pointer] = input[r_pointer], input[l_pointer]
        l_pointer += 1
        r_pointer -= 1
    
    return l_pointer
    

def sort (input, l, r):
    if l + 1 > r:
        return
    partition = make_partition(input, l, r)
    sort(input, l, partition)
    sort(input, partition+1, r)

sort(input, 0, len(input) - 1)
print(input)
127/16:
input = [2, 3, 1, 4, 2]

def make_partition(input, l, r):
    m = (r + l) // 2
    x = input[m]

    l_pointer = l
    r_pointer = r
    while l_pointer < r_pointer:
        while input[l_pointer] < x:
            l_pointer += 1
        while input[r_pointer] > x:
            r_pointer -= 1
        input[l_pointer], input[r_pointer] = input[r_pointer], input[l_pointer]
        l_pointer += 1
        r_pointer -= 1
    
    return l_pointer
    

def sort (input, l, r):
    if l + 1 > r:
        return
    partition = make_partition(input, l, r)
    sort(input, l, partition -1)
    sort(input, partition+1, r)

sort(input, 0, len(input) - 1)
print(input)
129/1:
import random

array = [int(x) for x in input().split()]

def partition(arr, start, end):
    pivot = random.choice(arr)

    low = start
    high = end
    while low <= high:
        while arr[high] >= pivot:
            high -= 1
        while arr[low] <= pivot:
            low += 1
        if low <= high:
            array[low], array[high] = array[high], array[low]
        else:
            break
    array[start], array[high] = array[high], array[start]
    return high

def quick_sort(arr, start, end):
    if start >= end:
        return

    p = partition(arr, start, end)
    quick_sort(arr, start, p-1)
    quick_sort(arr, p+1, end)
129/2:
import random

array = [int(x) for x in input().split()]

def partition(arr, start, end):
    pivot = random.choice(arr)

    low = start
    high = end
    while low <= high:
        while arr[high] >= pivot:
            high -= 1
        while arr[low] <= pivot:
            low += 1
        if low <= high:
            array[low], array[high] = array[high], array[low]
        else:
            break
    array[start], array[high] = array[high], array[start]
    return high

def quick_sort(arr, start, end):
    if start >= end:
        return

    p = partition(arr, start, end)
    quick_sort(arr, start, p-1)
    quick_sort(arr, p+1, end)

quick_sort(array, 0, len(array) - 1)
print(array)
129/3:
import random

array = [int(x) for x in input().split()]

def partition(arr, start, end):
    pivot = random.choice(arr)

    low = start
    high = end
    while low <= high:
        while arr[high] >= pivot:
            high -= 1
        while arr[low] <= pivot:
            low += 1
        if low <= high:
            array[low], array[high] = array[high], array[low]
        else:
            break
    array[start], array[high] = array[high], array[start]
    return high

def quick_sort(arr, start, end):
    if start >= end:
        return

    p = partition(arr, start, end)
    quick_sort(arr, start, p-1)
    quick_sort(arr, p+1, end)

quick_sort(array, 0, len(array) - 1)
print(array)
129/4:
import random

array = [int(x) for x in input().split()]

def partition(arr, start, end):
    pivot = random.choice(arr)

    low = start
    high = end
    print('arr', arr)
    print('low', low)
    print('high', high)
    while low <= high:
        while arr[high] >= pivot:
            high -= 1
        while arr[low] <= pivot:
            low += 1
        if low <= high:
            array[low], array[high] = array[high], array[low]
        else:
            break
    array[start], array[high] = array[high], array[start]
    return high

def quick_sort(arr, start, end):
    if start > end:
        return

    p = partition(arr, start, end)
    quick_sort(arr, start, p-1)
    quick_sort(arr, p+1, end)

quick_sort(array, 0, len(array) - 1)
print(array)
129/5:
import random

array = [int(x) for x in input().split()]

def partition(arr, start, end):
    pivot = random.choice(arr)

    low = start
    high = end
    print('arr', arr)
    print('low', low)
    print('high', high)
    while low <= high:
        while arr[high] > pivot:
            high -= 1
        while arr[low] < pivot:
            low += 1
        if low <= high:
            array[low], array[high] = array[high], array[low]
        else:
            break
    array[start], array[high] = array[high], array[start]
    return high

def quick_sort(arr, start, end):
    if start > end:
        return

    p = partition(arr, start, end)
    quick_sort(arr, start, p-1)
    quick_sort(arr, p+1, end)

quick_sort(array, 0, len(array) - 1)
print(array)
129/6:
import random

array = [int(x) for x in input().split()]

def pivot(array, start, end):
    
#initializing 
    pivot = array[start]
    low = start + 1
    high = end


    while True:
  
#moving high towards left
        while low <= high and array[high] >= pivot:
            high = high - 1

#moving low towards right 
        while low <= high and array[low] <= pivot:
            low = low + 1

#checking if low and high have crossed
        if low <= high:

#swapping values to rearrange
            array[low], array[high] = array[high], array[low]
         
        else:
#breaking out of the loop if low > high
            break

#swapping pivot with high so that pivot is at its right # #position 
    array[start], array[high] = array[high], array[start]

#returning pivot position
    return high


def quick_sort(array, start, end):
    if start >= end:
        return

#call pivot 
    p = pivot(array, start, end)
#recursive call on left half
    quick_sort(array, start, p-1)
#recursive call on right half
    quick_sort(array, p+1, end)

quick_sort(array, 0, len(array) - 1)
print(array)
129/7:
import random

array = [int(x) for x in input().split()]

def pivot(array, start, end):
    
#initializing 
    pivot = array[start]
    low = start + 1
    high = end


    while True:
  
#moving high towards left
        while low <= high and array[high] >= pivot:
            high = high - 1

#moving low towards right 
        while low <= high and array[low] <= pivot:
            low = low + 1

#checking if low and high have crossed
        if low <= high:

#swapping values to rearrange
            array[low], array[high] = array[high], array[low]
         
        else:
#breaking out of the loop if low > high
            break

#swapping pivot with high so that pivot is at its right # #position 
    array[start], array[high] = array[high], array[start]

#returning pivot position
    return high


def quick_sort(array, start, end):
    if start >= end:
        return

#call pivot 
    p = pivot(array, start, end)
#recursive call on left half
    quick_sort(array, start, p-1)
#recursive call on right half
    quick_sort(array, p+1, end)

quick_sort(array, 0, len(array) - 1)
print(array)
130/1:
array = [int(x) for x in input().split()]

d = dict.fromkeys((range(100)))

def count_sort(array):
   pass

count_sort(array)
print(d)
130/2:
array = [int(x) for x in input().split()]

d = dict.fromkeys((range(100)))

def count_sort(array):
   for i in array:
       d[i] += 1

count_sort(array)
print(d)
130/3:
array = [int(x) for x in input().split()]

d = dict.fromkeys((range(100)))

def count_sort(array):
   for i in array:
       d[i] = int(0 if d[i] is None else d[i] + 1)

count_sort(array)
print(d)
130/4:
array = [int(x) for x in input().split()]

d = dict.fromkeys((range(100)), 0)

def count_sort(array):
   for i in array:
       d[i] += 1

count_sort(array)
print(d)
130/5:
array = [int(x) for x in input().split()]

d = dict.fromkeys((range(100)), 0)

def count_sort(array):
   for i in array:
       d[i] += 1

count_sort(array)
for key in d.keys():
    if d[key] != 0:
        print(key)
130/6:
array = [int(x) for x in input().split()]

d = dict.fromkeys((range(100)), 0)

def count_sort(array):
   for i in array:
       d[i] += 1

count_sort(array)
for key in d.keys():
    if d[key] != 0:
        print(key, sep=' ')
130/7:
array = [int(x) for x in input().split()]

d = dict.fromkeys((range(100)), 0)

def count_sort(array):
   for i in array:
       d[i] += 1

count_sort(array)
for key in d.keys():
    if d[key] != 0:
        print(key, end=' ')
130/8:
array = [int(x) for x in input().split()]

d = dict.fromkeys((range(100)), 0)

def count_sort(array):
   for i in array:
       d[i] += 1

count_sort(array)
for key in d.keys():
    if d[key] != 0:
        print(key, end=' ')
130/9:
array = [int(x) for x in input().split()]

d = dict.fromkeys((range(100)), 0)

def count_sort(array):
   for i in array:
       d[i] += 1

count_sort(array)
for key, value in d.items():
    if value != 0:
        for i in range(value):
            print(key, end=' ')
130/10:
array = [int(x) for x in input().split()]

def count_sort(arr):
    size = len(arr)
    output = [0] * size
    count = [0] * 100

    for m in range(0, size):
        count[arr[m]] += 1

    for m in range(1, 100):
        count[m] += count[m - 1]
    m = size - 1
    while m >= 0:
        output[count[arr[m]] - 1] = arr[m]
        count[arr[m]] -= 1
        m -= 1

    for m in range(0, size):
        arr[m] = output[m]


print(count_sort(array))
130/11:
array = [int(x) for x in input().split()]

def count_sort(arr):
    size = len(arr)
    output = [0] * size
    count = [0] * 100

    for m in range(0, size):
        count[arr[m]] += 1

    for m in range(1, 100):
        count[m] += count[m - 1]
    m = size - 1
    while m >= 0:
        output[count[arr[m]] - 1] = arr[m]
        count[arr[m]] -= 1
        m -= 1

    for m in range(0, size):
        arr[m] = output[m]
    return arr


print(count_sort(array))
130/12:
array = [int(x) for x in input().split()]

def count_sort(arr):
    size = len(arr)
    output = [0] * size
    count = [0] * 100

    for m in range(0, size):
        count[arr[m]] += 1

    for m in range(1, 100):
        count[m] += count[m - 1]
    m = size - 1
    while m >= 0:
        output[count[arr[m]] - 1] = arr[m]
        count[arr[m]] -= 1
        m -= 1

    for m in range(0, size):
        print(output[m])


print(count_sort(array))
130/13:
array = [int(x) for x in input().split()]

def count_sort(arr):
    size = len(arr)
    output = [0] * size
    count = [0] * 100

    for m in range(0, size):
        count[arr[m]] += 1

    for m in range(1, 100):
        count[m] += count[m - 1]
    m = size - 1
    while m >= 0:
        output[count[arr[m]] - 1] = arr[m]
        count[arr[m]] -= 1
        m -= 1

    for m in range(0, size -1):
        print(output[m])


print(count_sort(array))
130/14:
array = [int(x) for x in input().split()]

def count_sort(arr):
    size = len(arr)
    output = [0] * size
    count = [0] * 100

    for m in range(0, size):
        count[arr[m]] += 1

    for m in range(1, 100):
        count[m] += count[m - 1]
    m = size - 1
    while m >= 0:
        output[count[arr[m]] - 1] = arr[m]
        count[arr[m]] -= 1
        m -= 1

    for m in range(0, size -1):
        print(output[m])


print(count_sort(array))
130/15:
array = [int(x) for x in input().split()]

def count_sort(arr):
    size = len(arr)
    output = [0] * size
    count = [0] * 100

    for m in range(0, size):
        count[arr[m]] += 1

    for m in range(1, 100):
        count[m] += count[m - 1]
    m = size - 1
    while m >= 0:
        output[count[arr[m]] - 1] = arr[m]
        count[arr[m]] -= 1
        m -= 1

    for m in range(0, size):
        arr[m] = output[m]
    return arr

res = count_sort(array)
print(*res)
130/16:
array = [int(x) for x in input().split()]

def count_sort(arr):
    size = len(arr)
    output = [0] * size
    count = [0] * 100

    for m in range(0, size):
        count[arr[m]] += 1

    for m in range(1, 100):
        count[m] += count[m - 1]
    m = size - 1
    while m >= 0:
        output[count[arr[m]] - 1] = arr[m]
        count[arr[m]] -= 1
        m -= 1

    for m in range(0, size):
        arr[m] = output[m]
    return arr

res = count_sort(array)
print(*res)
130/17:
array = [int(x) for x in input().split()]

def count_sort(arr):
    size = len(arr)
    output = [0] * size
    count = [0] * 100

    for m in range(0, size):
        count[arr[m]] += 1

    for m in range(1, 100):
        count[m] += count[m - 1]
    m = size - 1
    while m >= 0:
        output[count[arr[m]] - 1] = arr[m]
        count[arr[m]] -= 1
        m -= 1

    for m in range(0, size):
        arr[m] = output[m]
    return arr

res = count_sort(array)
print(*res)
130/18:
array = [int(x) for x in input().split()]

def countingSort(inputArray):

    maxElement= max(inputArray)

    countArrayLength = maxElement+1
    countArray = [0] * countArrayLength
    for el in inputArray: 
        countArray[el] += 1

    for i in range(1, countArrayLength):
        countArray[i] += countArray[i-1] 
        
    outputArray = [0] * len(inputArray)
    i = len(inputArray) - 1
    while i >= 0:
        currentEl = inputArray[i]
        countArray[currentEl] -= 1
        newPosition = countArray[currentEl]
        outputArray[newPosition] = currentEl
        i -= 1

    return outputArray

sortedArray = countingSort(array)
for i in sortedArray:
    print(i, end =" ")
130/19:
array = [int(x) for x in input().split()]

def countingSort(inputArray):

    maxElement= max(inputArray)

    countArrayLength = maxElement+1
    countArray = [0] * countArrayLength
    for el in inputArray: 
        countArray[el] += 1

    for i in range(1, countArrayLength):
        countArray[i] += countArray[i-1] 
        
    outputArray = [0] * len(inputArray)
    i = len(inputArray) - 1
    while i >= 0:
        currentEl = inputArray[i]
        countArray[currentEl] -= 1
        newPosition = countArray[currentEl]
        outputArray[newPosition] = currentEl
        i -= 1

    return outputArray

sortedArray = countingSort(array)
for i in sortedArray:
    print(i, end =" ")
130/20:
array = [int(x) for x in input().split()]

maxElement= max(array)
d = dict.fromkeys((range(maxElement + 1)), 0)

def count_sort(array):
   for i in array:
       d[i] += 1

count_sort(array)
for key, value in d.items():
    if value != 0:
        for i in range(value):
            print(key, end=' ')
131/1:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    m = len(inp) // 2
    left = merge_sort(inp[:m + 1])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

input = [2, 3, 1, 4, 2]
merge_sort(input)
131/2:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

input = [2, 3, 1, 4, 2]
merge_sort(input)
134/1:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}
fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for line in fin:
        print(line)
134/2:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}
fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            print('x y', x, y)
134/3:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d[math.sqrt(x**2 + y**2)] = f'{x} {y}'

    print(d)
134/4:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d[math.sqrt(x**2 + y**2)] = f'{x} {y}'

keylist = merge_sort(d.keys())
for key in keylist:
    print(d[key])

fout.close()
134/5:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d[math.sqrt(x**2 + y**2)] = f'{x} {y}'

keylist = merge_sort(d.keys())
for key in keylist:
    print(d[key])

fout.close()
134/6:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d[math.sqrt(x**2 + y**2)] = f'{x} {y}'
print(d.keys())
keylist = merge_sort(d.keys())
for key in keylist:
    print(d[key])

fout.close()
134/7:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    print(inp)
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d[math.sqrt(x**2 + y**2)] = f'{x} {y}'
            
keylist = merge_sort(d.keys())
for key in keylist:
    print(d[key])

fout.close()
134/8:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    print(inp)
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d[math.sqrt(x**2 + y**2)] = f'{x} {y}'
            
keylist = merge_sort(d.keys())
for key in keylist:
    print(d[key])

fout.close()
134/9:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    print('inp', inp)
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d[math.sqrt(x**2 + y**2)] = f'{x} {y}'

keylist = merge_sort(d.keys())
for key in keylist:
    print(d[key])

fout.close()
134/10:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d[math.sqrt(x**2 + y**2)] = f'{x} {y}'

keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])

fout.close()
134/11:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d[math.sqrt(x**2 + y**2)] = f'{x} {y}'

keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])

fout.close()
134/12:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d[math.sqrt(x**2 + y**2)] = f'{x} {y}'
print('d', d)
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])

fout.close()
134/13:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d[math.sqrt(x**2 + y**2)] = f'{x} {y}'
print('d', d)
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])

fout.close()
134/14:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} /n {x} {y}'
            else:
                d[key] = f'{x} {y}'
print('d', d)
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])

fout.close()
134/15:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} /n {x} {y}'
            else:
                d[key] = f'{x} {y}'
print('d', d)
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])

fout.close()
134/16:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n {x} {y}'
            else:
                d[key] = f'{x} {y}'
print('d', d)
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])

fout.close()
134/17:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
print('d', d)
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])

fout.close()
134/18:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
print('d', d)
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])

fout.close()
134/19:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
print('d', d)
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])

fout.close()
134/20:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])

fout.close()
134/21:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1

def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])

fout.close()
134/22:
array = [int(x) for x in input().split()]

maxElement= max(array)
new_dict = dict.fromkeys((range(maxElement + 1)), 0)

def count_sort(array):
   for i in array:
       new_dict[i] += 1


import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
count_sort(list(d.keys()))
for key in new_dict:
    print(d[key])

fout.close()
134/23:
def count_sort(array):
   maxElement= max(array)
   new_dict = dict.fromkeys((range(maxElement + 1)), 0)
   
   for i in array:
       new_dict[i] += 1

    return new_dict

import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
sorted = count_sort(list(d.keys()))
for key in sorted:
    print(d[key])

fout.close()
134/25:
def count_sort(array):
   maxElement = max(array)
   new_dict = dict.fromkeys((range(maxElement + 1)), 0)
   for i in array:
       new_dict[i] += 1
   return new_dict


import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
sorted = count_sort(list(d.keys()))
for key in sorted:
    print(d[key])

fout.close()
134/26:
def count_sort(array):
   maxElement = max(array)
   new_dict = dict.fromkeys((range(int(maxElement) + 1)), 0)
   for i in array:
       new_dict[i] += 1
   return new_dict


import math

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
sorted = count_sort(list(d.keys()))
for key in sorted:
    print(d[key])

fout.close()
134/27:
import math

def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp


d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])

fout.close()
134/28:
import math

def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp


d = {}

with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])
134/29:
import math

def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp


d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)

fout.close()
134/30:
def heapify(arr, n, i):
    largest = i  # Initialize largest as root
    l = 2 * i + 1     # left = 2*i + 1
    r = 2 * i + 2     # right = 2*i + 2

    # See if left child of root exists and is
    # greater than root
    if l < n and arr[largest] < arr[l]:
        largest = l

    # See if right child of root exists and is
    # greater than root
    if r < n and arr[largest] < arr[r]:
        largest = r

    # Change root, if needed
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # swap

        # Heapify the root.
        heapify(arr, n, largest)

# The main function to sort an array of given size


def heapSort(arr):
    n = len(arr)

    # Build a maxheap.
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

    # One by one extract elements
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # swap
        heapify(arr, i, 0)
 

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
heapSort(list(d.keys()))
for key in d:
    print(d[key])

fout.close()
134/31:
def heapify(arr, n, i):
    largest = i  # Initialize largest as root
    l = 2 * i + 1     # left = 2*i + 1
    r = 2 * i + 2     # right = 2*i + 2

    # See if left child of root exists and is
    # greater than root
    if l < n and arr[largest] < arr[l]:
        largest = l

    # See if right child of root exists and is
    # greater than root
    if r < n and arr[largest] < arr[r]:
        largest = r

    # Change root, if needed
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # swap

        # Heapify the root.
        heapify(arr, n, largest)

# The main function to sort an array of given size


def heapSort(arr):
    n = len(arr)

    # Build a maxheap.
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

    # One by one extract elements
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # swap
        heapify(arr, i, 0)
 

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
heapSort(list(d.keys()))
for key in d:
    print(d[key])

fout.close()
134/32:
def heapify(arr, n, i):
    largest = i  # Initialize largest as root
    l = 2 * i + 1     # left = 2*i + 1
    r = 2 * i + 2     # right = 2*i + 2

    # See if left child of root exists and is
    # greater than root
    if l < n and arr[largest] < arr[l]:
        largest = l

    # See if right child of root exists and is
    # greater than root
    if r < n and arr[largest] < arr[r]:
        largest = r

    # Change root, if needed
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # swap

        # Heapify the root.
        heapify(arr, n, largest)

# The main function to sort an array of given size


def heapSort(arr):
    n = len(arr)

    # Build a maxheap.
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

    # One by one extract elements
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # swap
        heapify(arr, i, 0)
 

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
heapSort(list(d.keys()))
for key in d:
    print(d[key])

fout.close()
134/33:
def heapify(arr, n, i):
    largest = i  # Initialize largest as root
    l = 2 * i + 1     # left = 2*i + 1
    r = 2 * i + 2     # right = 2*i + 2

    # See if left child of root exists and is
    # greater than root
    if l < n and arr[largest] < arr[l]:
        largest = l

    # See if right child of root exists and is
    # greater than root
    if r < n and arr[largest] < arr[r]:
        largest = r

    # Change root, if needed
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # swap

        # Heapify the root.
        heapify(arr, n, largest)

# The main function to sort an array of given size


def heapSort(arr):
    n = len(arr)

    # Build a maxheap.
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

    # One by one extract elements
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # swap
        heapify(arr, i, 0)
 

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
heapSort(list(d.keys()))
for key in d:
    print(d[key])

fout.close()
134/34:
def heapify(arr, n, i):
    largest = i  # Initialize largest as root
    l = 2 * i + 1     # left = 2*i + 1
    r = 2 * i + 2     # right = 2*i + 2

    # See if left child of root exists and is
    # greater than root
    if l < n and arr[largest] < arr[l]:
        largest = l

    # See if right child of root exists and is
    # greater than root
    if r < n and arr[largest] < arr[r]:
        largest = r

    # Change root, if needed
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # swap

        # Heapify the root.
        heapify(arr, n, largest)

# The main function to sort an array of given size


def heapSort(arr):
    n = len(arr)

    # Build a maxheap.
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

    # One by one extract elements
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # swap
        heapify(arr, i, 0)
 

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
heapSort(list(d.keys()))
for key in d:
    print(d[key])

fout.close()
134/35:
def heapify(arr, n, i):
    largest = i  # Initialize largest as root
    l = 2 * i + 1     # left = 2*i + 1
    r = 2 * i + 2     # right = 2*i + 2

    # See if left child of root exists and is
    # greater than root
    if l < n and arr[largest] < arr[l]:
        largest = l

    # See if right child of root exists and is
    # greater than root
    if r < n and arr[largest] < arr[r]:
        largest = r

    # Change root, if needed
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # swap

        # Heapify the root.
        heapify(arr, n, largest)

# The main function to sort an array of given size


def heapSort(arr):
    n = len(arr)

    # Build a maxheap.
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

    # One by one extract elements
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # swap
        heapify(arr, i, 0)
 

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
heapSort(list(d.keys()))
for key in d:
    print(d[key], file=fout)

fout.close()
134/36:
def heapify(arr, n, i):
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2

    if l < n and arr[largest] < arr[l]:
        largest = l

    if r < n and arr[largest] < arr[r]:
        largest = r

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # swap
        heapify(arr, n, largest)


def heapSort(arr):
    n = len(arr)
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # swap
        heapify(arr, i, 0)
    return arr


fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keys = heapSort(list(d.keys()))
for key in d:
    print(d[key], file=fout)

fout.close()
134/37:
def heapify(arr, n, i):
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2

    if l < n and arr[largest] < arr[l]:
        largest = l

    if r < n and arr[largest] < arr[r]:
        largest = r

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # swap
        heapify(arr, n, largest)


def heapSort(arr):
    n = len(arr)
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # swap
        heapify(arr, i, 0)
    return arr


fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keys = heapSort(list(d.keys()))
for key in d:
    print(d[key], file=fout)

fout.close()
134/38:
def heapify(arr, n, i):
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2

    if l < n and arr[largest] < arr[l]:
        largest = l

    if r < n and arr[largest] < arr[r]:
        largest = r

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # swap
        heapify(arr, n, largest)


def heapSort(arr):
    n = len(arr)
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # swap
        heapify(arr, i, 0)
    return arr


fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keys = heapSort(list(d.keys()))
for key in d:
    print(d[key], file=fout)

fout.close()
134/39:
def heapify(arr, n, i):
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2

    if l < n and arr[largest] < arr[l]:
        largest = l

    if r < n and arr[largest] < arr[r]:
        largest = r

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # swap
        heapify(arr, n, largest)


def heapSort(arr):
    n = len(arr)
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # swap
        heapify(arr, i, 0)
    return arr


fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keys = heapSort(list(d.keys()))
for key in d:
    print(d[key], file=fout)

fout.close()
134/40:
def heapify(arr, n, i):
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2

    if l < n and arr[largest] < arr[l]:
        largest = l

    if r < n and arr[largest] < arr[r]:
        largest = r

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # swap
        heapify(arr, n, largest)


def heapSort(arr):
    n = len(arr)
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # swap
        heapify(arr, i, 0)


fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keys = list(d.keys())
heapSort(keys)
for key in d:
    print(d[key], file=fout)

fout.close()
134/41:
def heapify(arr, n, i):
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2

    if l < n and arr[largest] < arr[l]:
        largest = l

    if r < n and arr[largest] < arr[r]:
        largest = r

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # swap
        heapify(arr, n, largest)


def heapSort(arr):
    n = len(arr)
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # swap
        heapify(arr, i, 0)


fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keys = list(d.keys())
heapSort(keys)
for key in d:
    print(d[key], file=fout)

fout.close()
134/42:
def partition(start, end, array):
    
    # Initializing pivot's index to start
    pivot_index = start 
    pivot = array[pivot_index]
    
    # This loop runs till start pointer crosses 
    # end pointer, and when it does we swap the
    # pivot with element on end pointer
    while start < end:
        
        # Increment the start pointer till it finds an 
        # element greater than  pivot 
        while start < len(array) and array[start] <= pivot:
            start += 1
            
        # Decrement the end pointer till it finds an 
        # element less than pivot
        while array[end] > pivot:
            end -= 1
        
        # If start and end have not crossed each other, 
        # swap the numbers on start and end
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    # Swap pivot element with element on end pointer.
    # This puts pivot on its correct sorted place.
    array[end], array[pivot_index] = array[pivot_index], array[end]
   
    # Returning end pointer to divide the array into 2
    return end
    
# The main function that implements QuickSort 
def quick_sort(start, end, array):
    
    if (start < end):
        
        # p is partitioning index, array[p] 
        # is at right place
        p = partition(start, end, array)
        
        # Sort elements before partition 
        # and after partition
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)


fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) - 1, arr)
for key in arr:
    print(d[key], file=fout)

fout.close()
134/43:
def partition(start, end, array):
    
    # Initializing pivot's index to start
    pivot_index = start 
    pivot = array[pivot_index]
    
    # This loop runs till start pointer crosses 
    # end pointer, and when it does we swap the
    # pivot with element on end pointer
    while start < end:
        
        # Increment the start pointer till it finds an 
        # element greater than  pivot 
        while start < len(array) and array[start] <= pivot:
            start += 1
            
        # Decrement the end pointer till it finds an 
        # element less than pivot
        while array[end] > pivot:
            end -= 1
        
        # If start and end have not crossed each other, 
        # swap the numbers on start and end
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    # Swap pivot element with element on end pointer.
    # This puts pivot on its correct sorted place.
    array[end], array[pivot_index] = array[pivot_index], array[end]
   
    # Returning end pointer to divide the array into 2
    return end
    
# The main function that implements QuickSort 
def quick_sort(start, end, array):
    
    if (start < end):
        
        # p is partitioning index, array[p] 
        # is at right place
        p = partition(start, end, array)
        
        # Sort elements before partition 
        # and after partition
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)


fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) - 1, arr)
for key in arr:
    print(d[key], file=fout)

fout.close()
134/44:
import math


def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp


d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)

fout.close()
134/45:
import random
import math


def partition(arr, start, end):
    pivot_index = random.randrange(start, end)
    pivot = arr[pivot_index]
    arr[pivot_index], arr[start] = arr[start], arr[pivot_index]
    i = start + 1
    for j in range(start+1, end+1):
        if arr[j] < pivot:
            arr[i], arr[j] = arr[j], arr[i]
        i += 1
    arr[start], arr[i-1] = arr[i-1], arr[start]
    return i-1


def quicksort(arr, start, end):
    if start < end:
        split = partition(arr, start, end)
        quicksort(arr, start, split-1)
        quicksort(arr, split+1, end)
    return arr


fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            d[key] = f'{x} {y}'

arr = quicksort(list(d.keys()), 0, len(list(d.keys())) - 1)
for key in arr:
    print(d[key], file=fout)

fout.close()
134/46:
import random
import math


def partition(arr, start, end):
    pivot_index = random.randrange(start, end)
    pivot = arr[pivot_index]
    arr[pivot_index], arr[start] = arr[start], arr[pivot_index]
    i = start + 1
    for j in range(start+1, end+1):
        if arr[j] < pivot:
            arr[i], arr[j] = arr[j], arr[i]
        i += 1
    arr[start], arr[i-1] = arr[i-1], arr[start]
    return i-1


def quicksort(arr, start, end):
    if start < end:
        split = partition(arr, start, end)
        quicksort(arr, start, split-1)
        quicksort(arr, split+1, end)
    return arr


fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'

arr = quicksort(list(d.keys()), 0, len(list(d.keys())) - 1)
for key in arr:
    print(d[key], file=fout)

fout.close()
134/47:
import random
import math


def partition(arr, start, end):
    pivot_index = random.randrange(start, end)
    pivot = arr[pivot_index]
    arr[pivot_index], arr[start] = arr[start], arr[pivot_index]
    i = start + 1
    for j in range(start+1, end+1):
        if arr[j] < pivot:
            arr[i], arr[j] = arr[j], arr[i]
        i += 1
    arr[start], arr[i-1] = arr[i-1], arr[start]
    return i-1


def quicksort(arr, start, end):
    if start < end:
        split = partition(arr, start, end)
        quicksort(arr, start, split-1)
        quicksort(arr, split+1, end)
    return arr


fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'

arr = quicksort(list(d.keys()), 0, len(list(d.keys())) - 1)
for key in arr:
    print(d[key], file=fout)

fout.close()
134/48:
import math


def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)
    

fout.close()
134/49:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)


fout.close()
134/50:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)


fout.close()
134/51:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)


fout.close()
134/52:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)


fout.close()
134/53:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            print(line)
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)


fout.close()
134/54:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)


fout.close()
134/55:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)


fout.close()
134/56:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)


fout.close()
134/57:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)


fout.close()
134/58:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)


fout.close()
134/59:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)


fout.close()
134/60:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)


fout.close()
134/61:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)


fout.close()
134/62:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)


fout.close()
134/63:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)


fout.close()
134/64:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)


fout.close()
134/65:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
# keylist = sorted(d)
for k, v in od.items(): 
    print(k, v)
    # print(d[key], file=fout)


fout.close()
134/66:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
# keylist = sorted(d)
for k, v in k.items(): 
    print(k, v)
    # print(d[key], file=fout)


fout.close()
134/67:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
# keylist = sorted(d)
for k, v in d.items(): 
    print(k, v)
    # print(d[key], file=fout)


fout.close()
134/68:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
# keylist = sorted(d)
for k, v in d.items(): 
    print(v)
    # print(d[key], file=fout)


fout.close()
134/69:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
# keylist = sorted(d)
for k, v in sorted(d.items()): 
    print(v)
    # print(d[key], file=fout)


fout.close()
134/70:
import random
import math

def insertionSort(b):
    for i in range(1, len(b)):
        up = b[i]
        j = i - 1
        while j >= 0 and b[j] > up:
            b[j + 1] = b[j]
            j -= 1
        b[j + 1] = up    
    return b    
             
def bucketSort(x):
    arr = []
    slot_num = 10 # 10 means 10 slots, each
                  # slot's size is 0.1
    for i in range(slot_num):
        arr.append([])
         
    # Put array elements in different buckets
    for j in x:
        index_b = int(slot_num * j)
        arr[index_b].append(j)
     
    # Sort individual buckets
    for i in range(slot_num):
        arr[i] = insertionSort(arr[i])
         
    # concatenate the result
    k = 0
    for i in range(slot_num):
        for j in range(len(arr[i])):
            x[k] = arr[i][j]
            k += 1
    return x

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'

arr = bucketSort(list(d.keys()))
for key in arr:
    print(d[key], file=fout)

fout.close()
134/71:
import random
import math

def mergeSort(arr):
    if len(arr) > 1:

         # Finding the mid of the array
        mid = len(arr)//2

        # Dividing the array elements
        L = arr[:mid]

        # into 2 halves
        R = arr[mid:]

        # Sorting the first half
        mergeSort(L)

        # Sorting the second half
        mergeSort(R)

        i = j = k = 0

        # Copy data to temp arrays L[] and R[]
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1

        # Checking if any element was left
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1

        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1


fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'

arr = list(d.keys())
mergeSort(arr)
for key in arr:
    print(d[key], file=fout)

fout.close()
134/72:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
# keylist = sorted(d)
for k, v in sorted(d.items()): 
    print(v)
    # print(d[key], file=fout)


fout.close()
134/73:
import math
def mergeSort(arr):
    if len(arr) > 1:

         # Finding the mid of the array
        mid = len(arr)//2

        # Dividing the array elements
        L = arr[:mid]

        # into 2 halves
        R = arr[mid:]

        # Sorting the first half
        mergeSort(L)

        # Sorting the second half
        mergeSort(R)

        i = j = k = 0

        # Copy data to temp arrays L[] and R[]
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1

        # Checking if any element was left
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1

        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
arr = list(d.keys())
mergeSort(arr)
for key in keylist:
    print(d[key], file=fout)


fout.close()
134/74:
import math
def mergeSort(arr):
    if len(arr) > 1:

         # Finding the mid of the array
        mid = len(arr)//2

        # Dividing the array elements
        L = arr[:mid]

        # into 2 halves
        R = arr[mid:]

        # Sorting the first half
        mergeSort(L)

        # Sorting the second half
        mergeSort(R)

        i = j = k = 0

        # Copy data to temp arrays L[] and R[]
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1

        # Checking if any element was left
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1

        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
arr = list(d.keys())
mergeSort(arr)
for key in arr:
    print(d[key], file=fout)


fout.close()
134/75:
import math
def mergeSort(arr):
    if len(arr) > 1:

         # Finding the mid of the array
        mid = len(arr)//2

        # Dividing the array elements
        L = arr[:mid]

        # into 2 halves
        R = arr[mid:]

        # Sorting the first half
        mergeSort(L)

        # Sorting the second half
        mergeSort(R)

        i = j = k = 0

        # Copy data to temp arrays L[] and R[]
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1

        # Checking if any element was left
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1

        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
arr = list(d.keys())
mergeSort(arr)
for key in arr:
    print(d[key], file=fout)


fout.close()
134/76:
import math
def mergeSort(arr):
    if len(arr) > 1:

         # Finding the mid of the array
        mid = len(arr)//2

        # Dividing the array elements
        L = arr[:mid]

        # into 2 halves
        R = arr[mid:]

        # Sorting the first half
        mergeSort(L)

        # Sorting the second half
        mergeSort(R)

        i = j = k = 0

        # Copy data to temp arrays L[] and R[]
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1

        # Checking if any element was left
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1

        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
arr = list(d.keys())
mergeSort(arr)
for key in arr:
    print(d[key], file=fout)


fout.close()
134/77:
import math
def mergeSort(arr):
    if len(arr) > 1:

         # Finding the mid of the array
        mid = len(arr)//2

        # Dividing the array elements
        L = arr[:mid]

        # into 2 halves
        R = arr[mid:]

        # Sorting the first half
        mergeSort(L)

        # Sorting the second half
        mergeSort(R)

        i = j = k = 0

        # Copy data to temp arrays L[] and R[]
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1

        # Checking if any element was left
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1

        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
arr = list(d.keys())
mergeSort(arr)
for key in arr:
    print(d[key], file=fout)


fout.close()
134/78:
import math
def mergeSort(arr):
    if len(arr) > 1:
        mid = len(arr)//2
        L = arr[:mid]
        R = arr[mid:]

        mergeSort(L)
        mergeSort(R)

        i = j = k = 0
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1

        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
arr = list(d.keys())
mergeSort(arr)
for key in arr:
    print(d[key], file=fout)


fout.close()
134/79:
import math
def partition(start, end, array):
    
    # Initializing pivot's index to start
    pivot_index = start 
    pivot = array[pivot_index]
    
    # This loop runs till start pointer crosses 
    # end pointer, and when it does we swap the
    # pivot with element on end pointer
    while start < end:
        
        # Increment the start pointer till it finds an 
        # element greater than  pivot 
        while start < len(array) and array[start] <= pivot:
            start += 1
            
        # Decrement the end pointer till it finds an 
        # element less than pivot
        while array[end] > pivot:
            end -= 1
        
        # If start and end have not crossed each other, 
        # swap the numbers on start and end
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    # Swap pivot element with element on end pointer.
    # This puts pivot on its correct sorted place.
    array[end], array[pivot_index] = array[pivot_index], array[end]
   
    # Returning end pointer to divide the array into 2
    return end
    
# The main function that implements QuickSort 
def quick_sort(start, end, array):
    
    if (start < end):
        
        # p is partitioning index, array[p] 
        # is at right place
        p = partition(start, end, array)
        
        # Sort elements before partition 
        # and after partition
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key], file=fout)


fout.close()
134/80:
import math
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = math.sqrt(x**2 + y**2)
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
    arr = list(d.keys())
    quick_sort(0, len(arr) -1, arr)
    for key in arr:
        print(d[key])
134/81:
import math
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = math.sqrt(x**2 + y**2)
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key])
134/82:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])
134/83:
import math
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = math.sqrt(x**2 + y**2)
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key])
134/84:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])
134/85:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])
134/86:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])
134/87:
import math
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = math.sqrt(math.pow(x, 2) + math.pow(y, 2))
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key])
134/88:
import math
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = math.sqrt(math.pow(x, 2) + math.pow(y, 2))
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key])
134/89:
import math
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = math.sqrt(math.pow(x, 2) + math.pow(y, 2))
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key])
134/90:
import math
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = math.sqrt(math.pow(x, 2) + math.pow(y, 2))
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key])
134/91:
import math
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = math.sqrt(math.pow(x, 2) + math.pow(y, 2))
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key])
134/92:
import math
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = math.sqrt(math.pow(x, 2) + math.pow(y, 2))
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key])
134/93:
import math
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = math.sqrt(math.pow(x, 2) + math.pow(y, 2))
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key])
134/94:
import math
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = math.sqrt(math.pow(x, 2) + math.pow(y, 2))
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key])
134/95:
import math
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = math.sqrt(math.pow(x, 2) + math.pow(y, 2))
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key])
134/96:
import math
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = math.sqrt(math.pow(x, 2) + math.pow(y, 2))
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key])
134/97:
import math
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = math.sqrt(math.pow(x, 2) + math.pow(y, 2))
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key])
134/98:
import math
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = math.sqrt(math.pow(x, 2) + math.pow(y, 2))
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key])
134/99:
import math
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = math.sqrt(math.pow(x, 2) + math.pow(y, 2))
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key])
134/100:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            # if key in d:
            d[key] = f'{d[key]} \n{x} {y}'
            # else:
            #     d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])
134/101:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            # if key in d:
            d[key] = f'{d[key]} \n{x} {y}'
            # else:
            #     d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])
134/102:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            # if key in d:
            d[key] = f'{d[key]} \n{x} {y}'
            # else:
            #     d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])
134/103:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            # if key in d:
            d[key] = f'{d[key]} \n{x} {y}'
            # else:
            #     d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key])
134/104:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            point = [int(s) for s in line.split()]
            points.append(point)
    points.sort(key = lambda p: (p.x - x)**2 + (p.y - y)**2)
print(points)
134/105:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            p = {}
            p['x'] = x
            p['y'] = y
            points.append(p)
    points.sort(key = lambda p: (p.x)**2 + (p.y)**2)
print(points)
134/106:
import math
# def merge(m1, m2, res):
#     i = 0
#     j = 0
#     res_p = 0
#     while i < len(m1) and j < len(m2):
#         if m1[i] < m2[j]:
#             res[res_p] = m1[i]
#             res_p += 1
#             i += 1
#         else:
#             res[res_p] = m2[j]
#             res_p += 1
#             j += 1
#     while i < len(m1):
#         res[res_p] = m1[i]
#         res_p += 1
#         i += 1
#     while j < len(m2):
#         res[res_p] = m2[j]
#         res_p += 1
#         j += 1


# def merge_sort(inp):
#     if len(inp) < 2:
#         return inp
#     m = len(inp) // 2
#     left = merge_sort(inp[:m])
#     right = merge_sort(inp[m:])
#     merge(left, right, inp)

#     return inp

# d = {}
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            p = {}
            p['x'] = x
            p['y'] = y
            points.append(p)
    points.sort(key = lambda p: (p.x)**2 + (p.y)**2)
print(points)
134/107:
import math
# def merge(m1, m2, res):
#     i = 0
#     j = 0
#     res_p = 0
#     while i < len(m1) and j < len(m2):
#         if m1[i] < m2[j]:
#             res[res_p] = m1[i]
#             res_p += 1
#             i += 1
#         else:
#             res[res_p] = m2[j]
#             res_p += 1
#             j += 1
#     while i < len(m1):
#         res[res_p] = m1[i]
#         res_p += 1
#         i += 1
#     while j < len(m2):
#         res[res_p] = m2[j]
#         res_p += 1
#         j += 1


# def merge_sort(inp):
#     if len(inp) < 2:
#         return inp
#     m = len(inp) // 2
#     left = merge_sort(inp[:m])
#     right = merge_sort(inp[m:])
#     merge(left, right, inp)

#     return inp

# d = {}
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            p = {}
            p['x'] = x
            p['y'] = y
            print(p)
            points.append(p)
    points.sort(key = lambda p: (p.x)**2 + (p.y)**2)
print(points)
134/108:
import math
# def merge(m1, m2, res):
#     i = 0
#     j = 0
#     res_p = 0
#     while i < len(m1) and j < len(m2):
#         if m1[i] < m2[j]:
#             res[res_p] = m1[i]
#             res_p += 1
#             i += 1
#         else:
#             res[res_p] = m2[j]
#             res_p += 1
#             j += 1
#     while i < len(m1):
#         res[res_p] = m1[i]
#         res_p += 1
#         i += 1
#     while j < len(m2):
#         res[res_p] = m2[j]
#         res_p += 1
#         j += 1


# def merge_sort(inp):
#     if len(inp) < 2:
#         return inp
#     m = len(inp) // 2
#     left = merge_sort(inp[:m])
#     right = merge_sort(inp[m:])
#     merge(left, right, inp)

#     return inp

# d = {}
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            p = {}
            p['x'] = x
            p['y'] = y
            points.append(p)
    print(points)
    points.sort(key = lambda p: (p.x)**2 + (p.y)**2)
print(points)
134/109:
import math
# def merge(m1, m2, res):
#     i = 0
#     j = 0
#     res_p = 0
#     while i < len(m1) and j < len(m2):
#         if m1[i] < m2[j]:
#             res[res_p] = m1[i]
#             res_p += 1
#             i += 1
#         else:
#             res[res_p] = m2[j]
#             res_p += 1
#             j += 1
#     while i < len(m1):
#         res[res_p] = m1[i]
#         res_p += 1
#         i += 1
#     while j < len(m2):
#         res[res_p] = m2[j]
#         res_p += 1
#         j += 1


# def merge_sort(inp):
#     if len(inp) < 2:
#         return inp
#     m = len(inp) // 2
#     left = merge_sort(inp[:m])
#     right = merge_sort(inp[m:])
#     merge(left, right, inp)

#     return inp

# d = {}
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            p = {}
            p['x'] = x
            p['y'] = y
            points.append(p)
    points.sort(key = lambda p: (p['x'])**2 + (p['y'])**2)
print(points)
134/110:
import math
# def merge(m1, m2, res):
#     i = 0
#     j = 0
#     res_p = 0
#     while i < len(m1) and j < len(m2):
#         if m1[i] < m2[j]:
#             res[res_p] = m1[i]
#             res_p += 1
#             i += 1
#         else:
#             res[res_p] = m2[j]
#             res_p += 1
#             j += 1
#     while i < len(m1):
#         res[res_p] = m1[i]
#         res_p += 1
#         i += 1
#     while j < len(m2):
#         res[res_p] = m2[j]
#         res_p += 1
#         j += 1


# def merge_sort(inp):
#     if len(inp) < 2:
#         return inp
#     m = len(inp) // 2
#     left = merge_sort(inp[:m])
#     right = merge_sort(inp[m:])
#     merge(left, right, inp)

#     return inp

# d = {}
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            p = {}
            p['x'] = x
            p['y'] = y
            p['d'] = math.sqrt(x**2 + y**2)
            points.append(p)
    points.sort(key = lambda p: (p['x'])**2 + (p['y'])**2)
print(points)
134/111:
import math
# def merge(m1, m2, res):
#     i = 0
#     j = 0
#     res_p = 0
#     while i < len(m1) and j < len(m2):
#         if m1[i] < m2[j]:
#             res[res_p] = m1[i]
#             res_p += 1
#             i += 1
#         else:
#             res[res_p] = m2[j]
#             res_p += 1
#             j += 1
#     while i < len(m1):
#         res[res_p] = m1[i]
#         res_p += 1
#         i += 1
#     while j < len(m2):
#         res[res_p] = m2[j]
#         res_p += 1
#         j += 1


# def merge_sort(inp):
#     if len(inp) < 2:
#         return inp
#     m = len(inp) // 2
#     left = merge_sort(inp[:m])
#     right = merge_sort(inp[m:])
#     merge(left, right, inp)

#     return inp

# d = {}
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            p = {}
            p[math.sqrt(x**2 + y**2)] = f'{x} {y}'
            points.append(p)
    points.sort(key = lambda p: (p['x'])**2 + (p['y'])**2)
print(points)
134/112:
import math
# def merge(m1, m2, res):
#     i = 0
#     j = 0
#     res_p = 0
#     while i < len(m1) and j < len(m2):
#         if m1[i] < m2[j]:
#             res[res_p] = m1[i]
#             res_p += 1
#             i += 1
#         else:
#             res[res_p] = m2[j]
#             res_p += 1
#             j += 1
#     while i < len(m1):
#         res[res_p] = m1[i]
#         res_p += 1
#         i += 1
#     while j < len(m2):
#         res[res_p] = m2[j]
#         res_p += 1
#         j += 1


# def merge_sort(inp):
#     if len(inp) < 2:
#         return inp
#     m = len(inp) // 2
#     left = merge_sort(inp[:m])
#     right = merge_sort(inp[m:])
#     merge(left, right, inp)

#     return inp

# d = {}
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            p = {}
            p[math.sqrt(x**2 + y**2)] = f'{x} {y}'
            points.append(p)
    # points.sort(key = lambda p: (p['x'])**2 + (p['y'])**2)
print(points)
134/113:
import math
# def merge(m1, m2, res):
#     i = 0
#     j = 0
#     res_p = 0
#     while i < len(m1) and j < len(m2):
#         if m1[i] < m2[j]:
#             res[res_p] = m1[i]
#             res_p += 1
#             i += 1
#         else:
#             res[res_p] = m2[j]
#             res_p += 1
#             j += 1
#     while i < len(m1):
#         res[res_p] = m1[i]
#         res_p += 1
#         i += 1
#     while j < len(m2):
#         res[res_p] = m2[j]
#         res_p += 1
#         j += 1


# def merge_sort(inp):
#     if len(inp) < 2:
#         return inp
#     m = len(inp) // 2
#     left = merge_sort(inp[:m])
#     right = merge_sort(inp[m:])
#     merge(left, right, inp)

#     return inp

# d = {}
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            p = {}
            p['d'] = math.sqrt(x**2 + y**2)
            p['c'] = f'{x} {y}'
            points.append(p)
    arr = [p.d in points]
print(arr)
134/114:
import math
# def merge(m1, m2, res):
#     i = 0
#     j = 0
#     res_p = 0
#     while i < len(m1) and j < len(m2):
#         if m1[i] < m2[j]:
#             res[res_p] = m1[i]
#             res_p += 1
#             i += 1
#         else:
#             res[res_p] = m2[j]
#             res_p += 1
#             j += 1
#     while i < len(m1):
#         res[res_p] = m1[i]
#         res_p += 1
#         i += 1
#     while j < len(m2):
#         res[res_p] = m2[j]
#         res_p += 1
#         j += 1


# def merge_sort(inp):
#     if len(inp) < 2:
#         return inp
#     m = len(inp) // 2
#     left = merge_sort(inp[:m])
#     right = merge_sort(inp[m:])
#     merge(left, right, inp)

#     return inp

# d = {}
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            p = {}
            p['d'] = math.sqrt(x**2 + y**2)
            p['c'] = f'{x} {y}'
            points.append(p)
    arr = [p.d for p in points]
print(arr)
134/115:
import math
# def merge(m1, m2, res):
#     i = 0
#     j = 0
#     res_p = 0
#     while i < len(m1) and j < len(m2):
#         if m1[i] < m2[j]:
#             res[res_p] = m1[i]
#             res_p += 1
#             i += 1
#         else:
#             res[res_p] = m2[j]
#             res_p += 1
#             j += 1
#     while i < len(m1):
#         res[res_p] = m1[i]
#         res_p += 1
#         i += 1
#     while j < len(m2):
#         res[res_p] = m2[j]
#         res_p += 1
#         j += 1


# def merge_sort(inp):
#     if len(inp) < 2:
#         return inp
#     m = len(inp) // 2
#     left = merge_sort(inp[:m])
#     right = merge_sort(inp[m:])
#     merge(left, right, inp)

#     return inp

# d = {}
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            p = {}
            p['d'] = math.sqrt(x**2 + y**2)
            p['c'] = f'{x} {y}'
            points.append(p)
    arr = [p.d for p in points]
    print(arr)
134/116:
import math
# def merge(m1, m2, res):
#     i = 0
#     j = 0
#     res_p = 0
#     while i < len(m1) and j < len(m2):
#         if m1[i] < m2[j]:
#             res[res_p] = m1[i]
#             res_p += 1
#             i += 1
#         else:
#             res[res_p] = m2[j]
#             res_p += 1
#             j += 1
#     while i < len(m1):
#         res[res_p] = m1[i]
#         res_p += 1
#         i += 1
#     while j < len(m2):
#         res[res_p] = m2[j]
#         res_p += 1
#         j += 1


# def merge_sort(inp):
#     if len(inp) < 2:
#         return inp
#     m = len(inp) // 2
#     left = merge_sort(inp[:m])
#     right = merge_sort(inp[m:])
#     merge(left, right, inp)

#     return inp

# d = {}
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            p = {}
            p['d'] = math.sqrt(x**2 + y**2)
            p['c'] = f'{x} {y}'
            points.append(p)
    arr = [p['d'] for p in points]
    print(arr)
134/117:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

# d = {}
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            p = {}
            p['d'] = math.sqrt(x**2 + y**2)
            p['c'] = f'{x} {y}'
            points.append(p)
    arr = [p['d'] for p in points]
    merge_sort(arr)
134/118:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

# d = {}
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            p = {}
            p['d'] = math.sqrt(x**2 + y**2)
            p['c'] = f'{x} {y}'
            points.append(p)
    arr = [p['d'] for p in points]
    merge_sort(arr)
    print(arr)
134/119:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

# d = {}
points = {}
distances = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = math.sqrt(x**2 + y**2)
            distances.append(d)
            p = {}
            p['c'] = f'{x} {y}'
            p['d'] = d
            points.append(p)
    merge_sort(distances)
    for d in distances:
        for idx, p in enumerate(points):
            if p['d'] == d:
                print(p['c'])
                del points[idx]
134/120:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

# d = {}
points = []
distances = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = math.sqrt(x**2 + y**2)
            distances.append(d)
            p = {}
            p['c'] = f'{x} {y}'
            p['d'] = d
            points.append(p)
    merge_sort(distances)
    for d in distances:
        for idx, p in enumerate(points):
            if p['d'] == d:
                print(p['c'])
                del points[idx]
134/121:
class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = math.sqrt(x**2 + y**2)
            point = Point(x, y, d)
            points.append(point)
    print(points)
134/122:
class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = math.sqrt(x**2 + y**2)
            point = Point(x, y, d)
            points.append(point)

scores = [ point.d for point in points ]

print(scores)
134/123:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = math.sqrt(x**2 + y**2)
            point = Point(x, y, d)
            points.append(point)

scores = [ point.d for point in points ]
merge_sort(merge_sort)
print(scores)
134/124:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = math.sqrt(x**2 + y**2)
            point = Point(x, y, d)
            points.append(point)

scores = [ point.d for point in points ]
merge_sort(scores)

print(scores)
134/125:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = math.sqrt(x**2 + y**2)
            point = Point(x, y, d)
            points.append(point)

scores = [ point.d for point in points ]
merge_sort(scores)

print(points)
134/126:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = math.sqrt(x**2 + y**2)
            point = Point(x, y, d)
            points.append(point)

# scores = [point.d for point in points]
merge_sort(points)

print(points)
134/127:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i].d < m2[j].d:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = math.sqrt(x**2 + y**2)
            point = Point(x, y, d)
            points.append(point)

# scores = [point.d for point in points]
merge_sort(points)

print(points)
134/128:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i].d < m2[j].d:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = math.sqrt(x**2 + y**2)
            point = Point(x, y, d)
            points.append(point)

# scores = [point.d for point in points]
merge_sort(points)

print(points)
134/129:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i].d < m2[j].d:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = math.sqrt(x**2 + y**2)
            point = Point(x, y, d)
            points.append(point)


merge_sort(points)
scores = [[point.x, point.y] for point in points]
print(scores)
134/130:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i].d < m2[j].d:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = math.sqrt(x**2 + y**2)
            point = Point(x, y, d)
            points.append(point)


merge_sort(points)
scores = [[point.x, point.y] for point in points]
print('\n'.join(scores))
134/131:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i].d < m2[j].d:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = math.sqrt(x**2 + y**2)
            point = Point(x, y, d)
            points.append(point)


merge_sort(points)
scores = [f'{point.x} {point.y}' for point in points]
print('\n'.join(scores))
134/132:
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i].d < m2[j].d:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            point = Point(x, y, d)
            points.append(point)


merge_sort(points)
scores = [f'{point.x} {point.y}' for point in points]
print('\n'.join(scores))
134/133:

def count_sort(array, max_d):
    d = dict.fromkeys((range(max_d + 1)), 0)
    for i in array:
       d[i] += 1
    return d.values()

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


test = count_sort(points, max_d)
print(test)
# scores = [f'{point.x} {point.y}' for point in points]
# print('\n'.join(scores))
134/134:

def count_sort(points, max_d):
    L = len(points)
    max_value = max_d

    # Создаем вспомогательный список
    C = [0] * (max_value + 1)

    # Значения используем в качестве индекса, в индексы (==ые значениям)
    # из нашего списка ставим веса
    # если знаяение встречается несколько раз то это просто увеличивает вес на 1
    for p in points:
        C[p.d] += 1

    # далее как бы расчитываем вес каждого "индекса-значения"
    for i in range(1, (max_value + 1)):
        C[i] = C[i-1] + C[i]

    # где будем сохранять отсортированный список
    B = [0] * L
    for i in range(L):
        # если 0 - встретился, то у него вес =1, его нужно записать в 0-ячейку
        # если будут повторяться значения, они должны вставать на ячейку раньше (поэтому вес уменьшаем)
        C[points[i].d] -= 1
        B[C[points[i].d]] = points[i]

    return B

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


test = count_sort(points, max_d)
print(test)
# scores = [f'{point.x} {point.y}' for point in points]
# print('\n'.join(scores))
134/135:

def count_sort(points, max_d):
    L = len(points)
    max_value = max_d

    # Создаем вспомогательный список
    C = [0] * (max_value + 1)

    # Значения используем в качестве индекса, в индексы (==ые значениям)
    # из нашего списка ставим веса
    # если знаяение встречается несколько раз то это просто увеличивает вес на 1
    for p in points:
        C[p.d] += 1

    # далее как бы расчитываем вес каждого "индекса-значения"
    for i in range(1, (max_value + 1)):
        C[i] = C[i-1] + C[i]

    # где будем сохранять отсортированный список
    B = [0] * L
    for i in range(L):
        # если 0 - встретился, то у него вес =1, его нужно записать в 0-ячейку
        # если будут повторяться значения, они должны вставать на ячейку раньше (поэтому вес уменьшаем)
        C[points[i].d] -= 1
        B[C[points[i].d]] = points[i]

    return B

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
for s in sorted:
    print(s.x s.y)
# scores = [f'{point.x} {point.y}' for point in points]
# print('\n'.join(scores))
134/136:

def count_sort(points, max_d):
    L = len(points)
    max_value = max_d

    # Создаем вспомогательный список
    C = [0] * (max_value + 1)

    # Значения используем в качестве индекса, в индексы (==ые значениям)
    # из нашего списка ставим веса
    # если знаяение встречается несколько раз то это просто увеличивает вес на 1
    for p in points:
        C[p.d] += 1

    # далее как бы расчитываем вес каждого "индекса-значения"
    for i in range(1, (max_value + 1)):
        C[i] = C[i-1] + C[i]

    # где будем сохранять отсортированный список
    B = [0] * L
    for i in range(L):
        # если 0 - встретился, то у него вес =1, его нужно записать в 0-ячейку
        # если будут повторяться значения, они должны вставать на ячейку раньше (поэтому вес уменьшаем)
        C[points[i].d] -= 1
        B[C[points[i].d]] = points[i]

    return B

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/137:

def count_sort(points, max_d):
    L = len(points)
    max_value = max_d
    arr = [0] * (max_value + 1)
    for p in points:
        arr[p.d] += 1
    print(arr)
    for i in range(1, (max_value + 1)):
        arr[i] = arr[i-1] + arr[i]

    # где будем сохранять отсортированный список
    B = [0] * L
    for i in range(L):
        # если 0 - встретился, то у него вес =1, его нужно записать в 0-ячейку
        # если будут повторяться значения, они должны вставать на ячейку раньше (поэтому вес уменьшаем)
        arr[points[i].d] -= 1
        B[arr[points[i].d]] = points[i]

    return B

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/138:

def count_sort(points, max_d):
    L = len(points)
    max_value = max_d
    arr = [0] * (max_value + 1)
    for p in points:
        arr[p.d] += 1
    for i in range(1, (max_value + 1)):
        arr[i] = arr[i-1] + arr[i]

    # где будем сохранять отсортированный список
    B = [0] * L
    for i in range(L):
        # если 0 - встретился, то у него вес =1, его нужно записать в 0-ячейку
        # если будут повторяться значения, они должны вставать на ячейку раньше (поэтому вес уменьшаем)
        arr[points[i].d] -= 1
        B[arr[points[i].d]] = points[i]

    return B

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/139:

def count_sort(points, max_d):
    L = len(points)
    max_value = max_d

    d = dict.fromkeys((range(max_value + 1)), 0)
    for p in points:
        d[p.d] += 1
    print(d)
    B = [0] * L
    for key, value in d:
        pass
        # если 0 - встретился, то у него вес =1, его нужно записать в 0-ячейку
        # если будут повторяться значения, они должны вставать на ячейку раньше (поэтому вес уменьшаем)
        # arr[points[i].d] -= 1
        # B[arr[points[i].d]] = points[i]

    return B

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/140:

def count_sort(points, max_d):
    L = len(points)
    max_value = max_d

    d = dict.fromkeys((range(max_value + 1)), 0)
    for p in points:
        d[p.d] += 1
    print(d)
    B = [0] * L
    for key, value in d:
        pass
        # если 0 - встретился, то у него вес =1, его нужно записать в 0-ячейку
        # если будут повторяться значения, они должны вставать на ячейку раньше (поэтому вес уменьшаем)
        # arr[points[i].d] -= 1
        # B[arr[points[i].d]] = points[i]

    return B

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/141:
from math import sqrt
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = math.sqrt(math.pow(x, 2) + math.pow(y, 2))
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key])
134/142:
from math import sqrt
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = int(sqrt(x*x+y*y)*100)
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key])
134/143:
from math import sqrt
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
d = {}

from sys import stdin
text = stdin.read()
points = list(map(str, text.splitlines()))

for index, line in enumerate(points):
    x, y = [int(s) for s in line.split()]
    key = int(sqrt(x*x+y*y)*100)
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
arr = list(d.keys())
quick_sort(0, len(arr) -1, arr)
for key in arr:
    print(d[key])
134/144:

def count_sort(points, max_d):
    L = len(points)
    max_value = max_d

    arr = [0] * (max_value + 1)

    # Значения используем в качестве индекса, в индексы (==ые значениям)
    # из нашего списка ставим веса
    # если знаяение встречается несколько раз то это просто увеличивает вес на 1
    for p in points:
        arr[p.d] += 1
    print(arr)
    # далее как бы расчитываем вес каждого "индекса-значения"
    for i in range(1, (max_value + 1)):
        arr[i] = arr[i-1] + arr[i]
    print(arr)
    # где будем сохранять отсортированный список
    B = [0] * L
    for i in range(L):
        # если 0 - встретился, то у него вес =1, его нужно записать в 0-ячейку
        # если будут повторяться значения, они должны вставать на ячейку раньше (поэтому вес уменьшаем)
        arr[points[i].d] -= 1
        B[arr[points[i].d]] = points[i]

    return B

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/145:

def count_sort(points, max_d):
    L = len(points)
    max_value = max_d

    arr = [0] * (max_value + 1)

    # Значения используем в качестве индекса, в индексы (==ые значениям)
    # из нашего списка ставим веса
    # если знаяение встречается несколько раз то это просто увеличивает вес на 1
    for p in points:
        arr[p.d] += 1
    # далее как бы расчитываем вес каждого "индекса-значения"
    for i in range(1, (max_value + 1)):
        arr[i] = arr[i-1] + arr[i]
    print(arr)
    # где будем сохранять отсортированный список
    B = [0] * L
    for i in range(L):
        # если 0 - встретился, то у него вес =1, его нужно записать в 0-ячейку
        # если будут повторяться значения, они должны вставать на ячейку раньше (поэтому вес уменьшаем)
        arr[points[i].d] -= 1
        B[arr[points[i].d]] = points[i]

    return B

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/146:

def count_sort(points, max_d):
    L = len(points)
    max_value = max_d

    arr = [0] * (max_value + 1)

    # Значения используем в качестве индекса, в индексы (==ые значениям)
    # из нашего списка ставим веса
    # если знаяение встречается несколько раз то это просто увеличивает вес на 1
    for p in points:
        arr[p.d] += 1
    # далее как бы расчитываем вес каждого "индекса-значения"
    for i in range(1, (max_value + 1)):
        arr[i] = arr[i-1] + arr[i]
    print(arr)
    # где будем сохранять отсортированный список
    B = [0] * L
    for i in range(L):
        # если 0 - встретился, то у него вес =1, его нужно записать в 0-ячейку
        # если будут повторяться значения, они должны вставать на ячейку раньше (поэтому вес уменьшаем)
        arr[points[i].d] -= 1
        B[arr[points[i].d]] = points[i]
    print(B)
    return B

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/147:

def count_sort(points, max_d):
    L = len(points)
    max_value = max_d

    arr = [0] * (max_value + 1)

    # Значения используем в качестве индекса, в индексы (==ые значениям)
    # из нашего списка ставим веса
    # если знаяение встречается несколько раз то это просто увеличивает вес на 1
    for p in points:
        arr[p.d] += 1
    # далее как бы расчитываем вес каждого "индекса-значения"
    for i in range(1, (max_value + 1)):
        arr[i] = arr[i-1] + arr[i]
    print(arr)
    # где будем сохранять отсортированный список
    B = [0] * L
    for i in range(L):
        # если 0 - встретился, то у него вес =1, его нужно записать в 0-ячейку
        # если будут повторяться значения, они должны вставать на ячейку раньше (поэтому вес уменьшаем)
        arr[points[i].d] -= 1
        B[arr[points[i].d]] = points[i]
    print(B)
    return B

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/148:

def count_sort(points, max_d):
    L = len(points)
    max_value = max_d

    arr = [0] * (max_value + 1)

    # Значения используем в качестве индекса, в индексы (==ые значениям)
    # из нашего списка ставим веса
    # если знаяение встречается несколько раз то это просто увеличивает вес на 1
    for p in points:
        arr[p.d] += 1
    # далее как бы расчитываем вес каждого "индекса-значения"
    for i in range(1, (max_value + 1)):
        arr[i] = arr[i-1] + arr[i]
    # где будем сохранять отсортированный список
    B = [0] * L
    for i in range(L):
        # если 0 - встретился, то у него вес =1, его нужно записать в 0-ячейку
        # если будут повторяться значения, они должны вставать на ячейку раньше (поэтому вес уменьшаем)
        arr[points[i].d] -= 1
        B[arr[points[i].d]] = points[i]
    print(B)
    return B

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/149:

def count_sort(points, max_d):
    L = len(points)
    max_value = max_d

    arr = [0] * (max_value + 1)

    # Значения используем в качестве индекса, в индексы (==ые значениям)
    # из нашего списка ставим веса
    # если знаяение встречается несколько раз то это просто увеличивает вес на 1
    for p in points:
        arr[p.d] += 1
    # далее как бы расчитываем вес каждого "индекса-значения"
    for i in range(1, (max_value + 1)):
        arr[i] = arr[i-1] + arr[i]
    # где будем сохранять отсортированный список
    B = [0] * L
    for i in range(L):
        # если 0 - встретился, то у него вес =1, его нужно записать в 0-ячейку
        # если будут повторяться значения, они должны вставать на ячейку раньше (поэтому вес уменьшаем)
        arr[points[i].d] -= 1
        B[arr[points[i].d]] = points[i]
    print(B)
    return B

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/150:

def count_sort(points, max_d):
    max_value = max_d
    arr = [0] * (max_value + 1)

    for p in points:
        arr[p.d] += 1
    # далее как бы расчитываем вес каждого "индекса-значения"
    for i in range(1, (max_value + 1)):
        arr[i] = arr[i-1] + arr[i]
    # где будем сохранять отсортированный список
    B = [0] * len(points)
    for i in range(len(points)):
        # если 0 - встретился, то у него вес =1, его нужно записать в 0-ячейку
        # если будут повторяться значения, они должны вставать на ячейку раньше (поэтому вес уменьшаем)
        arr[points[i].d] -= 1
        print(points[i])
        B[arr[points[i].d]] = points[i]
    print(B)
    return B

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/151:

def count_sort(points, max_d):
    max_value = max_d
    arr = [0] * (max_value + 1)

    for p in points:
        arr[p.d] += 1
    # далее как бы расчитываем вес каждого "индекса-значения"
    for i in range(1, (max_value + 1)):
        arr[i] = arr[i-1] + arr[i]
    # где будем сохранять отсортированный список
    B = [0] * len(points)
    for i in range(len(points)):
        # если 0 - встретился, то у него вес =1, его нужно записать в 0-ячейку
        # если будут повторяться значения, они должны вставать на ячейку раньше (поэтому вес уменьшаем)
        # arr[points[i].d] -= 1
        print(points[i])
        B[arr[points[i].d]] = points[i]
    print(B)
    return B

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/152:

def count_sort(points, max_d):
    max_value = max_d
    arr = [0] * (max_value + 1)

    for p in points:
        arr[p.d] += 1
    # далее как бы расчитываем вес каждого "индекса-значения"
    for i in range(1, (max_value + 1)):
        arr[i] = arr[i-1] + arr[i]
    # где будем сохранять отсортированный список
    B = [0] * len(points)
    for i in range(len(points)):
        # если 0 - встретился, то у него вес =1, его нужно записать в 0-ячейку
        # если будут повторяться значения, они должны вставать на ячейку раньше (поэтому вес уменьшаем)
        arr[points[i].d] -= 1
        print(points[i])
        B[arr[points[i].d]] = points[i]
    print(B)
    return B

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/153:

def count_sort(points, max_d):
    max_value = max_d
    arr = [0] * (max_value + 1)

    for p in points:
        arr[p.d] += 1
    # далее как бы расчитываем вес каждого "индекса-значения"
    for i in range(1, (max_value + 1)):
        arr[i] = arr[i-1] + arr[i]
    # где будем сохранять отсортированный список
    B = [0] * len(points)
    for i in range(len(points)):
        # если 0 - встретился, то у него вес =1, его нужно записать в 0-ячейку
        # если будут повторяться значения, они должны вставать на ячейку раньше (поэтому вес уменьшаем)
        arr[points[i].d] -= 1
        print(points[i])
        B[arr[points[i].d]] = points[i]
    print(B)
    return B

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/154:

def count_sort(points, max_d):
    max_value = max_d
    arr = [0] * (max_value + 1)

    for p in points:
        arr[p.d] += 1
    for i in range(1, (max_value + 1)):
        arr[i] = arr[i-1] + arr[i]

    res = [0] * len(points)
    for i in range(len(points)):
        arr[points[i].d] -= 1
        res[arr[points[i].d]] = points[i]
    return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*100)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/155:

def count_sort(points, max_d):
    max_value = max_d
    arr = [0] * (max_value + 1)

    for p in points:
        arr[p.d] += 1
    for i in range(1, (max_value + 1)):
        arr[i] = arr[i-1] + arr[i]

    res = [0] * len(points)
    for i in range(len(points)):
        arr[points[i].d] -= 1
        res[arr[points[i].d]] = points[i]
    return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/156:
from math import sqrt
def partition(start, end, array):
    pivot_index = start 
    pivot = array[pivot_index]
    while start < end:
        while start < len(array) and array[start] <= pivot:
            start += 1
        while array[end] > pivot:
            end -= 1
        if(start < end):
            array[start], array[end] = array[end], array[start]
    
    array[end], array[pivot_index] = array[pivot_index], array[end]

    return end

def quick_sort(start, end, array):    
    if (start < end):
        p = partition(start, end, array)
        quick_sort(start, p - 1, array)
        quick_sort(p + 1, end, array)
        
class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

#  sorted_points = sorted(points, key=lambda e: distance(e, target))
points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)

sorted = quick_sort(0, len(points), points)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/157:

def count_sort(points, max_d):
    max_value = max_d
    arr = [0] * (max_value + 1)

    for p in points:
        arr[p.d] += 1
    # for i in range(1, (max_value + 1)):
    #     arr[i] = arr[i-1] + arr[i]

    res = [0] * len(points)
    for i in range(len(points)):
        arr[points[i].d] -= 1
        res[arr[points[i].d]] = points[i]
    return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/158:

def count_sort(points, max_d):
    max_value = max_d
    arr = [0] * (max_value + 1)

    for p in points:
        arr[p.d] += 1
    for i in range(1, (max_value + 1)):
        arr[i] = arr[i-1] + arr[i]

    res = [0] * len(points)
    for i in range(len(points)):
        arr[points[i].d] -= 1
        res[arr[points[i].d]] = points[i]
    return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/159:

def count_sort(points, max_d):
    max_value = max_d

    d = dict.fromkeys((range(max_d + 1)), 0)

    for p.d in points:
       d[p.d] += 1
    # arr = [0] * (max_value + 1)
    print(points)
    # for p in points:
    #     arr[p.d] += 1
    # for i in range(1, (max_value + 1)):
    #     arr[i] = arr[i-1] + arr[i]

    # res = [0] * len(points)
    # for i in range(len(points)):
    #     arr[points[i].d] -= 1
    #     res[arr[points[i].d]] = points[i]
    # return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/160:

def count_sort(points, max_d):
    max_value = max_d

    d = dict.fromkeys((range(max_d + 1)), 0)
    for p in points:
       d[p.d] += 1
    # arr = [0] * (max_value + 1)
    print(points)
    # for p in points:
    #     arr[p.d] += 1
    # for i in range(1, (max_value + 1)):
    #     arr[i] = arr[i-1] + arr[i]

    # res = [0] * len(points)
    # for i in range(len(points)):
    #     arr[points[i].d] -= 1
    #     res[arr[points[i].d]] = points[i]
    # return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
scores = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(scores))
fin.close()
134/161:

def count_sort(points, max_d):
    max_value = max_d

    d = dict.fromkeys((range(max_d + 1)), 0)
    for p in points:
       d[p.d] += 1
    # arr = [0] * (max_value + 1)
    print(points)
    # for p in points:
    #     arr[p.d] += 1
    # for i in range(1, (max_value + 1)):
    #     arr[i] = arr[i-1] + arr[i]

    # res = [0] * len(points)
    # for i in range(len(points)):
    #     arr[points[i].d] -= 1
    #     res[arr[points[i].d]] = points[i]
    # return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
# scores = [f'{point.x} {point.y}' for point in sorted]
# print('\n'.join(scores))
fin.close()
134/162:

def count_sort(points, max_d):
    max_value = max_d

    d = dict.fromkeys((range(max_d + 1)), 0)
    for p in points:
       d[p.d] += 1
    # arr = [0] * (max_value + 1)
    print(d)
    # for p in points:
    #     arr[p.d] += 1
    # for i in range(1, (max_value + 1)):
    #     arr[i] = arr[i-1] + arr[i]

    # res = [0] * len(points)
    # for i in range(len(points)):
    #     arr[points[i].d] -= 1
    #     res[arr[points[i].d]] = points[i]
    # return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
# scores = [f'{point.x} {point.y}' for point in sorted]
# print('\n'.join(scores))
fin.close()
134/163:

def count_sort(points, max_d):
    max_value = max_d

    d = dict.fromkeys((range(max_d + 1)), 0)
    for p in points:
       d[p.d] += 1
    # arr = [0] * (max_value + 1)
    print(d)
    # for p in points:
    #     arr[p.d] += 1
    # for i in range(1, (max_value + 1)):
    #     arr[i] = arr[i-1] + arr[i]

    # res = [0] * len(points)
    # for i in range(len(points)):
    #     arr[points[i].d] -= 1
    #     res[arr[points[i].d]] = points[i]
    # return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
# scores = [f'{point.x} {point.y}' for point in sorted]
# print('\n'.join(scores))
fin.close()
134/164:

def count_sort(points, max_d):
    max_value = max_d

    d = dict.fromkeys((range(max_d + 1)), 0)
    for p in points:
       d[p.d] += 1
    # arr = [0] * (max_value + 1)
    print(d)
    # for p in points:
    #     arr[p.d] += 1
    # for i in range(1, (max_value + 1)):
    #     arr[i] = arr[i-1] + arr[i]

    # res = [0] * len(points)
    # for i in range(len(points)):
    #     arr[points[i].d] -= 1
    #     res[arr[points[i].d]] = points[i]
    # return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
# scores = [f'{point.x} {point.y}' for point in sorted]
# print('\n'.join(scores))
fin.close()
134/165:

def count_sort(points, max_d):
    max_value = max_d

    d = dict.fromkeys((range(max_d + 1)), 0)
    for p in points:
       d[p.d] += 1

    res = {}
    for key, value in d.items():
        for idx, p in enumerate(points):
            if p.d == key:
                res.append(p.x, p.y)
                del points[idx]
    print(res)
    # arr = [0] * (max_value + 1)

    # for p in points:
    #     arr[p.d] += 1
    # for i in range(1, (max_value + 1)):
    #     arr[i] = arr[i-1] + arr[i]

    # res = [0] * len(points)
    # for i in range(len(points)):
    #     arr[points[i].d] -= 1
    #     res[arr[points[i].d]] = points[i]
    # return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
# scores = [f'{point.x} {point.y}' for point in sorted]
# print('\n'.join(scores))
fin.close()
134/166:

def count_sort(points, max_d):
    max_value = max_d

    d = dict.fromkeys((range(max_d + 1)), 0)
    for p in points:
       d[p.d] += 1

    res = []
    for key, value in d.items():
        for idx, p in enumerate(points):
            if p.d == key:
                res.append(p.x, p.y)
                del points[idx]
    print(res)
    # arr = [0] * (max_value + 1)

    # for p in points:
    #     arr[p.d] += 1
    # for i in range(1, (max_value + 1)):
    #     arr[i] = arr[i-1] + arr[i]

    # res = [0] * len(points)
    # for i in range(len(points)):
    #     arr[points[i].d] -= 1
    #     res[arr[points[i].d]] = points[i]
    # return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
# scores = [f'{point.x} {point.y}' for point in sorted]
# print('\n'.join(scores))
fin.close()
134/167:

def count_sort(points, max_d):
    max_value = max_d

    d = dict.fromkeys((range(max_d + 1)), 0)
    for p in points:
       d[p.d] += 1

    res = []
    for key, value in d.items():
        for idx, p in enumerate(points):
            if p.d == key:
                res.append([p.x, p.y])
                del points[idx]
    print(res)
    # arr = [0] * (max_value + 1)

    # for p in points:
    #     arr[p.d] += 1
    # for i in range(1, (max_value + 1)):
    #     arr[i] = arr[i-1] + arr[i]

    # res = [0] * len(points)
    # for i in range(len(points)):
    #     arr[points[i].d] -= 1
    #     res[arr[points[i].d]] = points[i]
    # return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
# scores = [f'{point.x} {point.y}' for point in sorted]
# print('\n'.join(scores))
fin.close()
134/168:

def count_sort(points, max_d):
    max_value = max_d

    d = dict.fromkeys((range(max_d + 1)), 0)
    for p in points:
       d[p.d] += 1

    res = []
    for key, value in d.items():
        for idx, p in enumerate(points):
            print(p)
            if p.d == key:
                res.append([p.x, p.y])
                del points[idx]
    # print(res)
    # arr = [0] * (max_value + 1)

    # for p in points:
    #     arr[p.d] += 1
    # for i in range(1, (max_value + 1)):
    #     arr[i] = arr[i-1] + arr[i]

    # res = [0] * len(points)
    # for i in range(len(points)):
    #     arr[points[i].d] -= 1
    #     res[arr[points[i].d]] = points[i]
    # return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
# scores = [f'{point.x} {point.y}' for point in sorted]
# print('\n'.join(scores))
fin.close()
134/169:

def count_sort(points, max_d):
    max_value = max_d

    d = dict.fromkeys((range(max_d + 1)), 0)
    for p in points:
       d[p.d] += 1

    res = []
    for key, value in d.items():
        for idx, p in enumerate(points):
            print(p.x, p.y, p.d)
            if p.d == key:
                res.append([p.x, p.y])
                del points[idx]
    # print(res)
    # arr = [0] * (max_value + 1)

    # for p in points:
    #     arr[p.d] += 1
    # for i in range(1, (max_value + 1)):
    #     arr[i] = arr[i-1] + arr[i]

    # res = [0] * len(points)
    # for i in range(len(points)):
    #     arr[points[i].d] -= 1
    #     res[arr[points[i].d]] = points[i]
    # return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
# scores = [f'{point.x} {point.y}' for point in sorted]
# print('\n'.join(scores))
fin.close()
134/170:

def count_sort(points, max_d):
    max_value = max_d

    d = dict.fromkeys((range(max_d + 1)), 0)
    for p in points:
       d[p.d] += 1

    res = []
    for key, value in d.items():
        for idx, p in enumerate(points):
            print(p.x, p.y, p.d)
            if p.d == key:
                res.append([p.x, p.y])
                del points[idx]
    # print(res)
    # arr = [0] * (max_value + 1)

    # for p in points:
    #     arr[p.d] += 1
    # for i in range(1, (max_value + 1)):
    #     arr[i] = arr[i-1] + arr[i]

    # res = [0] * len(points)
    # for i in range(len(points)):
    #     arr[points[i].d] -= 1
    #     res[arr[points[i].d]] = points[i]
    # return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
# scores = [f'{point.x} {point.y}' for point in sorted]
# print('\n'.join(scores))
fin.close()
134/171:

def count_sort(points, max_d):
    max_value = max_d

    d = dict.fromkeys((range(max_d + 1)), 0)
    for p in points:
       d[p.d] += 1

    res = []
    for key, value in d.items():
        for idx, p in enumerate(points):
            print(p.x, p.y, p.d)
            if p.d == key:
                print(p.x, p.y)
                del points[idx]
    # print(res)
    # arr = [0] * (max_value + 1)

    # for p in points:
    #     arr[p.d] += 1
    # for i in range(1, (max_value + 1)):
    #     arr[i] = arr[i-1] + arr[i]

    # res = [0] * len(points)
    # for i in range(len(points)):
    #     arr[points[i].d] -= 1
    #     res[arr[points[i].d]] = points[i]
    # return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
# scores = [f'{point.x} {point.y}' for point in sorted]
# print('\n'.join(scores))
fin.close()
134/172:

def count_sort(points, max_d):
    max_value = max_d

    d = dict.fromkeys((range(max_d + 1)), 0)
    for p in points:
       d[p.d] += 1

    res = []
    for key, value in d.items():
        for idx, p in enumerate(points):
            print(p.x, p.y, p.d)
            if p.d == key:
                print(p.x, p.y)
                del points[idx]
    # print(res)
    # arr = [0] * (max_value + 1)

    # for p in points:
    #     arr[p.d] += 1
    # for i in range(1, (max_value + 1)):
    #     arr[i] = arr[i-1] + arr[i]


    # res = [0] * len(points)
    # for i in range(len(points)):
    #     arr[points[i].d] -= 1
    #     res[arr[points[i].d]] = points[i]
    # return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
# scores = [f'{point.x} {point.y}' for point in sorted]
# print('\n'.join(scores))
fin.close()
134/173:

def count_sort(points, max_d):
    max_value = max_d

    d = dict.fromkeys((range(max_d + 1)), 0)
    for p in points:
       d[p.d] += 1

    res = []
    for key, value in d.items():
        for idx, p in enumerate(points):
            print(p.x, p.y, p.d)
            if p.d == key:
                print(p.x, p.y)
                del points[idx]
    # print(res)
    # arr = [0] * (max_value + 1)

    # for p in points:
    #     arr[p.d] += 1
    # for i in range(1, (max_value + 1)):
    #     arr[i] = arr[i-1] + arr[i]


    # res = [0] * len(points)
    # for i in range(len(points)):
    #     arr[points[i].d] -= 1
    #     res[arr[points[i].d]] = points[i]
    # return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
# scores = [f'{point.x} {point.y}' for point in sorted]
# print('\n'.join(scores))
fin.close()
134/174:

def count_sort(points, max_d):
    arr = [0] * (max_d + 1)

    for p in points:
        arr[p.d] += 1
    for i in range(1, (max_d + 1)):
        arr[i] = arr[i-1] + arr[i]


    res = [0] * len(points)
    for i in range(len(points)):
        arr[points[i].d] -= 1
        res[arr[points[i].d]] = points[i]
    return res

class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d

points = []
max_d = 0
from math import sqrt
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            d = int(sqrt(x*x+y*y)*10)
            max_d = max(max_d, d)
            point = Point(x, y, d)
            points.append(point)


sorted = count_sort(points, max_d)
result = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(result))
fin.close()
134/175:

from math import sqrt


def count_sort(points, max_d):
    arr = [0] * (max_d + 1)

    for p in points:
        arr[p.d] += 1
    for i in range(1, (max_d + 1)):
        arr[i] = arr[i-1] + arr[i]

    res = [0] * len(points)
    for i in range(len(points)):
        arr[points[i].d] -= 1
        res[arr[points[i].d]] = points[i]
    return res


class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d


points = []
max_d = 0
fin = open('input.txt', 'r', encoding='utf8')
for index, line in enumerate(fin):
    if index != 0:
        x, y = [int(s) for s in line.split()]
        d = int(sqrt(x*x+y*y)*10)
        max_d = max(max_d, d)
        point = Point(x, y, d)
        points.append(point)


sorted = count_sort(points, max_d)
result = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(result))
fin.close()
134/176:

from math import sqrt


def count_sort(points, max_d):
    arr = [0] * (max_d + 1)

    for p in points:
        arr[p.d] += 1
    for i in range(1, (max_d + 1)):
        arr[i] = arr[i-1] + arr[i]

    res = [0] * len(points)
    for i in range(len(points)):
        arr[points[i].d] -= 1
        res[arr[points[i].d]] = points[i]
    return res


class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d


points = []
max_d = 0
fin = open('input.txt', 'r', encoding='utf8')
for index, line in enumerate(fin):
    if index != 0:
        x, y = [int(s) for s in line.split()]
        d = int(sqrt(x*x+y*y)*10)
        max_d = max(max_d, d)
        point = Point(x, y, d)
        points.append(point)


sorted = count_sort(points, max_d)
result = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(result))
fin.close()
134/177:

from math import sqrt


def count_sort(points, max_d):
    arr = [0] * (max_d + 1)

    for p in points:
        arr[p.d] += 1
    for i in range(1, (max_d + 1)):
        arr[i] = arr[i-1] + arr[i]

    res = [0] * len(points)
    for i in range(len(points)):
        arr[points[i].d] -= 1
        res[arr[points[i].d]] = points[i]
    return res


class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d


points = []
max_d = 0
fin = open('input.txt', 'r', encoding='utf8')
for index, line in enumerate(fin):
    if index != 0:
        x, y = [int(s) for s in line.split()]
        d = int(sqrt(x*x+y*y)*10)
        max_d = max(max_d, d)
        point = Point(x, y, d)
        points.append(point)


sorted = count_sort(points, max_d)
result = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(result))
fin.close()
134/178:

from math import sqrt


def count_sort(points, max_d):
    arr = [0] * (max_d + 1)

    for p in points:
        arr[p.d] += 1
    for i in range(1, (max_d + 1)):
        arr[i] = arr[i-1] + arr[i]

    res = [0] * len(points)
    for i in range(len(points)):
        arr[points[i].d] -= 1
        res[arr[points[i].d]] = points[i]
    return res


class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d


points = []
max_d = 0
fin = open('input.txt', 'r', encoding='utf8')

length = int(fin.readline())
max_distance = 0
for i in range(length):
    x, y = [int(s) for s in line.split()]
    d = int(sqrt(x*x+y*y)*10)
    max_d = max(max_d, d)
    point = Point(x, y, d)
    points.append(point)

sorted = count_sort(points, max_d)
result = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(result))
fin.close()
134/179:

from math import sqrt


def count_sort(points, max_d):
    arr = [0] * (max_d + 1)

    for p in points:
        arr[p.d] += 1
    for i in range(1, (max_d + 1)):
        arr[i] = arr[i-1] + arr[i]

    res = [0] * len(points)
    for i in range(len(points)):
        arr[points[i].d] -= 1
        res[arr[points[i].d]] = points[i]
    return res


class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d


points = []
max_d = 0
fin = open('input.txt', 'r', encoding='utf8')

length = int(fin.readline())
max_distance = 0
for i in range(length):
    x, y = [int(s) for s in line.split()]
    d = int(sqrt(x*x+y*y)*10)
    max_d = max(max_d, d)
    point = Point(x, y, d)
    points.append(point)

sorted = count_sort(points, max_d)
result = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(result))
fin.close()
134/180:

from math import sqrt


def count_sort(points, max_d):
    arr = [0] * (max_d + 1)

    for p in points:
        arr[p.d] += 1
    for i in range(1, (max_d + 1)):
        arr[i] = arr[i-1] + arr[i]

    res = [0] * len(points)
    for i in range(len(points)):
        arr[points[i].d] -= 1
        res[arr[points[i].d]] = points[i]
    return res


class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d


points = []
max_d = 0
fin = open('input.txt', 'r', encoding='utf8')

length = int(fin.readline())
max_distance = 0
for i in range(length):
    x, y = [int(s) for s in line.split()]
    d = int(sqrt(x*x+y*y)*10)
    max_d = max(max_d, d)
    point = Point(x, y, d)
    points.append(point)

sorted = count_sort(points, max_d)
result = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(result))
fin.close()
134/181:

from math import sqrt


def count_sort(points, max_d):
    arr = [0] * (max_d + 1)

    for p in points:
        arr[p.d] += 1
    for i in range(1, (max_d + 1)):
        arr[i] = arr[i-1] + arr[i]

    res = [0] * len(points)
    for i in range(len(points)):
        arr[points[i].d] -= 1
        res[arr[points[i].d]] = points[i]
    return res


class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d


points = []
max_d = 0
fin = open('input.txt', 'r', encoding='utf8')

length = int(fin.readline())
max_distance = 0
for i in range(length):
    p = list(map(int, fin.readline().split()))
    x, y = [int(s) for s in line.split()]
    d = int(sqrt(x*x+y*y)*10)
    max_d = max(max_d, d)
    point = Point(x, y, d)
    points.append(point)

sorted = count_sort(points, max_d)
result = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(result))
fin.close()
134/182:

from math import sqrt


def count_sort(points, max_d):
    arr = [0] * (max_d + 1)

    for p in points:
        arr[p.d] += 1
    for i in range(1, (max_d + 1)):
        arr[i] = arr[i-1] + arr[i]

    res = [0] * len(points)
    for i in range(len(points)):
        arr[points[i].d] -= 1
        res[arr[points[i].d]] = points[i]
    return res


class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d


points = []
max_d = 0
fin = open('input.txt', 'r', encoding='utf8')

length = int(fin.readline())
max_distance = 0
for i in range(length):
    x, y = list(map(int, fin.readline().split()))
    d = int(sqrt(x*x+y*y)*10)
    max_d = max(max_d, d)
    point = Point(x, y, d)
    points.append(point)

sorted = count_sort(points, max_d)
result = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(result))
fin.close()
134/183:

from math import sqrt


def count_sort(points, max_d):
    arr = [0] * (max_d + 1)

    for p in points:
        arr[p.d] += 1
    for i in range(1, (max_d + 1)):
        arr[i] = arr[i-1] + arr[i]

    res = [0] * len(points)
    for i in range(len(points)):
        arr[points[i].d] -= 1
        res[arr[points[i].d]] = points[i]
    return res


class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d


points = []
max_d = 0
fin = open('input.txt', 'r', encoding='utf8')

length = int(fin.readline())
max_distance = 0
for i in range(length):
    x, y = list(map(int, fin.readline().split()))
    d = int(sqrt(x*x+y*y)*10)
    max_d = max(max_d, d)
    point = Point(x, y, d)
    points.append(point)

sorted = count_sort(points, max_d)
result = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(result))
fin.close()
134/184:

from math import sqrt


def count_sort(points, max_d):
    arr = [0] * (max_d + 1)

    for p in points:
        arr[p.d] += 1
    for i in range(1, (max_d + 1)):
        arr[i] = arr[i-1] + arr[i]

    res = [0] * len(points)
    for i in range(len(points)):
        arr[points[i].d] -= 1
        res[arr[points[i].d]] = points[i]
    return res


class Point:
    def __init__(self, x, y, d):
        self.x = x
        self.y = y
        self.d = d


points = []
max_d = 0
fin = open('input.txt', 'r', encoding='utf8')

length = int(fin.readline())
max_distance = 0
for i in range(length):
    x, y = list(map(int, fin.readline().split()))
    d = int(sqrt(x*x+y*y)*10)
    max_d = max(max_d, d)
    point = Point(x, y, d)
    points.append(point)

sorted = count_sort(points, max_d)
result = [f'{point.x} {point.y}' for point in sorted]
print('\n'.join(result))
fin.close()
134/185:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fout = open('output.txt', 'w', encoding='utf8')
with open("input.txt", 'r', encoding='utf8') as fin:
    for index, line in enumerate(fin):
        if index != 0:
            x, y = [int(s) for s in line.split()]
            key = math.sqrt(x**2 + y**2)
            if key in d:
                d[key] = f'{d[key]} \n{x} {y}'
            else:
                d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)


fout.close()
134/186:
import math
def merge(m1, m2, res):
    i = 0
    j = 0
    res_p = 0
    while i < len(m1) and j < len(m2):
        if m1[i] < m2[j]:
            res[res_p] = m1[i]
            res_p += 1
            i += 1
        else:
            res[res_p] = m2[j]
            res_p += 1
            j += 1
    while i < len(m1):
        res[res_p] = m1[i]
        res_p += 1
        i += 1
    while j < len(m2):
        res[res_p] = m2[j]
        res_p += 1
        j += 1


def merge_sort(inp):
    if len(inp) < 2:
        return inp
    m = len(inp) // 2
    left = merge_sort(inp[:m])
    right = merge_sort(inp[m:])
    merge(left, right, inp)

    return inp

d = {}

fin = open('input.txt', 'r', encoding='utf8')
fout = open('output.txt', 'w', encoding='utf8')

length = int(fin.readline())
max_distance = 0
for i in range(length):
    x, y = list(map(int, fin.readline().split()))
    key = math.sqrt(x**2 + y**2)
    if key in d:
        d[key] = f'{d[key]} \n{x} {y}'
    else:
        d[key] = f'{x} {y}'
keylist = merge_sort(list(d.keys()))
for key in keylist:
    print(d[key], file=fout)

fin.close
fout.close()
139/1: import pandas as pd
140/1: import pandas as pd
140/2:
data = pd.read_csv("https://raw.githubusercontent.com/iad34/seminars/master/materials/data_sem1.csv",
                   sep=";")
141/1:
data = pd.read_csv("https://raw.githubusercontent.com/iad34/seminars/master/materials/data_sem1.csv",
                   sep=";")
141/2: import pandas as pd
141/3: import pandas as pd
141/4:
data = pd.read_csv("https://raw.githubusercontent.com/iad34/seminars/master/materials/data_sem1.csv",
                   sep=";")
141/5: data.head(10)
141/6: type(data)
141/7: data.shape
141/8:
df = pd.DataFrame({'AAA' : [4,5,6,7], 'BBB' : [10,20,30,40], 'CCC' : [100,50,-30,-50]})
df
141/9: data.index
141/10: data.columns
141/11: data[["Age", "Sex", "Cabin"]].head(5)
141/12:
#print(data.index[2:5])
#print(data.columns[0])
print(data.dtypes)
141/13:
y = data['Survived'] # целевая переменная (вектор ответов)

X = data.drop("Survived", axis=1) # матрица объект-признак

X.head()
141/14: data.drop("Survived", axis=1)
141/15:
data = data.drop("Survived", axis=1) # две таблицы в памяти

# или

data.drop("Survived", axis=1, inplace=True) # изменение таблицы без создания копий

data.head()
141/16: data.groupby("Family")
141/17:
# data["Age"].apply(lambda x: 1 if x >= 18 else 0)

data["NewAge"] = data["Age"].apply(lambda x: x+100)
141/18: data["Family"] = data["Name"].apply(lambda s: s.split(";")[0])
141/19: data.groupby("Family")
141/20: grouped_family = data.groupby("Family")["Age"]
141/21: grouped_family.mean()
141/22: data.groupby("Family")[data.Age > 20]
141/23: data.groupby("Family")[data.Age > 20].head()
141/24: data.groupby("Family")['Age'].head()
141/25: data.groupby("Family")['Age' > 20].head()
141/26: data.[data.Age > 20].head()
141/27: data[data.Age > 20].head()
141/28: data[min(data.Age) > 20].head()
141/29: data[data.Age < 20].head()
141/30: data[data.Age < 20].groupby("Family").head()
141/31: data.groupby("Family").head()
141/32: data[data.Age < 20].groupby("Family")
141/33: data[data.Age < 20].groupby("Family").head()
141/34: data.groupby("Family").['Age'].min() < 20
141/35: data.groupby("Family")['Age'].min() < 20
141/36: (data.groupby("Family")['Age'].min() < 20).mean()
141/37: (data.[(data.Survived == true) & (data.Pclass == 3)].mean()
141/38: (data[(data.Survived == true) & (data.Pclass == 3)].mean()
141/39: (data[(data.Survived == true) & (data.Pclass == 3)]
141/40: (data[(data.Survived == 1) & (data.Pclass == 3)]
141/41: data[(data.Survived == 1) & (data.Pclass == 3)]
141/42:
data = pd.read_csv("https://raw.githubusercontent.com/iad34/seminars/master/materials/data_sem1.csv",
                   sep=";")
141/43: data[(data.Survived == 1) & (data.Pclass == 3)]
141/44: data[data.Pclass == 3]['Survived'].mean()
141/45: data['Survived'].count()
141/46:
data['Survived'].count()

data[data.Survived == 0].mean()
141/47: data['Survived'].value_counts()
141/48: data["IsChild"] = data["Age"].apply(lambda x: x > 20 return 1)
141/49: data["IsChild"] = data[data.Age < 20, 1, 0]
141/50: data["IsChild"] = data.where[data.Age < 20, 1, 0]
141/51: data["IsChild"] = data.where(data.Age < 20, 1, 0)
141/52: data["IsChild"] = data.where(data['Age'] < 20, 1, 0)
141/53: data["IsChild"] = data.['Age'].apply(lambda x: 'True' if x <= 4 else 'False')
141/54: data["IsChild"] = data['Age'].apply(lambda x: 'True' if x <= 4 else 'False')
141/55:
data["IsChild"] = data['Age'].apply(lambda x: 'True' if x <= 4 else 'False')
data.head()
141/56:
data["IsChild"] = data['Age'].apply(lambda x: '1' if x < 20 else '0')
data.head()
141/57:
data["IsChild"] = data['Age'].apply(lambda x: '1' if x > 20 else '0')
data.head()
141/58:
data["IsChild"] = data['Age'].apply(lambda x: '1' if x < 20 else '0')
data.head()
141/59:
# your code here
data[data.Sex == 'female' & Pclass== '1']['Survived'].mean()
141/60:
# your code here
data[data.Sex == 'female' & data.Pclass== '1']['Survived'].mean()
141/61:
# your code here
data[(data.Sex == 'female' )& (data.Pclass == '1')]['Survived'].mean()
141/62:
# your code here
data[(data.Sex == 'female' )& (data.Pclass == '1')]['Survived'].head()
141/63:
# your code here
data[(data.Sex == 'female' )& (data.Pclass == 1)]['Survived'].head()
141/64:
# your code here
data[(data.Sex == 'female' )& (data.Pclass == 1)]['Survived'].mean()
142/1:
import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
import seaborn as sns

%pylab inline
142/2:
Data = pd.read_csv("https://raw.githubusercontent.com/iad34/seminars/master/materials/data_sem1.csv",
                   sep=";")
142/3: #your code here
142/4: Data.head()
142/5: #your code here
142/6: Data.head()
142/7: #your code here
142/8: #your code here
142/9: #your code here
142/10: #your code here
142/11: Data.head()
142/12:
sns.barplot(x='Sex', y='Survived', data=Data, palette='summer')
plt.title('Sex - Survived')
plt.show()
142/13:
sns.barplot(x='Sex', y='Survived', hue='Pclass', data=Data, palette='autumn')
plt.title('Sex - Survived')
plt.show()
142/14:
sns.factorplot(x="Sex", y="Age", data=Data, kind="box") # box plot (box-and-whiskers-plot)
plt.show()
142/15:
sns.factorplot(x="Sex", y="Age",hue ="Pclass", data=Data, kind="box")
plt.show()
142/16:
print(Data['Embarked'].value_counts(dropna=False))
Data.shape
142/17:
Data.dropna(subset=['Embarked'], inplace=True)
Data.shape
142/18:
Data = pd.get_dummies(Data, columns=['Embarked'], drop_first=True)
Data.head()
142/19: #your code here
142/20:
median_age = Data['Age'].median()

Data['Age'].fillna(median_age, inplace=True)
142/21:
sns.distplot(Data['Age'], kde=True)
plt.show()
142/22:
import seaborn as sns

facet = sns.FacetGrid(data = Data, hue = "Pclass", legend_out=True, size = 5)
facet = facet.map(sns.kdeplot, "Age")
facet.add_legend();
142/23: #your code here
142/24: Data['Pclass'].value_counts()
142/25: #your code here
142/26: Data['SibSp'].value_counts()
142/27: Data['Parch'].value_counts()
142/28: #your code here
142/29: Data.head()
142/30:
#your code here
NumericData = ...
142/31: NumericData.corr()
142/32: Data.shape
142/33: Data.describe()
142/34: Data['Sex'].isnull().sum()
142/35: Data['Sex'].value_counts()
142/36: Data = Data[Data['Sex'] != 'unknown']
142/37:
Data = Data[Data['Sex'] != 'unknown']
Data.shape
142/38:
Data['Sex'] = Data['Sex'].apply(lambda x: 1 if x == 'male' else 0)
Data['Sex'] = Data['Sex'].map({ 'male': 1, 'female': 0 })
142/39: Data.head()
142/40:
Data = pd.read_csv("https://raw.githubusercontent.com/iad34/seminars/master/materials/data_sem1.csv",
                   sep=";")
142/41:
Data = Data[Data['Sex'] != 'unknown']
Data.shape
142/42:
# Data['Sex'] = Data['Sex'].apply(lambda x: 1 if x == 'male' else 0)
Data['Sex'] = Data['Sex'].map({ 'male': 1, 'female': 0 })
142/43: Data.head()
142/44:
sns.barplot(x='Sex', y='Survived', data=Data, palette='summer')
plt.title('Sex - Survived')
plt.show()
142/45:
sns.barplot(x='Sex', y='Survived', hue='Pclass', data=Data, palette='autumn')
plt.title('Sex - Survived')
plt.show()
142/46:
sns.factorplot(x="Sex", y="Age", data=Data, kind="box") # box plot (box-and-whiskers-plot)
plt.show()
142/47:
sns.factorplot(x="Sex", y="Age",hue ="Pclass", data=Data, kind="box")
plt.show()
142/48:
print(Data['Embarked'].value_counts(dropna=False))
Data.shape
142/49:
Data.dropna(subset=['Embarked'], inplace=True)
Data.shape
142/50:
Data = pd.get_dummies(Data, columns=['Embarked'], drop_first=True)
Data.head()
142/51: Data['Age'].isnull().sum()
142/52:
median_age = Data['Age'].median()

Data['Age'].fillna(median_age, inplace=True)
142/53:
sns.distplot(Data['Age'], kde=True)
plt.show()
142/54:
import seaborn as sns

facet = sns.FacetGrid(data = Data, hue = "Pclass", legend_out=True, size = 5)
facet = facet.map(sns.kdeplot, "Age")
facet.add_legend();
142/55: Data['Pclass'].value_counts()
142/56:
import seaborn as sns

facet = sns.FacetGrid(data = Data, hue = "Survived", legend_out=True, size = 5)
facet = facet.map(sns.kdeplot, "PClass")
facet.add_legend();
142/57:
import seaborn as sns

facet = sns.FacetGrid(data = Data, hue = "PClass", legend_out=True, size = 5)
facet = facet.map(sns.kdeplot, "Survived")
facet.add_legend();
142/58: Data['Pclass'].value_counts()
142/59:
import seaborn as sns

sns.barplot(x='PClass', y='Survived', data=Data, palette='summer')
plt.title('PClass - Survived')
plt.show()
142/60:
import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
import seaborn as sns

%pylab inline
142/61:
sns.barplot(x='PClass', y='Survived', data=Data, palette='winter')
plt.title('PClass - Survived')
plt.show()
142/62:

sns.barplot(x='Pclass', y='Survived', data=Data, palette='winter')
plt.title('PClass - Survived')
plt.show()
142/63: Data['SibSp'].value_counts()
142/64: Data['Parch'].value_counts()
142/65: Data.drop('PassengerId', axis=1, inplace=True)
142/66: Data.head()
142/67:
#your code here
NumericData = Data._get_numeric_data()
142/68:
#your code here
NumericData = Data._get_numeric_data()
NumericData.head()
142/69: NumericData.corr()
142/70:
colormap = plt.cm.RdBu
plt.figure(figsize=(14,12))

plt.title('Pearson Correlation of Features', y=1.05, size=18)
sns.heatmap(NumericData.corr(),
            linewidths=0.1, vmax=1.0, 
            square=True, cmap=colormap, linecolor='white', annot=True)
142/71:
g = sns.pairplot(Data[[u'Survived', u'Pclass', u'Sex', u'Age', u'Parch', u'Fare']], \
                 hue='Survived', palette = 'seismic', size=4, diag_kind = 'kde', \
                 diag_kws=dict(shade=True), plot_kws=dict(s=50) )
g.set(xticklabels=[])
142/72:
Data['AgeBin'] = pd.cut(Data['Age'].astype(int), 5)

Data['AgeBin'].head()
142/73:
from sklearn.preprocessing import LabelEncoder
label = LabelEncoder()

Data['AgeBin_Code'] = label.fit_transform(Data['AgeBin'])

Data[['Age','AgeBin','AgeBin_Code']].head()
142/74: Data.head()
142/75: Data.NameLen
142/76: Data['FamilySize'] = Data['Parch'] + Data['SibSp']+1
142/77: Data['IsAlone'] = (Data['FamilySize'] == 1).astype(int)
142/78: np.corrcoef(Data["NameLen"], Data['Survived'])[0][1]
142/79: Data['IsAlone'] = (Data['FamilySize'] == 1).astype(int)
142/80: np.corrcoef(Data['NameLen'], Data['Survived'])[0][1]
142/81: Data['NameLen'] = Data['Name'].apply(len)
142/82: np.corrcoef(Data['NameLen'], Data['Survived'])[0][1]
142/83:
def prediction(x): # Sex, Pclass
    if x.Sex == 0:
        return 1
    return 0
142/84:
from sklearn.metrics import accuracy_score

pred = Data.apply(lambda x: prediction(x), axis=1)
# сколько процентов правильных ответ дает алгоритм
accuracy_score(Data['Survived'], pred)
142/85:
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier

y = Data['Survived']
X = Data._get_numeric_data().drop('Survived', axis=1)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25)
142/86:
model = KNeighborsClassifier()

model.fit(X_train, y_train) # обучаем модель
142/87:
pred_knn = model.predict(X_test) # делаем предсказание на тесте
pred_knn
142/88: accuracy_score(y_test, pred_knn) #  доля прав.ответов knn
142/89:
pred_our = X_test.apply(lambda x: prediction(x), axis=1)

accuracy_score(y_test, pred_our) # доля прав.ответов нашей модели
144/1: import pandas as pd
144/2:
path = r'../Data'
all_files = glob.glob(os.path.join(path, "*.csv"))

df_from_file = (pd.read_csv(f) for f in all_files)
df = pd.concat(df_from_each_file)
144/3:
import glob
path = r'../Data'
all_files = glob.glob(os.path.join(path, "*.csv"))

df_from_file = (pd.read_csv(f) for f in all_files)
df = pd.concat(df_from_each_file)
144/4:
import glob
path = r'../Data'
all_files = glob.glob(os.path.join(path, "*.csv"))

df_from_file = (pd.read_csv(f) for f in all_files)
df = pd.concat(df_from_each_file)
144/5:
import glob

path = r'../Data'
all_files = glob.glob(os.path.join(path, "*.csv"))

df_from_file = (pd.read_csv(f) for f in all_files)
df = pd.concat(df_from_each_file)
144/6:
import glob

path = r'../Data'
all_files = glob.glob(os.path.join(path, "*.csv"))

# df_from_file = (pd.read_csv(f) for f in all_files)
# df = pd.concat(df_from_each_file)
144/7:
import glob

path = r'../Data'
all_files = glob.glob(os.path.join(path, "*.csv"))

# df_from_file = (pd.read_csv(f) for f in all_files)
# df = pd.concat(df_from_each_file)
144/8:
import glob
import os

path = r'../Data'
all_files = glob.glob(os.path.join(path, "*.csv"))

# df_from_file = (pd.read_csv(f) for f in all_files)
# df = pd.concat(df_from_each_file)
144/9:
import glob
import os

path = r'../Data'
all_files = glob.glob(os.path.join(path, "*.csv"))

df_from_file = (pd.read_csv(f) for f in all_files)
df = pd.concat(df_from_each_file)

df.head(10)
144/10:
import glob
import os

path = r'../Data'
all_files = glob.glob(os.path.join(path, "*.csv"))

df_from_file = (pd.read_csv(f) for f in all_files)
df = pd.concat(df_from_file)

df.head(10)
144/11:
import glob
import os

path = r'../Data'
all_files = glob.glob(os.path.join(path, "/*.csv"))

df_from_file = (pd.read_csv(f) for f in all_files)
df = pd.concat(df_from_file)

df.head(10)
144/12:
import glob
import os

path = f'../Data'
all_files = glob.glob(os.path.join(path, "/*.csv"))

df_from_file = (pd.read_csv(f) for f in all_files)
df = pd.concat(df_from_file)

df.head(10)
144/13:
import glob
import os

path = f'../Data'
all_files = glob.glob(os.path.join(path, "/*.csv"))

df_from_file = (pd.read_csv(f) for f in all_files)
df = pd.concat(df_from_file)

df.head(10)
144/14:
import glob
import os

path = f'Data'
all_files = glob.glob(os.path.join(path, "/*.csv"))

df_from_file = (pd.read_csv(f) for f in all_files)
df = pd.concat(df_from_file)

df.head(10)
144/15:
import glob
import os

path = f'./Data'
all_files = glob.glob(os.path.join(path, "/*.csv"))

df_from_file = (pd.read_csv(f) for f in all_files)
df = pd.concat(df_from_file)

df.head(10)
144/16:
import glob
import os

BASE_DIR = os.getcwd()
all_files = glob.glob(os.path.join(BASE_DIR, "Data/*.csv"))

df_from_file = (pd.read_csv(f) for f in all_files)
df = pd.concat(df_from_file)

df.head(10)
144/17:
import glob
import os

BASE_DIR = os.getcwd()
all_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))

df_from_file = (pd.read_csv(f) for f in all_files)
df = pd.concat(df_from_file)

df.head(10)
144/18:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))

marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_*.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)
info_df = pd.concat(info_df)
marks_df = pd.concat(marks_df)


marks_df.head(10)
144/19:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))

marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_*.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)
info_df = pd.concat(info)
marks_df = pd.concat(marks)


marks_df.head(10)
144/20:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))

marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_*.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)
info_df = pd.concat(info)
marks_df = pd.concat(marks)
pandas.concat(info_df, marks_df, axis=0)

marks_df.head(10)
144/21:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))

marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_*.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)
info_df = pd.concat(info)
marks_df = pd.concat(marks)
df = pandas.concat(info_df, marks_df, axis=0)

df.head(10)
144/22:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))

marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_*.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)
info_df = pd.concat(info)
marks_df = pd.concat(marks)
df = pd.concat(info_df, marks_df, axis=0)

df.head(10)
144/23:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))

marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_*.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)
info_df = pd.concat(info)
marks_df = pd.concat(marks)
df = pd.concat([info_df, marks_df], axis=0)

df.head(10)
144/24:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))

marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_*.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)

info_df = pd.concat(info)
marks_df = pd.concat(marks)
df = pd.concat([info_df, marks_df])

df.head(10)
144/25:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))

marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_*.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)

info_df = pd.DataFrame(pd.concat(info))
marks_df = pd.DataFrame(pd.concat(marks))
df = pd.concat([info_df, marks_df])

df.head(10)
144/26:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))

marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_*.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)

info_df = pd.DataFrame(pd.concat(info))
marks_df = pd.DataFrame(pd.concat(marks))
df = pd.concat([info_df, marks_df])

info_df.head(10)
144/27:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))

marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_*.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)

info_df = pd.DataFrame(pd.concat(info))
marks_df = pd.DataFrame(pd.concat(marks))
df = pd.concat([info_df, marks_df])

marks_df.head(10)
144/28:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))

marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_*.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)

info_df = pd.DataFrame(pd.concat(info))
marks_df = pd.DataFrame(pd.concat(marks))
df = pd.concat([info_df, marks_df])

info
144/29:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))

marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_*.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)

info_df = pd.DataFrame(pd.concat(info))
marks_df = pd.DataFrame(pd.concat(marks))
df = pd.concat([info_df, marks_df])

df.head(10)
144/30:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))

marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_*.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)

info_df = pd.DataFrame(pd.concat(info))
marks_df = pd.DataFrame(pd.concat(marks))
df = pd.concat([info_df, marks_df])

df.iloc(10)
144/31:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))

marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_*.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)

info_df = pd.DataFrame(pd.concat(info))
marks_df = pd.DataFrame(pd.concat(marks))
df = pd.concat([info_df, marks_df])

df.head(10)
144/32:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))
marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_*.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)

info_df = pd.DataFrame(pd.concat(info))
# marks_df = pd.DataFrame(pd.concat(marks))
# df = pd.concat([info_df, marks_df])

info_df.head(10)
144/33:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))
marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_*.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)

info_df = pd.concat(info)
# marks_df = pd.DataFrame(pd.concat(marks))
# df = pd.concat([info_df, marks_df])

info_df.head(10)
144/34:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))
marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_*.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)

info_df = pd.concat(info)
marks_df = pd.concat(marks)
# df = pd.concat([info_df, marks_df])

marks_df.head(10)
144/35:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))
marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_0.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)

info_df = pd.concat(info)
marks_df = pd.concat(marks)
# df = pd.concat([info_df, marks_df])

marks_df.head(10)
144/36:
import glob
import os

BASE_DIR = os.getcwd()
info_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_info_*.csv"))
marks_files = glob.glob(os.path.join(BASE_DIR, "Data/Students_marks_*.csv"))

info = (pd.read_csv(f) for f in info_files)
marks = (pd.read_csv(f) for f in marks_files)

info_df = pd.concat(info)
marks_df = pd.concat(marks)
# df = pd.concat([info_df, marks_df])

marks_df.head(10)
144/37:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_{i}.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_{i}.csv"))
    students.append(pd.concat([info_df, marks_df], axis=0))


df = pd.concat(students)

v.head(10)
144/38:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_{i}.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_{i}.csv"))
    students.append(pd.concat([info_df, marks_df], axis=0))


df = pd.concat(students)

df.head(10)
144/39:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_{i}.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_{i}.csv"))
    students.append(pd.concat([info_df, marks_df], axis=0))


df = pd.concat(students)

df.head(10)
144/40:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_{i}.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_{i}.csv"))
    students.append(pd.concat([info_df, marks_df], axis=0, v))


df = pd.concat(students)

df.head(10)
144/41:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_{i}.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_{i}.csv"))
    students.append(pd.concat([info_df, marks_df], axis=0, ignore_index=True))


df = pd.concat(students)

df.head(10)
144/42:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_{i}.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_{i}.csv"))
    students.append(pd.concat([info_df, marks_df], axis=0, ignore_index=True))


df = pd.concat(students)

df.size
144/43:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_{i}.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_{i}.csv"))
    students.append(pd.concat([info_df, marks_df], axis=0, ignore_index=True))


df = pd.concat(students)

df.shape()
144/44:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_{i}.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_{i}.csv"))
    students.append(pd.concat([info_df, marks_df], axis=0, ignore_index=True))


df = pd.concat(students)

df.size()
144/45:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_{i}.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_{i}.csv"))
    students.append(pd.concat([info_df, marks_df], axis=0, ignore_index=True))


df = pd.concat(students)

df.size
144/46:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_{i}.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_{i}.csv"))
    students.append(pd.concat([info_df, marks_df], axis=0, ignore_index=True))


df = pd.concat(students)

df.tail(100)
144/47:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_{i}.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_{i}.csv"))
    students.append(pd.concat([info_df, marks_df], axis=0, ignore_index=True))


df = pd.concat(students)

df
144/48:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    print(f"Data/Students_info_{i}.csv")
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_{i}.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_{i}.csv"))
    students.append(pd.concat([info_df, marks_df], axis=0, ignore_index=True))


df = pd.concat(students)

df
144/49:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_{i}.csv"))
    info.file.head(10)
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_{i}.csv"))
    students.append(pd.concat([info_df, marks_df], axis=0, ignore_index=True))


df = pd.concat(students)

df
144/50:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_{i}.csv"))
    info_file.head(10)
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_{i}.csv"))
    students.append(pd.concat([info_df, marks_df], axis=0, ignore_index=True))


df = pd.concat(students)

df
144/51:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_{i}.csv"))
    info_file.head(10)
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_{i}.csv"))
    students.append(pd.concat([info_df, marks_df], keys=["Index"], ignore_index=True))


df = pd.concat(students)

df
144/52:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_{i}.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_{i}.csv"))
    students.append(pd.concat([info_df, marks_df], keys=["Index"], ignore_index=True))


df = pd.concat(students)

df
144/53:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_{i}.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_{i}.csv"))
    students.append(pd.concat([info_df, marks_df], keys=["Index"], ignore_index=True))


df = pd.concat(students)

df.head(100)
144/54:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
    students.append(pd.concat([info_df, marks_df], keys=["Index"], ignore_index=True))


df = pd.concat(students)

df.head(100)
144/55:
import os

BASE_DIR = os.getcwd()


students = []
# for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
    students.append(pd.concat([info_df, marks_df], keys=["Index"], ignore_index=True))


df = pd.concat(students)

df.head(100)
144/56:
import os

BASE_DIR = os.getcwd()


students = []
# for i in range(0, 10):
info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
students.append(pd.concat([info_df, marks_df], keys=["Index"], ignore_index=True))


df = pd.concat(students)

df.head(100)
144/57:
import os

BASE_DIR = os.getcwd()


students = []
# for i in range(0, 10):
info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
students.append(pd.concat([info_df, marks_df], axis=0, ignore_index=True))


df = pd.concat(students)

df.head(100)
144/58:
import os

BASE_DIR = os.getcwd()


students = []
# for i in range(0, 10):
info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
students.append(pd.concat([info_df, marks_df], axis=0, ignore_index=True))


df = pd.concat(students)

df.head(100)
144/59:
import os

BASE_DIR = os.getcwd()


students = []
# for i in range(0, 10):
info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
students.append(pd.concat([info_df, marks_df], axis=0, ignore_index=True))


df = pd.concat(students)

df.head(100)
144/60:
import os

BASE_DIR = os.getcwd()


students = []
# for i in range(0, 10):
info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_1.csv"))
mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
students.append(pd.concat([info_df, marks_df], axis=0, ignore_index=True))


df = pd.concat(students)

df.head(100)
144/61:
import os

BASE_DIR = os.getcwd()


students = []
# for i in range(0, 10):
info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_1.csv"))
mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_1.csv"))
students.append(pd.concat([info_df, marks_df], axis=0, ignore_index=True))


df = pd.concat(students)

df.head(100)
144/62:
import os

BASE_DIR = os.getcwd()


students = []
# for i in range(0, 10):
info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_1.csv"))
mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_1.csv"))
students.append(pd.concat([info_df, marks_df], axis=0, ignore_index=True))


df = pd.concat(students)

df.head(100)
144/63:
import os

BASE_DIR = os.getcwd()


students = []
# for i in range(0, 10):
info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_1.csv"))
mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_1.csv"))
students.append(pd.concat([info_df, marks_df], axis=0, ignore_index=True))


df = pd.concat(students)

# df.head(100)
144/64:
import os

BASE_DIR = os.getcwd()


students = []
# for i in range(0, 10):
info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_1.csv"))
mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_1.csv"))
students.append(pd.concat([info_file, mark_file], axis=0, ignore_index=True))


df = pd.concat(students)

df.head(100)
144/65:
import os

BASE_DIR = os.getcwd()


students = []
# for i in range(0, 10):
info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
students.append(pd.concat([info_file, mark_file], axis=0, ignore_index=True))


df = pd.concat(students)

df.head(100)
144/66:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
    students.append(pd.concat([info_file, mark_file], axis=0, ignore_index=True))


df = pd.concat(students)

df.head(100)
144/67:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
    students.append(pd.concat([info_file, mark_file], axis=0))


df = pd.concat(students)

df.head(100)
144/68:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
    students.append(pd.concat([info_file, mark_file], key=['undex']))


df = pd.concat(students)

df.head(100)
144/69:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
    students.append(pd.concat([info_file, mark_file], key=['index']))


df = pd.concat(students)

df.head(100)
144/70:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
    students.append(pd.concat([info_file, mark_file], key=['Index']))


df = pd.concat(students)

df.head(100)
144/71:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
    students.append(pd.concat([info_file, mark_file]))


df = pd.concat(students)

df.head(100)
144/72:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
    students.append(pd.concat([info_file, mark_file]))
    print(mark_file)


df = pd.concat(students)

# df.head(100)
144/73:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
    students.append(pd.concat([info_file, mark_file]), axis=1)



df = pd.concat(students)

df.head(100)
144/74:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
    students.append(pd.concat([info_file, mark_file]), axis=1)

df = pd.concat(students)

df.head(100)
144/75:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
    students.append(pd.concat([info_file, mark_file], axis=1))

df = pd.concat(students)

df.head(100)
144/76:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
    students.append(pd.concat([info_file, mark_file], axis=1))

df = pd.concat(students)
144/77: data.columns
144/78: df.columns
144/79:
df = pd.drop(['index'], axis=1)
df.head(10)
144/80:
df = pd.DataFrame.drop(['index'], axis=1)
df.head(10)
144/81:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
    students.append(pd.concat([info_file, mark_file], axis=1))

df = pd.concat(students)
type(df)
144/82:
df = df.drop(['index'], axis=1)
df.head(10)
144/83: df.shape
144/84:
df = df.drop(['index'], axis=1, inplace=Tru)
df.head(10)
144/85:
df = df.drop(['index'], axis=1, inplace=True)
df.head(10)
144/86:
df = df.drop(['index'], axis=1)
df.head(10)
144/87:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
    students.append(pd.concat([info_file, mark_file], axis=1))

df = pd.concat(students)
type(df)
144/88:
df = df.drop(['index'], axis=1)
df.head(10)
144/89: df.shape
144/90: df.describe()
144/91: df.value_counts()
144/92: df.is_null()
144/93: pd.isnull(df)
144/94: df.isnull().sum()
144/95:
df['average'] = df[['math score', 'reading score', 'writing score']].mean(axis=1)

df.head(10)
144/96:
df['average'] = df[['math score', 'reading score', 'writing score']].mean(axis=1)

df.head(5)
144/97: df[df['test preparation course'] === 'completed']['math score', 'reading score', 'writing score'].mean()
144/98: df[df['test preparation course'] == 'completed']['math score', 'reading score', 'writing score'].mean()
144/99: df[df['test preparation course'] == 'completed'][['math score', 'reading score', 'writing score']].mean()
144/100: df[df['test preparation course'] == 'none'][['math score', 'reading score', 'writing score']].mean()
144/101:
c = df[df['test preparation course'] == 'completed'][['math score', 'reading score', 'writing score']].mean()
n = c = df[df['test preparation course'] == 'none'][['math score', 'reading score', 'writing score']].mean()

print(c)
print(n)
144/102:
c = df[df['test preparation course'] == 'completed'][['math score', 'reading score', 'writing score']].mean()
n = c = df[df['test preparation course'] == 'none'][['math score', 'reading score', 'writing score']].mean()

print(f'{c}\n')
print(n)
144/103:
c = df[df['test preparation course'] == 'completed'][['math score', 'reading score', 'writing score']].mean()
n = df[df['test preparation course'] == 'none'][['math score', 'reading score', 'writing score']].mean()

print(f'{c}\n')
print(n)
144/104: df['lunch'].unique()
144/105:
df.rename(columns={"parental level of education": "education", "test preparation course": "test preparation"})
df.head(5)
144/106:
df.rename(columns={"parental level of education": "education", "test preparation course": "test preparation"})
df.head(5)
144/107:
df.rename(columns={"parental level of education ": "education", "test preparation course": "test preparation"})
df.head(5)
144/108:
df.rename(columns={"parental level of education": "education", "test preparation course": "test preparation"})
df.head(5)
144/109: df.rename(columns={"parental level of education": "education", "test preparation course": "test preparation"})
144/110: passmark = 50
144/111: df[df['math score'] > 50].mean()
144/112: df[df['math score'] > 50].mean()
144/113: df[df['math score'] > 50]['math score'].mean()
144/114:
df[df['math score'] > 50]['math score'].mean()

new_df = df[df['math score'] <= 50]
144/115:
df[df['math score'] > 50]['math score'].mean()

new_df = df[df['math score'] <= 50]
new_df.shape
144/116:
df[df['math score'] > 50]['math score'].mean()

# new_df = df[df['math score'] <= 50]
# new_df.shape
144/117:
df[df['math score'] <= 50]['math score'].mean()

# new_df = df[df['math score'] <= 50]
# new_df.shape
144/118:
df[df['math score'] > 50]['math score'].mean()

# new_df = df[df['math score'] <= 50]
# new_df.shape
144/119:
df[df['math score'] > 50]]

# new_df = df[df['math score'] <= 50]
# new_df.shape
144/120:
[df['math score'] > 50].mean()

# new_df = df[df['math score'] <= 50]
# new_df.shape
144/121:
df[df['math score'] > 50][].mean()

# new_df = df[df['math score'] <= 50]
# new_df.shape
144/122:
df[df['math score'] > 50].mean()

# new_df = df[df['math score'] <= 50]
# new_df.shape
144/123:
df[df['math score'] > 50].head(10)

# new_df = df[df['math score'] <= 50]
# new_df.shape
144/124:
df[df['math score'] > 50].shape[0]

# new_df = df[df['math score'] <= 50]
# new_df.shape
144/125:
df[df['math score'] > 50].shape[0]
df.shape[0]
# new_df = df[df['math score'] <= 50]
# new_df.shape
144/126:
df[df['math score'] > 50].shape[0]/df.shape[0]*100

# new_df = df[df['math score'] <= 50]
# new_df.shape
144/127: df[df['math score'] > 50].shape[0]/df.shape[0]*100
144/128:
df[df['math score'] > 50].shape[0]/df.shape[0]*100
df[df['math score'] > 50].mean()
144/129:
df[df['math score'] > 50].shape[0]/df.shape[0]*100
df[df['math score'] > 50]['math score'].mean()
144/130: df[df['math score'] > 50].shape[0]/df.shape[0]*100
144/131:
df[df['math score'] > 50].shape[0]/df.shape[0]*100
df[df['math score'] > 50][df[test preparation] == 'completed'].mean()
144/132:
df[df['math score'] > 50].shape[0]/df.shape[0]*100
df[df['math score'] > 50][df['test preparation'] == 'completed'].mean()
144/133:
df[df['math score'] > 50].shape[0]/df.shape[0]*100
df[df['math score'] > 50]['test preparation'].mean()
144/134: df = df.rename(columns={"parental level of education": "education", "test preparation course": "test preparation"})
144/135:
df[df['math score'] > 50].shape[0]/df.shape[0]*100
df[df['math score'] > 50]['test preparation'].mean()
144/136:
df = df.rename(columns={"parental level of education": "education", "test preparation course": "test preparation"})
df.head(6)
144/137:
df[df['math score'] > 50].shape[0]/df.shape[0]*100
df[df['math score'] > 50]['test preparation' == 'completed'].mean()
144/138:
df['passed'] = (df['math score'] > 50).astype(int)
# df[df['math score'] > 50].shape[0]/df.shape[0]*100


# df[df['math score'] > 50]['test preparation' == 'completed'].mean()
144/139:
df['passed'] = (df['math score'] > 50).astype(int)
df.head(100)
# df[df['math score'] > 50].shape[0]/df.shape[0]*100


# df[df['math score'] > 50]['test preparation' == 'completed'].mean()
144/140:
df['passed'] = (df['math score'] > 50).astype(int)
df['passed'].mean()
# df[df['math score'] > 50].shape[0]/df.shape[0]*100


# df[df['math score'] > 50]['test preparation' == 'completed'].mean()
144/141:
df['passed'] = (df['math score'] > 50).astype(int)
df['passed'].mean()
df[df['math score'] > 50].shape[0]/df.shape[0]*100


# df[df['math score'] > 50]['test preparation' == 'completed'].mean()
144/142:
df['passed'] = (df['math score'] > 50).astype(int)
df['passed'].mean()
# df[df['math score'] > 50].shape[0]/df.shape[0]*100


# df[df['math score'] > 50]['test preparation' == 'completed'].mean()
144/143:
df['passed'] = (df['math score'] > 50).astype(int)
# Какая доля студентов сдала экзамен по математике (passmark > 50)
df['passed'].mean()

# Какая доля студентов, проходивших курс подготовки к экзамену, сдала экзамен по математике
df[df['test preparation'] == 'completed']['passed'].mean()
144/144:
df['passed'] = (df['math score'] > 50).astype(int)
# Какая доля студентов сдала экзамен по математике (passmark > 50)
df['passed'].mean()

# Какая доля студентов, проходивших курс подготовки к экзамену, сдала экзамен по математике
df[df['test preparation'] == 'completed']['passed'].mean()

# Какая доля женщин, не проходивших курс подготовки к экзамену, не сдала экзамен по математике?
df[df['test preparation'] == 'none' & (df.gender == 'female')]['passed'].mean()
144/145:
df['passed'] = (df['math score'] > 50).astype(int)
# Какая доля студентов сдала экзамен по математике (passmark > 50)
df['passed'].mean()

# Какая доля студентов, проходивших курс подготовки к экзамену, сдала экзамен по математике
df[df['test preparation'] == 'completed']['passed'].mean()

# Какая доля женщин, не проходивших курс подготовки к экзамену, не сдала экзамен по математике?
df[*df['test preparation'] == 'none') & (df.gender == 'female')]['passed'].mean()
144/146:
df['passed'] = (df['math score'] > 50).astype(int)
# Какая доля студентов сдала экзамен по математике (passmark > 50)
df['passed'].mean()

# Какая доля студентов, проходивших курс подготовки к экзамену, сдала экзамен по математике
df[df['test preparation'] == 'completed']['passed'].mean()

# Какая доля женщин, не проходивших курс подготовки к экзамену, не сдала экзамен по математике?
df[(df['test preparation'] == 'none') & (df.gender == 'female')]['passed'].mean()
144/147:
df['passed'] = (df['math score'] > 50).astype(int)
# Какая доля студентов сдала экзамен по математике (passmark > 50)
df['passed'].mean()

# Какая доля студентов, проходивших курс подготовки к экзамену, сдала экзамен по математике
df[df['test preparation'] == 'completed']['passed'].mean()

# Какая доля женщин, не проходивших курс подготовки к экзамену, не сдала экзамен по математике?
1 -df[(df['test preparation'] == 'none') & (df.gender == 'female')]['passed'].mean()
144/148:
df['passed'] = (df['math score'] > 50).astype(int)
# Какая доля студентов сдала экзамен по математике (passmark > 50)
df['passed'].mean()

# Какая доля студентов, проходивших курс подготовки к экзамену, сдала экзамен по математике
df[df['test preparation'] == 'completed']['passed'].mean()

# Какая доля женщин, не проходивших курс подготовки к экзамену, не сдала экзамен по математике?
1 - df[(df['test preparation'] == 'none') & (df.gender == 'female')]['passed'].mean()
144/149:
df['passed'] = (df['math score'] > 50).astype(int)
# Какая доля студентов сдала экзамен по математике (passmark > 50)
res1 = df['passed'].mean()

# Какая доля студентов, проходивших курс подготовки к экзамену, сдала экзамен по математике
res2 = df[df['test preparation'] == 'completed']['passed'].mean()

# Какая доля женщин, не проходивших курс подготовки к экзамену, не сдала экзамен по математике?
res3 = 1 - df[(df['test preparation'] == 'none') & (df.gender == 'female')]['passed'].mean()
144/150:
df['passed'] = (df['math score'] > 50).astype(int)
# Какая доля студентов сдала экзамен по математике (passmark > 50)
res1 = df['passed'].mean()
print(res1)
# Какая доля студентов, проходивших курс подготовки к экзамену, сдала экзамен по математике
res2 = df[df['test preparation'] == 'completed']['passed'].mean()
print(res2)
# Какая доля женщин, не проходивших курс подготовки к экзамену, не сдала экзамен по математике?
res3 = 1 - df[(df['test preparation'] == 'none') & (df.gender == 'female')]['passed'].mean()
print(res3)
144/151:
import time
start_time = time.time()

(df.groupby("race/ethnicity"))['reading score'].mean()

# print("--- %s seconds ---" % (time.time() - start_time)
144/152:
import time
start_time = time.time()

(df.groupby("race/ethnicity"))['reading score'].mean()

print("--- %s seconds ---" % (time.time() - start_time)
144/153:
import time
start_time = time.time()

(df.groupby("race/ethnicity"))['reading score'].mean()

print(f"--- {time.time() - start_time} seconds ---")
144/154:
import time
start_time = time.time()

(df.groupby("race/ethnicity"))['reading score'].mean()

print(f"race/ethnicity --- {time.time() - start_time} seconds ---")

start_time2 = time.time()

(df.groupby("education"))['writing score'].min()
print(f"education --- {time.time() - start_time2} seconds ---")
144/155:
import time
# start_time = time.time()

# (df.groupby("race/ethnicity"))['reading score'].mean()

# print(f"race/ethnicity --- {time.time() - start_time} seconds ---")

# start_time2 = time.time()

(df.groupby("education"))['writing score'].min()
# print(f"education --- {time.time() - start_time2} seconds ---")
144/156:
import time
start_time = time.time()

(df.groupby("race/ethnicity"))['reading score'].mean()

print(f"race/ethnicity --- {time.time() - start_time} seconds ---")

start_time2 = time.time()

(df.groupby("education"))['writing score'].min()
print(f"education --- {time.time() - start_time2} seconds ---")
144/157:
import time
start_time = time.time()

(df.groupby("race/ethnicity"))['reading score'].mean()

# print(f"race/ethnicity --- {time.time() - start_time} seconds ---")

# start_time2 = time.time()

# (df.groupby("education"))['writing score'].min()
# print(f"education --- {time.time() - start_time2} seconds ---")
144/158:
dict1 = {}
for column in df:
    key = df['race/ethnicity']
    if key not in dict1:
        dict1[key] = df['reading score']

print(dict1)
144/159:
dict1 = {}
for column in df:
    if df['race/ethnicity'] not in dict1:
        dict1[df['race/ethnicity']] = df['reading score']

print(dict1)
144/160:
dict1 = {}
for column in df:
    key = df['race/ethnicity']
    print(key)
    if df['race/ethnicity'] not in dict1:
        dict1[df['race/ethnicity']] = df['reading score']

print(dict1)
144/161:
dict1 = {}
for column in df:
    key = df['race/ethnicity']

    if df['race/ethnicity'] not in dict1:
        dict1[key] = 1

print(dict1)
144/162:
dict1 = {}
for column in df:
    key = df['race/ethnicity']

    if key not in dict1:
        dict1[key] = 1

print(dict1)
144/163:
dict1 = {}
for column in df:
    key = str(df['race/ethnicity'])

    if key not in dict1:
        dict1[key] = 1

print(dict1)
144/164:
dict1 = {}
for column in df:
    key = str(df['race/ethnicity']).rstrip()

    if key not in dict1:
        dict1[key] = 1

print(dict1)
144/165:
dict1 = {}
for column in df:
    key = str(df['race/ethnicity']).splitlines()


    if key not in dict1:
        dict1[key] = 1

print(dict1)
144/166:
dict1 = {}
for column in df:
    key = str(df['race/ethnicity']).rstrip("\n")


    if key not in dict1:
        dict1[key] = 1

print(dict1)
144/167:
dict1 = {}
for column in df:
    key = df['race/ethnicity'].name

    if key not in dict1:
        dict1[key] = 1

print(dict1)
144/168:
dict1 = {}
for column in df:
    key = df['race/ethnicity'].value

    if key not in dict1:
        dict1[key] = 1

print(dict1)
144/169:
dict1 = {}
for column in df:
    key = df['race/ethnicity'].item()
    if key not in dict1:
        dict1[key] = 1

print(dict1)
144/170:
dict1 = {}
for column in df:
    key = df['race/ethnicity'][0]
    if key not in dict1:
        dict1[key] = 1

print(dict1)
144/171:
dict1 = {}
for column in df:
    key = df.loc[df['race/ethnicity']].item()
    if key not in dict1:
        dict1[key] = 1

print(dict1)
144/172:
dict1 = {}
for column in df:
    key = df['race/ethnicity'].apply(str)
    if key not in dict1:
        dict1[key] = 1

print(dict1)
144/173:
dict1 = {}
for column in df:
    key = df['race/ethnicity'].applymap(str)
    if key not in dict1:
        dict1[key] = 1

print(dict1)
144/174:
dict1 = {}
for column in df:
    key = df['race/ethnicity'].astype(str)
    if key not in dict1:
        dict1[key] = 1

print(dict1)
144/175:
dict1 = {}
for column in df:
    key = df['race/ethnicity'].astype(str)
    print(key)
    if key not in dict1:
        dict1[key] = 1

print(dict1)
144/176:
dict1 = {}
for column in df:
    key = df['race/ethnicity'].astype(str)
    print(key)
    if key not in dict1:
        dict1[str(key)] = 1

print(dict1)
144/177:
dict1 = {}
for column in df:
    key = str(df['race/ethnicity'].astype(str))
    print(key)
    if key not in dict1:
        dict1[str(key)] = 1

print(dict1)
144/178:
dict1 = {}
for column in df:
    key = str(df['race/ethnicity'].astype(str))

    if key not in dict1:
        dict1[str(key)] = 1

print(dict1)
144/179:
values = df['race/ethnicity'].unique()
# for column in df:
#     key = str(df['race/ethnicity'].astype(str))

#     if key not in dict1:
#         dict1[str(key)] = 1

# print(dict1)
144/180:
values = df['race/ethnicity'].unique()
# for column in df:
#     key = str(df['race/ethnicity'].astype(str))

#     if key not in dict1:
#         dict1[str(key)] = 1

print(values)
144/181:
values = df['race/ethnicity'].unique()
dict1 = dict.fromkeys(values , 1)
# for column in df:
#     key = str(df['race/ethnicity'].astype(str))

#     if key not in dict1:
#         dict1[str(key)] = 1

print(values)
144/182:
values = df['race/ethnicity'].unique()
dict1 = dict.fromkeys(values , 1)
# for column in df:
#     key = str(df['race/ethnicity'].astype(str))

#     if key not in dict1:
#         dict1[str(key)] = 1

print(dict1)
144/183:
values = df['race/ethnicity'].unique()
dict1 = dict.fromkeys(values , 0)
# for column in df:
#     key = str(df['race/ethnicity'].astype(str))

#     if key not in dict1:
#         dict1[str(key)] = 1

print(dict1)
144/184:
values = df['race/ethnicity'].unique()
dict1 = dict.fromkeys(values , 0)
for label, content in df.items():
    print(f'label: {label}')
    print(f'content: {content}', sep='\n')

print(dict1)
144/185:
values = df['race/ethnicity'].unique()
dict1 = dict.fromkeys(values , 0)
for label, content in df.items():
    print(f'label: {label}')
    print(f'content: {content}', sep='\n')

# print(dict1)
144/186:
values = df['race/ethnicity'].unique()
dict1 = dict.fromkeys(values , 0)
for 'race/ethnicity', content in df.items():
    print(f'label: {label}')
    print(f'content: {content}', sep='\n')

# print(dict1)
144/187:
values = df['race/ethnicity'].unique()
dict1 = dict.fromkeys(values , 0)
for df['race/ethnicity'], content in df.items():
    print(f'label: {label}')
    print(f'content: {content}', sep='\n')

# print(dict1)
144/188:
values = df['race/ethnicity'].unique()
dict1 = dict.fromkeys(values , 0)
for colname, content in df.items():
    print(df['race/ethnicity'], content)

# print(dict1)
144/189:
values = df['race/ethnicity'].unique()
dict1 = dict.fromkeys(values , 0)
for index, row in df.iterrows():
    print(row)
    # do some logic here
# print(dict1)
144/190:
values = df['race/ethnicity'].unique()
dict1 = dict.fromkeys(values , 0)
for index, row in df.iterrows():
    print(row['race/ethnicity]).values
    # do some logic here
# print(dict1)
144/191:
values = df['race/ethnicity'].unique()
dict1 = dict.fromkeys(values , 0)
for index, row in df.iterrows():
    print(row['race/ethnicity])
    # do some logic here
# print(dict1)
144/192:
values = df['race/ethnicity'].unique()
dict1 = dict.fromkeys(values , 0)
for index, row in df.iterrows():
    print(row['race/ethnicity'])
    # do some logic here
# print(dict1)
144/193:
df['average'] = df[['math score', 'reading score', 'writing score']].mean(axis=1)

df.head(5)
144/194: import pandas as pd
144/195:
import os

BASE_DIR = os.getcwd()


students = []
for i in range(0, 10):
    info_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_info_0.csv"))
    mark_file = pd.read_csv(os.path.join(BASE_DIR, f"Data/Students_marks_0.csv"))
    students.append(pd.concat([info_file, mark_file], axis=1))

df = pd.concat(students)
type(df)
144/196:
df = df.drop(['index'], axis=1)
df.head(10)
144/197: df.shape
144/198: df.describe()
144/199: df.isnull().sum()
144/200:
df = df.rename(columns={"parental level of education": "education", "test preparation course": "test preparation"})
df.head(6)
144/201:
df['passed'] = (df['math score'] > 50).astype(int)
# Какая доля студентов сдала экзамен по математике (passmark > 50)
res1 = df['passed'].mean()
print(res1)
# Какая доля студентов, проходивших курс подготовки к экзамену, сдала экзамен по математике
res2 = df[df['test preparation'] == 'completed']['passed'].mean()
print(res2)
# Какая доля женщин, не проходивших курс подготовки к экзамену, не сдала экзамен по математике?
res3 = 1 - df[(df['test preparation'] == 'none') & (df.gender == 'female')]['passed'].mean()
print(res3)
144/202:
values = df['race/ethnicity'].unique()
dict1 = dict.fromkeys(values , 0)
for index, row in df.iterrows():
    print(row['race/ethnicity'])
    # do some logic here
# print(dict1)
144/203:
values = df['race/ethnicity'].unique()
dict1 = dict.fromkeys(values , 0)
for index, row in df.iterrows():
    print(type(row['race/ethnicity'])
    # do some logic here
# print(dict1)
144/204:
values = df['race/ethnicity'].unique()
dict1 = dict.fromkeys(values , 0)
for index, row in df.iterrows():
    print(type(row['race/ethnicity'])
    # do some logic here
# print(dict1)
144/205:
values = df['race/ethnicity'].unique()
dict1 = dict.fromkeys(values , 0)
for index, row in df.iterrows():
    print(type(row['race/ethnicity'])
144/206:
values = df['race/ethnicity'].unique()
dict1 = dict.fromkeys(values , 0)
for index, row in df.iterrows():
    print(type(row['race/ethnicity']))
144/207:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    mark = row['reading score'']
    if key is not in dict1:
        dict1[key] = mark

print(dict1)
144/208:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    mark = row['reading score']
    if key is not in dict1:
        dict1[key] = mark

print(dict1)
144/209:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    mark = row['reading score']
    if key not in dict1:
        dict1[key] = mark

print(dict1)
144/210:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    mark = row['reading score']
    if key not in dict1:
        dict1[key] = mark
    else:
        dict1[key] = (dict1[key] + mark)/len(dic1[key] + 1)

print(dict1)
144/211:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    mark = row['reading score']
    if key not in dict1:
        dict1[key] = mark
    else:
        dict1[key] = (dict1[key] + mark)/len(dict1[key] + 1)

print(dict1)
144/212:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key][mark] = score
        dict1[key][iter] = 1
    else:
        dict1[key][mark] = (dict1[key][mark] + score)/dict1[key][iter] + 1)

print(dict1)
144/213:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key][mark] = score
        dict1[key][iter] = 1
    else:
        dict1[key][mark] = (dict1[key][mark] + score)/(dict1[key][iter] + 1)

print(dict1)
144/214:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key][mark] = score
        dict1[key][iter] = 1
    else:
        dict1[key][mark] = (dict1[key][mark] + score)/(dict1[key][iter] + 1)

print(dict1)
144/215:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key][mark] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key][mark] = (dict1[key][mark] + score)/(dict1[key]['iter'] + 1)

print(dict1)
144/216:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key][mark] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key][mark] = (dict1[key][mark] + score)/(dict1[key]['iter'] + 1)
        dict1[key]['iter'] = dict1[key]['iter'] + 1

print(dict1)
144/217:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = (dict1[key]['mark'] + score)/(dict1[key]['iter'] + 1)
        dict1[key]['iter'] = dict1[key]['iter'] + 1

print(dict1)
144/218:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
#     else:
#         dict1[key]['mark'] = (dict1[key]['mark'] + score)/(dict1[key]['iter'] + 1)
#         dict1[key]['iter'] = dict1[key]['iter'] + 1

print(dict1)
144/219:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = (dict1[key]['mark'] + score)/(dict1[key]['iter'] + 1)
        dict1[key]['iter'] = dict1[key]['iter'] + 1

print(dict1)
144/220:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        print(dict1[key]['mark'] + score)
        dict1[key]['mark'] = (dict1[key]['mark'] + score)/(dict1[key]['iter'] + 1)
        dict1[key]['iter'] = dict1[key]['iter'] + 1

# print(dict1)
144/221:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = dict1[key]['mark'] + score
        dict1[key]['iter'] += 1

print(dict1)
144/222:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = dict1[key]['mark'] + score
        dict1[key]['iter'] += 1
for key in dict1:
    dict1[key]['average'] = dict1[key]['mark']/dict1[key]['iter']
print(dict1)
144/223:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = dict1[key]['mark'] + score
        dict1[key]['iter'] += 1
for key in dict1:
    dict1[key]['average'] = dict1[key]['mark']/dict1[key]['iter']
print(dict1, sep='/n')
144/224:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = dict1[key]['mark'] + score
        dict1[key]['iter'] += 1
for key in dict1:
    dict1[key]['average'] = dict1[key]['mark']/dict1[key]['iter']
print(**dict1, sep='/n')
144/225:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = dict1[key]['mark'] + score
        dict1[key]['iter'] += 1
for key in dict1:
    dict1[key]['average'] = dict1[key]['mark']/dict1[key]['iter']
print(**dict1)
144/226:
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = dict1[key]['mark'] + score
        dict1[key]['iter'] += 1
for key in dict1:
    dict1[key]['average'] = dict1[key]['mark']/dict1[key]['iter']
print(dict1, sep='/n')
144/227:
import time
start_time = time.time()
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = dict1[key]['mark'] + score
        dict1[key]['iter'] += 1
for key in dict1:
    dict1[key]['average'] = dict1[key]['mark']/dict1[key]['iter']

print(f"race/ethnicity --- {time.time() - start_time} seconds ---")
144/228:
import time
start_time = time.time()

(df.groupby("race/ethnicity"))['reading score'].mean()

print(f"race/ethnicity --- {time.time() - start_time} seconds ---")

start_time2 = time.time()

(df.groupby("education"))['writing score'].min()
print(f"education --- {time.time() - start_time2} seconds ---")
144/229:
import time
start_time = time.time()
dict1 = {}
for index, row in df.iterrows():
    key = row['education']
    score = row['writing score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = dict1[key]['mark'] + score
        dict1[key]['iter'] += 1
for key in dict1:
    dict1[key]['average'] = dict1[key]['mark']/dict1[key]['iter']

print(f"race/ethnicity --- {time.time() - start_time} seconds ---")
144/230:
import time
start_time = time.time()
dict1 = {}
for index, row in df.iterrows():
    key = row['education']
    score = row['writing score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = dict1[key]['mark'] + score
        dict1[key]['iter'] += 1
for key in dict1:
    dict1[key]['average'] = dict1[key]['mark']/dict1[key]['iter']

print(f"education --- {time.time() - start_time} seconds ---")
144/231:
import time
start_time = time.time()
dict1 = {}
for index, row in df.iterrows():
    key = row['education']
    score = row['writing score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['min'] = score
    else:
        if dict1[key]['min'] > score:
            dict1[key]['min'] = score

print(dict1)
# print(f"education --- {time.time() - start_time} seconds ---")
144/232:
import time
start_time = time.time()

(df.groupby("race/ethnicity"))['reading score'].mean()

print(f"race/ethnicity --- {time.time() - start_time} seconds ---")

start_time2 = time.time()

print((df.groupby("education"))['writing score'].min())
print(f"education --- {time.time() - start_time2} seconds ---")
144/233:
import time
start_time = time.time()

print((df.groupby("race/ethnicity"))['reading score'].mean())

print(f"race/ethnicity --- {time.time() - start_time} seconds ---")

start_time2 = time.time()

print((df.groupby("education"))['writing score'].min())
print(f"education --- {time.time() - start_time2} seconds ---")
144/234:
import time
start_time = time.time()
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = dict1[key]['mark'] + score
        dict1[key]['iter'] += 1
for key in dict1:
    dict1[key]['average'] = dict1[key]['mark']/dict1[key]['iter']
    print(f'{ dict1[key]}: {dict1[key]['average']})

print(f"race/ethnicity --- {time.time() - start_time} seconds ---")
144/235:
import time
start_time = time.time()
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = dict1[key]['mark'] + score
        dict1[key]['iter'] += 1
for key in dict1:
    dict1[key]['average'] = dict1[key]['mark']/dict1[key]['iter']
    print(f'{ dict1[key]}: {dict1[key]['average']}')

print(f"race/ethnicity --- {time.time() - start_time} seconds ---")
144/236:
import time
start_time = time.time()
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = dict1[key]['mark'] + score
        dict1[key]['iter'] += 1
for key in dict1:
    dict1[key]['average'] = dict1[key]['mark']/dict1[key]['iter']
    print(f'{ dict1[key]}: {dict1[key][average]}')

print(f"race/ethnicity --- {time.time() - start_time} seconds ---")
144/237:
import time
start_time = time.time()
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = dict1[key]['mark'] + score
        dict1[key]['iter'] += 1
for key in dict1:
    dict1[key]['average'] = dict1[key]['mark']/dict1[key]['iter']
    print(f'{ dict1[key]}: {dict1[key]['average']}')

print(f"race/ethnicity --- {time.time() - start_time} seconds ---")
144/238:
import time
start_time = time.time()
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = dict1[key]['mark'] + score
        dict1[key]['iter'] += 1
for key in dict1:
    dict1[key]['average'] = dict1[key]['mark']/dict1[key]['iter']
    print(f'{ dict1[key]}: {dict1[key]["average"]}')

print(f"race/ethnicity --- {time.time() - start_time} seconds ---")
144/239:
import time
start_time = time.time()
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = dict1[key]['mark'] + score
        dict1[key]['iter'] += 1
for key in dict1:
    dict1[key]['average'] = dict1[key]['mark']/dict1[key]['iter']
    print(f'{key}: {dict1[key]["average"]}')

print(f"race/ethnicity --- {time.time() - start_time} seconds ---")
144/240:
import time
start_time = time.time()
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = dict1[key]['mark'] + score
        dict1[key]['iter'] += 1
for key in dict1:
    dict1[key]['average'] = dict1[key]['mark']/dict1[key]['iter']
    print(f'{key}: {dict1[key]["average"]}')

print(f"race/ethnicity --- {time.time() - start_time} seconds ---")
144/241:
import time
start_time = time.time()
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = dict1[key]['mark'] + score
        dict1[key]['iter'] += 1
for key in dict1:
    dict1[key]['average'] = dict1[key]['mark']/dict1[key]['iter']
    print(f'{key}: {dict1[key]["average"]}')

print(f"race/ethnicity --- {time.time() - start_time} seconds ---")
144/242:
import time
start_time = time.time()
dict1 = {}
for index, row in df.iterrows():
    key = row['race/ethnicity']
    score = row['reading score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['mark'] = score
        dict1[key]['iter'] = 1
    else:
        dict1[key]['mark'] = dict1[key]['mark'] + score
        dict1[key]['iter'] += 1
for key in dict1:
    dict1[key]['average'] = dict1[key]['mark']/dict1[key]['iter']
    print(f'{key}: {dict1[key]["average"]}')

print(f"race/ethnicity --- {time.time() - start_time} seconds ---")
144/243:
import time
start_time = time.time()
dict1 = {}
for index, row in df.iterrows():
    key = row['education']
    score = row['writing score']
    if key not in dict1:
        dict1[key] = {}
        dict1[key]['min'] = score
    else:
        if dict1[key]['min'] > score:
            dict1[key]['min'] = score

print(dict1)
print(f"education --- {time.time() - start_time} seconds ---")
144/244:
grouped = pd.pivot_table(df,index=['gender','education'])
grouped
144/245:
grouped = pd.pivot_table(df,index=['gender','education'], values=['math score', 'reading score', 'writing score'])
grouped
144/246: df[Math_PassStatus] = df['math score'].apply(lamda x: 'F' x < 50 else 'P')
144/247:
df[Math_PassStatus] = df['math score'].apply(lambda x: 'F' x < 50 else 'P')

df
144/248:
df[Math_PassStatus] = df['math score'].apply(lambda x: 'F' if x < 50 else 'P')

df
144/249:
df['Math_PassStatus'] = df['math score'].apply(lambda x: 'F' if x < 50 else 'P')

df
144/250:
df['Math_PassStatus'] = df['math score'].apply(lambda x: 'F' if x < 50 else 'P')

df['Math_PassStatus'].value_counts()
144/251:
df['Reading_PassStatus'] = df['reading score'].apply(lambda x: 'F' if x < 50 else 'P')

df['Math_PassStatus'].value_counts()
144/252:
df['Reading_PassStatus'] = df['reading score'].apply(lambda x: 'F' if x < 50 else 'P')

df['Reading_PassStatus'].value_counts()
144/253:
df['Writing_PassStatus'] = df['writing score'].apply(lambda x: 'F' if x < 50 else 'P')

df['Writing_PassStatus'].value_counts()
144/254:
df[OverAll_PassStatus] = df.apply(lambda row: 'F'if row['math score'] == 'F' & row['reading score'] == 'F' 
                                  & row['writing score'] == 'F' else 'P', axis=1)
df.head(10)
144/255:
df[OverAll_PassStatus] = df.apply(lambda row: 'F'if row['math score'] == 'F' and row['reading score'] == 'F' 
                                  and row['writing score'] == 'F' else 'P', axis=1)
df.head(10)
144/256:
df['OverAll_PassStatus'] = df.apply(lambda row: 'F'if row['math score'] == 'F' and row['reading score'] == 'F' 
                                  and row['writing score'] == 'F' else 'P', axis=1)
df.head(10)
144/257:
df['OverAll_PassStatus'] = df.apply(lambda row: 'P' if row['math score'] == 'P' and row['reading score'] == 'P' 
                                  and row['writing score'] == 'P' else 'F', axis=1)
df.head(10)
144/258:
df['OverAll_PassStatus'] = df.apply(lambda row: 'P' if (row['math score'] == 'P') and (row['reading score'] == 'P') 
                                  and (row['writing score'] == 'P') else 'F', axis=1)
df.head(10)
144/259:
df['OverAll_PassStatus'] = df.apply(lambda row: 'P' if (row['math score'] == 'P') and (row['reading score'] == 'P') 
                                  and (row['writing score'] == 'P') else 'F', axis=0)
df.head(10)
144/260:
df['OverAll_PassStatus'] = df.apply(lambda row: 'P' if (row['math score'] == 'P') and (row['reading score'] == 'P') 
                                  and (row['writing score'] == 'P') else 'F', axis=1)
df.head(10)
144/261:
df['OverAll_PassStatus'] = df.apply(lambda row: 'P' if (row['Math_PassStatus'] == 'P') and (row['Reading_PassStatus'] == 'P') 
                                  and (row['Writing_PassStatus'] == 'P') else 'F', axis=1)
df.head(10)
144/262:
df['OverAll_PassStatus'] = df.apply(lambda row: 'P' if (row['Math_PassStatus'] == 'P') and (row['Reading_PassStatus'] == 'P') 
                                  and (row['Writing_PassStatus'] == 'P') else 'F', axis=1)
df.head(10)
144/263:
def GetGrade(average_mark):
    # your code here    

# your code here
144/264: df[df['OverAll_PassStatus'] =='P']
144/265: df[df['OverAll_PassStatus'] =='P'].values[0]
144/266: df[df['OverAll_PassStatus'] =='P'].value_counts()
144/267: df[df['OverAll_PassStatus'] =='P'].shape()
144/268: df[df['OverAll_PassStatus'] =='P'].shape
144/269: df[df['OverAll_PassStatus'] =='P'].shape[0]
144/270: df[df['OverAll_PassStatus'] =='P']
144/271: df[df['OverAll_PassStatus'] =='P'].shape[0]
144/272:
df['OverAll_PassStatus'] = df.apply(lambda row: 'P' if (row['Math_PassStatus'] == 'P') and (row['Reading_PassStatus'] == 'P') 
                                  and (row['Writing_PassStatus'] == 'P') else 'F', axis=1)
df.head(5)
144/273:
df.head(10)

def GetGrade(average_mark):
    # your code here    

# your code here
144/274:
df.head(10)

def GetGrade(average_mark):
    pass
144/275:


def GetGrade(average_mark):
    pass

df.head(10)
144/276:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(average_mark):
    if average_mark in a:
        return 'A'
    elif average_mark in b:
        return 'B'
    elif average_mark in c:
        return 'C'
    elif average_mark in d:
        return 'C'
    elif average_mark in e:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score']
                                           + row['writing score'])/3, axis=1)
df.head(10)
144/277:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(average_mark):
    if average_mark in a:
        return 'A'
    elif average_mark in b:
        return 'B'
    elif average_mark in c:
        return 'C'
    elif average_mark in d:
        return 'C'
    elif average_mark in e:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])/3, axis=1)
144/278:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(average_mark):
    if average_mark in a:
        return 'A'
    elif average_mark in b:
        return 'B'
    elif average_mark in c:
        return 'C'
    elif average_mark in d:
        return 'C'
    elif average_mark in e:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])/3, axis=1)
144/279:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(average_mark):
    if average_mark in a:
        return 'A'
    elif average_mark in b:
        return 'B'
    elif average_mark in c:
        return 'C'
    elif average_mark in d:
        return 'C'
    elif average_mark in e:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])/3, axis=1)
144/280:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(average_mark):
    if average_mark in a:
        return 'A'
    elif average_mark in b:
        return 'B'
    elif average_mark in c:
        return 'C'
    elif average_mark in d:
        return 'C'
    elif average_mark in e:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] + row['writing score'])/3, axis=1)
144/281:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(average_mark):
    if average_mark in a:
        return 'A'
    elif average_mark in b:
        return 'B'
    elif average_mark in c:
        return 'C'
    elif average_mark in d:
        return 'C'
    elif average_mark in e:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])/3), axis=1)
144/282:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(average_mark):
    if average_mark in a:
        return 'A'
    elif average_mark in b:
        return 'B'
    elif average_mark in c:
        return 'C'
    elif average_mark in d:
        return 'C'
    elif average_mark in e:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])/3), axis=1)
df.head(5)
144/283:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(average_mark):
    print(average_mark)
    if average_mark in a:
        return 'A'
    elif average_mark in b:
        return 'B'
    elif average_mark in c:
        return 'C'
    elif average_mark in d:
        return 'C'
    elif average_mark in e:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])/3), axis=1)
144/284:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(average_mark):
    print(average_mark in c)
    if average_mark in a:
        return 'A'
    elif average_mark in b:
        return 'B'
    elif average_mark in c:
        return 'C'
    elif average_mark in d:
        return 'C'
    elif average_mark in e:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])/3), axis=1)
144/285:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(average_mark):

    if average_mark in a:
        return 'A'
    elif average_mark in b:
        return 'B'
    elif average_mark in c:
        return 'C'
    elif average_mark in d:
        return 'C'
    elif average_mark in e:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])/3), axis=1)
144/286:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(average_mark):
    if a>=90 and a<=100:
        return 'A'
    elif a>=80 and a<90:
        return 'B'
    elif a>=70 and a<80:
        return 'C'
    elif a>=60 and a<70:
        return 'C'
    elif a>=50 and a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])/3), axis=1)
144/287:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(average_mark):
    if a>=90 & a<=100:
        return 'A'
    elif a>=80 & a<90:
        return 'B'
    elif a>=70 & a<80:
        return 'C'
    elif a>=60 & a<70:
        return 'C'
    elif a>=50 & a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])/3), axis=1)
144/288:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(average_mark):
    print(average_mark)
    if a>=90 & a<=100:
        return 'A'
    elif a>=80 & a<90:
        return 'B'
    elif a>=70 & a<80:
        return 'C'
    elif a>=60 & a<70:
        return 'C'
    elif a>=50 & a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])/3), axis=1)
144/289:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(a):
    if a>=90 & a<=100:
        return 'A'
    elif a>=80 & a<90:
        return 'B'
    elif a>=70 & a<80:
        return 'C'
    elif a>=60 & a<70:
        return 'C'
    elif a>=50 & a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])/3), axis=1)
144/290:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(a):
    print(a)
    if a>=90 & a<=100:
        return 'A'
    elif a>=80 & a<90:
        return 'B'
    elif a>=70 & a<80:
        return 'C'
    elif a>=60 & a<70:
        return 'C'
    elif a>=50 & a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])/3), axis=1)
144/291:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(a):
    print(a)
    return 'test'
    if a>=90 & a<=100:
        return 'A'
    elif a>=80 & a<90:
        return 'B'
    elif a>=70 & a<80:
        return 'C'
    elif a>=60 & a<70:
        return 'C'
    elif a>=50 & a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])/3), axis=1)
144/292:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(a):
    if a>=90 & a<=100:
        return 'A'
    elif a>=80 & a<90:
        return 'B'
    elif a>=70 & a<80:
        return 'C'
    elif a>=60 & a<70:
        return 'C'
    elif a>=50 & a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade(round(row['math score'] + row['reading score'] 
                                             + row['writing score'])/3), axis=1)
144/293:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(a):
    print(a)
    if a>=90 & a<=100:
        return 'A'
    elif a>=80 & a<90:
        return 'B'
    elif a>=70 & a<80:
        return 'C'
    elif a>=60 & a<70:
        return 'C'
    elif a>=50 & a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade(round(row['math score'] + row['reading score'] 
                                             + row['writing score'])/3), axis=1)
144/294:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(a):
    print(a)
    if a>=90 & a<=100:
        return 'A'
    elif a>=80 & a<90:
        return 'B'
    elif a>=70 & a<80:
        return 'C'
    elif a>=60 & a<70:
        return 'C'
    elif a>=50 & a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade(round(row['math score'] + row['reading score'] 
                                             + row['writing score'])/3)), axis=1)
144/295:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(a):
    print(a)
    if a>=90 & a<=100:
        return 'A'
    elif a>=80 & a<90:
        return 'B'
    elif a>=70 & a<80:
        return 'C'
    elif a>=60 & a<70:
        return 'C'
    elif a>=50 & a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade(round((row['math score'] + row['reading score'] 
                                             + row['writing score'])/3)), axis=1)
144/296:
f = (0, 50)
e = (50, 60)
d = (60, 70)
c = (70, 80)
b = (80, 90)
a = (90, 101)

def GetGrade(a):
    print(a)
    if a>=90 & a<=100:
        return 'A'
    elif a>=80 & a<90:
        return 'B'
    elif a>=70 & a<80:
        return 'C'
    elif a>=60 & a<70:
        return 'C'
    elif a>=50 & a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade(round((row['math score'] + row['reading score'] 
                                             + row['writing score'])/3)), axis=1)

df.head(5)
144/297:
def GetGrade(a):
    if a>=90 & a<=100:
        return 'A'
    elif a>=80 & a<90:
        return 'B'
    elif a>=70 & a<80:
        return 'C'
    elif a>=60 & a<70:
        return 'C'
    elif a>=50 & a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade(round((row['math score'] + row['reading score'] 
                                             + row['writing score'])/3)), axis=1)

df.head(5)
144/298:
def GetGrade(a):
    if a>=90 & a<=100:
        return 'A'
    elif a>=80 & a<90:
        return 'B'
    elif a>=70 & a<80:
        return 'C'
    elif a>=60 & a<70:
        return 'C'
    elif a>=50 & a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])//3), axis=1)

df.head(5)
144/299:
def GetGrade(a):
    print(a)
    if a>=90 & a<=100:
        return 'A'
    elif a>=80 & a<90:
        return 'B'
    elif a>=70 & a<80:
        return 'C'
    elif a>=60 & a<70:
        return 'C'
    elif a>=50 & a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])//3), axis=1)

df.head(5)
144/300:
def GetGrade(a):
    print(a)
    if a>=90 and a<=100:
        return 'A'
    elif a>=80 and a<90:
        return 'B'
    elif a>=70 and a<80:
        return 'C'
    elif a>=60 and a<70:
        return 'C'
    elif a>=50 and a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])//3), axis=1)

df.head(5)
144/301:
def GetGrade(a):
    if a>=90 and a<=100:
        return 'A'
    elif a>=80 and a<90:
        return 'B'
    elif a>=70 and a<80:
        return 'C'
    elif a>=60 and a<70:
        return 'C'
    elif a>=50 and a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])//3), axis=1)

df.head(5)
144/302:
def GetGrade(a):
    if a>=90 and a<=100:
        return 'A'
    elif a>=80 and a<90:
        return 'B'
    elif a>=70 and a<80:
        return 'C'
    elif a>=60 and a<70:
        return 'C'
    elif a>=50 and a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])//3), axis=1)

df.groupBy('Grade')
144/303:
def GetGrade(a):
    if a>=90 and a<=100:
        return 'A'
    elif a>=80 and a<90:
        return 'B'
    elif a>=70 and a<80:
        return 'C'
    elif a>=60 and a<70:
        return 'C'
    elif a>=50 and a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])//3), axis=1)

df.groupby('Grade')
144/304:
def GetGrade(a):
    if a>=90 and a<=100:
        return 'A'
    elif a>=80 and a<90:
        return 'B'
    elif a>=70 and a<80:
        return 'C'
    elif a>=60 and a<70:
        return 'C'
    elif a>=50 and a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])//3), axis=1)

df.groupby('Grade').sum()
144/305:
def GetGrade(a):
    if a>=90 and a<=100:
        return 'A'
    elif a>=80 and a<90:
        return 'B'
    elif a>=70 and a<80:
        return 'C'
    elif a>=60 and a<70:
        return 'C'
    elif a>=50 and a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])//3), axis=1)

df.groupby('Grade').value_count()
144/306:
def GetGrade(a):
    if a>=90 and a<=100:
        return 'A'
    elif a>=80 and a<90:
        return 'B'
    elif a>=70 and a<80:
        return 'C'
    elif a>=60 and a<70:
        return 'C'
    elif a>=50 and a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])//3), axis=1)

df.groupby('Grade').value_counts()
144/307:
def GetGrade(a):
    if a>=90 and a<=100:
        return 'A'
    elif a>=80 and a<90:
        return 'B'
    elif a>=70 and a<80:
        return 'C'
    elif a>=60 and a<70:
        return 'C'
    elif a>=50 and a<60:
        return 'E'
    else:
        return 'F'

df['Grade'] = df.apply(lambda row: GetGrade((row['math score'] + row['reading score'] 
                                             + row['writing score'])//3), axis=1)

df.groupby('Grade').size()
146/1:
import numpy as np         # библиотека для матриц и математики
import pandas as pd        # библиотека дл работы с табличками
from scipy import stats    # модуль для работы со статистикой

# библиотеки для визуализации
import matplotlib.pyplot as plt
import seaborn as sns

plt.style.use('ggplot')    # стиль графиков
%matplotlib inline
146/2: norm_rv = stats.norm(loc=0, scale=1)  # задали генератор
146/3:
sample = norm_rv.rvs(1000)  # сгенерируем 1000 значений
sample[:10]
146/4: sample.shape
146/5: sample.mean()
146/6: norm_rv.pdf(1)
146/7:
x = np.linspace(-3, 3, 100)
pdf = norm_rv.pdf(x)
146/8:
plt.plot(x, pdf)
plt.ylabel('$f(x)$')
plt.xlabel('$x$')

# На ней же нарисуем f(1)
plt.scatter([1,2], 
            [norm_rv.pdf(1), norm_rv.pdf(2)], color="blue");
146/9: norm_rv.cdf(1)
146/10:
x = np.linspace(-3, 3, 100)
pdf = norm_rv.pdf(x)

plt.plot(x, pdf)
plt.ylabel('$f(x)$')
plt.xlabel('$x$')

# На ней же нарисуем f(1)
plt.scatter([1], [norm_rv.pdf(1)], color="blue");

# на ту же картинку добавили новую часть, штриховку
xq = np.linspace(-3, 1, 100)
yq = norm_rv.pdf(xq)
plt.fill_between(xq, 0, yq, color='blue', alpha=0.2)

plt.axvline(1, color='blue', linestyle="--", lw=2);
146/11:
# правило 3 сигм
for x in [1,2,3]:
    print(f'P({-x} <X< {x}) = ',norm_rv.cdf(x)-norm_rv.cdf(-x))
146/12: norm_rv.cdf(3) - norm_rv.cdf(1)
146/13:
x = np.linspace(-5, 5, 100)
pdf = norm_rv.pdf(x)

plt.plot(x, pdf)
plt.ylabel('$f(x)$')
plt.xlabel('$x$')

# На ней же нарисуем f(1)
plt.scatter([1, 3], [norm_rv.pdf(1), norm_rv.pdf(3)], color="blue");

# на ту же картинку добавили новую часть, штриховку
xq = np.linspace(1, 3)
yq = norm_rv.pdf(xq)
plt.fill_between(xq, 0, yq, color='blue', alpha=0.2)

plt.axvline(1, color='blue', linestyle="--", lw=2)
plt.axvline(3, color='blue', linestyle="--", lw=2);
146/14:
q = norm_rv.ppf(0.999)
# q = norm_rv.ppf(0.5)  # медиана
q
146/15:
x = np.linspace(-3, 3, 100)
pdf = norm_rv.pdf(x)

plt.plot(x, pdf)
plt.ylabel('$f(x)$')
plt.xlabel('$x$')

xq = np.linspace(-3, q)
yq = norm_rv.pdf(xq)
plt.fill_between(xq, 0, yq, color='blue', alpha=0.2)

plt.axvline(q, color='blue', linestyle="--", lw=2)

y_max = plt.ylim()[1]
plt.text(q + 0.1, 0.8*y_max, round(q,2), color='blue', fontsize=16);
146/16: sample[:10]
146/17: sample.shape
146/18: np.mean(sample)  # выборочное среднее(при больших n похоже на математическое ожидание)
146/19: np.var(sample)   # выборочная дисперсия
146/20: np.std(sample)   # выборочное стандартное отклонение
146/21: np.median(sample) # выборочная медиана
146/22: plt.hist(sample, bins=1000);  # bins отвечает за число столбцов
146/23: plt.hist(sample, bins=10);  # bins отвечает за число столбцов
146/24:
x = np.linspace(-3, 3, 100)
pdf = norm_rv.pdf(x)

# плотность 
plt.plot(x, pdf, lw=3)

# гистограмма, параметр density отнормировал её. 
plt.hist(sample, bins=30, density=True);

plt.ylabel('$f(x)$')
plt.xlabel('$x$');
146/25:
# для построения ECDF используем библиотеку statsmodels
from statsmodels.distributions.empirical_distribution import ECDF

ecdf = ECDF(sample)   # строим эмпирическую функцию по выборке

plt.step(ecdf.x, ecdf.y)
plt.ylabel('$F(x)$', fontsize=20)
plt.xlabel('$x$', fontsize=20);
146/26:
x = np.linspace(-3, 3, 100)

# теоретическа cdf 
cdf = norm_rv.cdf(x)
plt.plot(x, cdf, label='theoretical CDF')

# эмпирическая сdf
ecdf = ECDF(sample)
plt.step(ecdf.x, ecdf.y, label='empirical CDF')

plt.ylabel('$F(x)$')
plt.xlabel('$x$')
plt.legend(loc='upper left');
146/27: np.arange(1,11)
146/28:
np.random.choice(np.arange(1,11), 
                 size=5,
                 replace=False) # выборка без повторений
146/29:
np.random.choice(np.arange(1,11), 
                 size=5,
                replace=True) # с повторениями
146/30:
np.random.choice(['карась', 'плотва', 'щука'], 
                 size=10, 
                 p=[0.5, 0.2, 0.3]) # с повторениями
146/31:
np.random.choice(np.arange(1,11), 
                 size=5,
                replace=True) # с повторениями
146/32:
np.random.choice(np.arange(1,11), 
                 size=5,
                replace=True) # с повторениями
146/33:
np.random.choice(np.arange(1,11), 
                 size=5,
                replace=True) # с повторениями
146/34:
np.random.choice(np.arange(1,11), 
                 size=5,
                replace=True) # с повторениями
146/35:
np.random.choice(np.arange(1,11), 
                 size=5,
                replace=True) # с повторениями
146/36:
np.random.choice(np.arange(1,11), 
                 size=5,
                replace=True) # с повторениями
146/37:
np.random.choice(np.arange(1,11), 
                 size=5,
                replace=True) # с повторениями
146/38:
np.random.choice(['карась', 'плотва', 'щука'], 
                 size=10, 
                 p=[0.5, 0.2, 0.3]) # с повторениями
146/39:
np.random.choice(['карась', 'плотва', 'щука'], 
                 size=10, 
                 p=[0.5, 0.2, 0.3]) # с повторениями
146/40:
np.random.choice(['карась', 'плотва', 'щука'], 
                 size=10, 
                 p=[0.5, 0.2, 0.3]) # с повторениями
146/41:
np.random.choice(['карась', 'плотва', 'щука'], 
                 size=10, 
                 p=[0.5, 0.2, 0.3]) # с повторениями
146/42:
np.random.choice(['карась', 'плотва', 'щука'], 
                 size=3, 
                 p=[0.5, 0.2, 0.3]) # с повторениями
146/43:
np.random.choice(['карась', 'плотва', 'щука'], 
                 size=4, 
                 p=[0.5, 0.2, 0.3]) # с повторениями
146/44:
np.random.choice(['карась', 'плотва', 'щука'], 
                 size=4, 
                 p=[0.5, 0.2, 0.3]) # с повторениями
146/45:
np.random.choice(['карась', 'плотва', 'щука'], 
                 size=4, 
                 p=[0.5, 0.2, 0.3]) # с повторениями
146/46:
np.random.choice(['карась', 'плотва', 'щука'], 
                 size=4, 
                 p=[0.5, 0.2, 0.3]) # с повторениями
146/47:
np.random.choice(['карась', 'плотва', 'щука'], 
                 size=4, 
                 p=[0.5, 0.2, 0.3]) # с повторениями
146/48:
np.random.choice(['карась', 'плотва', 'щука'], 
                 size=4, 
                 p=[0.5, 0.2, 0.3]) # с повторениями
146/49:
rv = stats.norm(loc=3, scale=2)
rv.rvs(5)
146/50: stats.norm(loc=3, scale=2).rvs(5)
146/51: stats.norm(loc=3, scale=2).rvs(5, random_state=111)
146/52: stats.norm(loc=3, scale=2).rvs(5, random_state=111)
148/1:
import numpy as np         # библиотека для матриц и математики
import pandas as pd        # библиотека для работы с табличками
from scipy import stats    # модуль для работы со статистикой

# библиотеки для визуализации
import matplotlib.pyplot as plt
import seaborn as sns

plt.style.use('ggplot')    # стиль графиков
148/2: %matplotlib inline
148/3: df = pd.read_csv("../data/youtube_data_short.csv", sep = "\t")
148/4: df = pd.read_csv("./data/youtube_data_short.csv", sep = "\t")
148/5: print(df.shape)
148/6: np.nanmean(df.likeCount.values)
148/7: df.likeCount.dropna().values.mean()
148/8: df.likeCount.max()
148/9:
mx = df.likeCount.max()
mx
148/10: df[df.likeCount == mx]
148/11: df.likeCount.mean()
148/12: df.likeCount.median()
148/13: df.likeCount.hist(bins=50, density=True);
150/1:
import pandas as pd
import numpy as np
import seaborn as sns
150/2:
import pandas as pd
import numpy as np
import seaborn as sns
150/3: np.random.seed(42)
150/4: data = pd.read_csv('bike_buyers_clean.csv')
150/5: data
150/6:
# проверим типы колонок в датасете
data.dtypes
150/7:
X = data.iloc[:,:-1]
X.drop(columns='ID', inplace=True)

y = data['Purchased Bike']
150/8:
num_cols = X.columns[X.dtypes == 'int64'].tolist()
cat_cols = X.columns[X.dtypes == 'object']

print(f"We have {len(num_cols)} numeric columns: {', '.join(num_cols)}")
print(f"And {len(cat_cols)} categorical columns: {', '.join(cat_cols)}")
150/9:
for col in cat_cols:
    print(col)
    display(X[col].value_counts(normalize=True))
    print()
150/10:
# у нас есть категориальные переменные разных видов!

binary_cols = cat_cols[X[cat_cols].nunique() == 2].tolist()
ordinal_cols = ['Commute Distance', 'Education']
cat_cols = cat_cols.difference(binary_cols + ordinal_cols).tolist()
150/11:
for col in num_cols:
    print(col)
    display(X[col].describe())
    print()
150/12: X.describe()
150/13:
# classes are balanced !
y.value_counts(normalize=True)
150/14:
# transform y to numeric column
y = (y == 'Yes').astype(int)
y
150/15:
# run if not installed yet

#!pip install category_encoders
150/16:
from category_encoders.ordinal import OrdinalEncoder
from category_encoders.one_hot import OneHotEncoder
from category_encoders.target_encoder import TargetEncoder
151/1:
import pandas as pd
import numpy as np
import sklearn
from sklearn.linear_model import SGDRegressor
from sklearn.datasets import load_diabetes
151/2:
import pandas as pd
import numpy as np
import sklearn
from sklearn.linear_model import SGDRegressor
from sklearn.datasets import load_diabetes
152/1:
import pandas as pd
import numpy as np
import sklearn
from sklearn.linear_model import SGDRegressor
from sklearn.datasets import load_diabetes
152/2:
import pandas as pd
import numpy as np
import sklearn
from sklearn.linear_model import SGDRegressor
from sklearn.datasets import load_diabetes
152/3: np.random.seed(42)
152/4:
import warnings
warnings.filterwarnings('ignore')
152/5: X, y = load_diabetes(return_X_y=True,as_frame=True)
152/6: X
152/7: y
152/8:
# Разобьем данные на обучающую и тестовую выборки

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y)
152/9:
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

lr_mse = SGDRegressor(loss='squared_loss', max_iter=50000)
lr_mae = SGDRegressor(loss='epsilon_insensitive', epsilon=0, max_iter=50000)

lr_mse.fit(X_train, y_train)
lr_mae.fit(X_train, y_train)

y_pred_mse = lr_mse.predict(X_test)
y_pred_mae = lr_mae.predict(X_test)

print(f'''MSE loss: 
mae={mean_absolute_error(y_test, y_pred_mse)}
mse={mean_squared_error(y_test, y_pred_mse)}
R2={r2_score(y_test, y_pred_mse)}
''')

print(f'''MAE loss: 
mae={mean_absolute_error(y_test, y_pred_mae)}
mse={mean_squared_error(y_test, y_pred_mae)}
R2={r2_score(y_test, y_pred_mae)}
''')
152/10:
def max_error(y_true, y_pred):
    max_erorr = np.abs(y_true - y_pred).max()
    return max_erorr

def quantile_error(y_true, y_pred, q=0.95):
    q_error = np.quantile(np.abs(y_true -  y_pred), q)
    return q_error

# Оценим максимальную ошибку в обоих случаях

print(f'MSE Loss: {max_error(y_test, y_pred_mse)}')
print(f'MAE Loss: {max_error(y_test, y_pred_mae)}')
152/11: from sklearn.model_selection import cross_validate
152/12:
# проверим на кросс-валидации значения ошибок MSE, MAE, R2 
# для линейной регрессии, обученной с помощью функционала MSE

num_splits=5

cv_res = cross_validate(lr_mse,
                     X,
                     y,
                     scoring='neg_mean_squared_error', # метрика, которую нужно оценить
                     cv=num_splits # количество разбиений или класс-сплиттер
                    )

print(f"test mse errors are {cv_res['test_score']}")
print(f"mean test mse = {cv_res['test_score'].mean()}")
152/13:
# Проведем кросс-валидацию сразу для нескольких метрик

cv_res2 = cross_validate(lr_mse,
                     X,
                     y,
                     scoring=['neg_mean_squared_error', 'neg_mean_absolute_error', 'r2'],
                     cv=num_splits
                    )
print(f"""test mse errors are {cv_res2['test_neg_mean_squared_error']} 
and  mean mse = {cv_res2['test_neg_mean_squared_error'].mean()}
""")

print(f"""test mae errors are {cv_res2['test_neg_mean_absolute_error']} 
and  mean mae = {cv_res2['test_neg_mean_absolute_error'].mean()}
""")


print(f"""test R2 are {cv_res2['test_r2']} 
and  mean R2 = {cv_res2['test_r2'].mean()}
""")
152/14:
# для тех, кто хочет хочет дополнительно подумать

# кросс-валидацию можно проводить на основе своей кастомной метрики, но для этого
# из нее нужно сделать объект scorer

from sklearn.metrics import make_scorer

max_error_scorer = make_scorer(max_error, greater_is_better=False)

cv_res3 = cross_validate(lr_mse,
                     X,
                     y,
                     scoring=max_error_scorer,
                     cv=num_splits
                    )
cv_res3['test_score']
152/15:
import copy

cols = copy.deepcopy(X.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_x_' + col2
        if col_name not in X.columns:
            X[col_name] = X[col1]*X[col2]
X
152/16: X_train, X_test, y_train, y_test = train_test_split(X, y)
152/17:
# альфа - это гиперпараметр, посмотрим как зависят значения весов от него

from sklearn.linear_model import Lasso

for a in np.arange(0, 1.1, 0.25):
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a)
    lasso.fit(X_train, y_train)

    y_pred_tr = lasso.predict(X_train)
    y_pred2 = lasso.predict(X_test)

    print('alpha={}'.format(a))
    print('Train MSE:', mean_squared_error(y_train, y_pred_tr))
    print('Test MSE:', mean_squared_error(y_test, y_pred2))
    print(lasso.coef_,'\n')
152/18:
# альфа - это гиперпараметр, посмотрим как зависят значения весов от него

from sklearn.linear_model import Ridge

for a in np.arange(0, 1.1, 0.25):
    if a == 0:
        a += 0.00000001
    ridge = Ridge(alpha=a)
    ridge.fit(X_train, y_train)

    y_pred_tr = ridge.predict(X_train)
    y_pred2 = ridge.predict(X_test)

    print('alpha={}'.format(a))
    print('Train MSE:', mean_squared_error(y_train, y_pred_tr))
    print('Test MSE:', mean_squared_error(y_test, y_pred2))
    print(ridge.coef_,'\n')
152/19:
from sklearn.linear_model import LassoCV

n_alphas = 200
alphas = np.linspace(1e-10, 5, n_alphas)

lasso_cv = LassoCV(alphas=alphas, cv=5, random_state=42)
lasso_cv.fit(X, y)

print(f'Optimal alpha value is {lasso_cv.alpha_}')
152/20:
# Более общий способ использования кросс-валидации для поиска лучшего набора гиперпараметров


from sklearn.model_selection import GridSearchCV

params = {'alpha':alphas}
#print(params)
cv = GridSearchCV(lasso,
                  params,
                  scoring='r2',
                  cv=num_splits
                 )
cv.fit(X, y)

print(cv.best_params_)
154/1:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

%pylab inline
154/2:
data = pd.read_csv('diamonds.csv')
data.head(5)x
154/3:
data = pd.read_csv('diamonds.csv')
data.head(5)
154/4: data.isnull().sum()
154/5:
data = data.drop(['Unnamed'], axis=1)
data.head()
154/6:
data = data.drop(['Unnamed: 0'], axis=1)
data.head()
154/7:
# введем целевую переменную - цена
y = data['price'] # целевая переменная
numericData = data._get_numeric_data()
numericData.corr()
154/8:
# введем целевую переменную - цена
y = data['price'] # целевая переменная
numericData = data._get_numeric_data()
numericData.corrwith(y)
154/9: numericData.corr()
154/10:
data = pd.get_dummies(data, columns=['cut', 'color', 'clarity'], drop_first=True)
data.head()
154/11:
y = data['price']
X = data._get_numeric_data().drop('price', axis=1)
154/12:
from sklearn.model_selection import train_test_split

Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.3)
154/13:
from sklearn.preprocessing import StandardScaler

# your code here
scaler = StandardScaler()
scaler.fit_transform(data)
154/14:
from sklearn.preprocessing import StandardScaler

# your code here
scaler = StandardScaler()
ss_data = scaler.fit_transform(data)
df_scaled = pd.DataFrame(ss_data,columns = data.columns)
154/15:
from sklearn.preprocessing import StandardScaler

# your code here
scaler = StandardScaler()
ss_data = scaler.fit_transform(data)
df_scaled = pd.DataFrame(ss_data,columns = data.columns)
df_scaled
157/1:
# нет удобной реализации - напишем сами !

from sklearn.base import TransformerMixin

class CustomScaler(TransformerMixin):
    def __init__(self, cols, scaler=None):
        self.cols = cols
        self.scaler = scaler or StandardScaler()
        
    def fit(self, X, y=None):
        num_cols = X.copy()[self.cols]
        self.scaler.fit(num_cols)
        return self
    def transform(self, X, y=None):
        X_res = X.copy()
        num_cols_tr = self.scaler.transform(X_res[self.cols])
        for i, col in enumerate(self.cols):
            X_res[col] = num_cols_tr[:,i]
        return X_res
157/2: X2
157/3:
import pandas as pd
import numpy as np
import seaborn as sns
157/4: np.random.seed(42)
157/5: data = pd.read_csv('bike_buyers_clean.csv')
157/6: data
157/7:
# проверим типы колонок в датасете
data.dtypes
157/8:
X = data.iloc[:,:-1]
X.drop(columns='ID', inplace=True)

y = data['Purchased Bike']
157/9:
num_cols = X.columns[X.dtypes == 'int64'].tolist()
cat_cols = X.columns[X.dtypes == 'object']

print(f"We have {len(num_cols)} numeric columns: {', '.join(num_cols)}")
print(f"And {len(cat_cols)} categorical columns: {', '.join(cat_cols)}")
157/10:
for col in cat_cols:
    print(col)
    display(X[col].value_counts(normalize=True))
    print()
157/11:
# у нас есть категориальные переменные разных видов!

binary_cols = cat_cols[X[cat_cols].nunique() == 2].tolist()
ordinal_cols = ['Commute Distance', 'Education']
cat_cols = cat_cols.difference(binary_cols + ordinal_cols).tolist()
157/12:
for col in num_cols:
    print(col)
    display(X[col].describe())
    print()
157/13: X.describe()
157/14:
# classes are balanced !
y.value_counts(normalize=True)
157/15:
# transform y to numeric column
y = (y == 'Yes').astype(int)
y
157/16:
# run if not installed yet

#!pip install category_encoders
157/17:
from category_encoders.ordinal import OrdinalEncoder
from category_encoders.one_hot import OneHotEncoder
from category_encoders.target_encoder import TargetEncoder
157/18: X2
157/19:
sc = CustomScaler(num_cols)
X2 = sc.fit_transform(X)
157/20:
from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
scaler.fit_transform(X['Income'].values.reshape(-1,1))
157/21: num_cols
157/22:
from sklearn.compose import ColumnTransformer

ct = ColumnTransformer([('scaler', StandardScaler(), num_cols)], remainder='passthrough') # 'drop'
157/23: ct.fit_transform(X)
157/24:
# нет удобной реализации - напишем сами !

from sklearn.base import TransformerMixin

class CustomScaler(TransformerMixin):
    def __init__(self, cols, scaler=None):
        self.cols = cols
        self.scaler = scaler or StandardScaler()
        
    def fit(self, X, y=None):
        num_cols = X.copy()[self.cols]
        self.scaler.fit(num_cols)
        return self
    def transform(self, X, y=None):
        X_res = X.copy()
        num_cols_tr = self.scaler.transform(X_res[self.cols])
        for i, col in enumerate(self.cols):
            X_res[col] = num_cols_tr[:,i]
        return X_res
157/25:
sc = CustomScaler(num_cols)
X2 = sc.fit_transform(X)
157/26: X2
154/16:
from sklearn.preprocessing import StandardScaler

# your code here
scaler = StandardScaler()
ss_data = scaler.fit_transform(Xtrain)
train_scaled = pd.DataFrame(ss_data,columns = Xtrain.columns)
train_scaled
154/17:
from sklearn.preprocessing import StandardScaler

# your code here
scaler = StandardScaler()
ss_data = scaler.fit_transform(Xtrain)
train_scaled = pd.DataFrame(ss_data,columns = Xtrain.columns)
train_scaled.head()
154/18:
from sklearn.preprocessing import StandardScaler

# your code here
scaler = StandardScaler()
ss_data = scaler.fit_transform(Xtest)
test_scaled = pd.DataFrame(ss_data,columns = Xtest.columns)
test_scaled.head()
154/19:
from sklearn.preprocessing import StandardScaler

# your code here
scaler = StandardScaler()
ss_data = scaler.transform(Xtest)
test_scaled = pd.DataFrame(ss_data,columns = Xtest.columns)
test_scaled.head()
154/20:
from sklearn.preprocessing import StandardScaler

# your code here
scaler = StandardScaler()
ss_data = scaler.fit_transform(Xtrain)
train_scaled = pd.DataFrame(ss_data,columns = Xtrain.columns)
train_scaled
154/21:
from sklearn.preprocessing import StandardScaler

# your code here
scaler = StandardScaler()
ss_data = scaler.fit_transform(Xtrain)
train_scaled = pd.DataFrame(ss_data,columns = Xtrain.columns)
train_scaled.head()
154/22:
from sklearn.preprocessing import StandardScaler

# your code here
scaler = StandardScaler()
ss_data = scaler.fit_transform(Xtest)
test_scaled = pd.DataFrame(ss_data,columns = Xtest.columns)
test_scaled.head()
154/23:
from sklearn.preprocessing import StandardScaler

# your code here
scaler = StandardScaler()
scaler.fit(Xtrain, ytrain)
157/27: X['Income']
154/24:
from sklearn.preprocessing import StandardScaler

# your code here
scaler = StandardScaler()
scaler.fit(Xtrain, ytrain)
scaler.fit_transform(Xtrain, ytrain)
154/25:
from sklearn.preprocessing import StandardScaler

# your code here
scaler = StandardScaler()
scaler.fit(Xtrain, ytrain)
scaler.fit_transform(Xtrain)
154/26:
from sklearn.preprocessing import StandardScaler

# your code here
scaler = StandardScaler()
scaler.fit(Xtrain, ytrain)
scaler.fit_transform(Xtrain)

Xtrain
154/27:
from sklearn.preprocessing import StandardScaler

# your code here
scaler = StandardScaler()
scaler.fit(Xtrain, ytrain)
Xtrain = pd.DataFrame(ss.fit_transform(Xtrain),columns = Xtrain.columns)

Xtrain
154/28:
from sklearn.preprocessing import StandardScaler

# your code here
ss = StandardScaler()
ss.fit(Xtrain, ytrain)
Xtrain = pd.DataFrame(ss.fit_transform(Xtrain),columns = Xtrain.columns)

Xtrain
154/29:
from sklearn.preprocessing import StandardScaler

# your code here
ss = StandardScaler()
ss.fit(Xtrain, ytrain)
Xtrain = pd.DataFrame(ss.fit_transform(Xtrain),columns = Xtrain.columns)
Xtest= pd.DataFrame(ss.fit_transform(Xtest),columns = Xtest.columns)

Xtest
154/30:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain,ytrain)

pred_train = lr.predict(X_train)
# pred_test = lr.predict(Xtest)

print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, pred_train))))
154/31:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain,ytrain)

pred_train = lr.predict(Xtrain)
# pred_test = lr.predict(Xtest)

print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, pred_train))))
154/32:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
from sklearn.metrics import mean_squared_error


# your code here
lr = LinearRegression()
lr.fit(Xtrain,ytrain)

pred_train = lr.predict(Xtrain)
# pred_test = lr.predict(Xtest)

print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, pred_train))))
154/33:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

%pylab inline
154/34:
data = pd.read_csv('diamonds.csv')
data.head(5)
154/35: data.isnull().sum()
154/36:
# введем целевую переменную - цена
y = data['price'] # целевая переменная
numericData = data._get_numeric_data()
numericData.corrwith(y)
154/37:
data = pd.get_dummies(data, columns=['cut', 'color', 'clarity'], drop_first=True)
data.head()
154/38:
y = data['price']
X = data._get_numeric_data().drop('price', axis=1)
154/39:
from sklearn.model_selection import train_test_split

Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.3)
154/40:
from sklearn.preprocessing import StandardScaler

# your code here
ss = StandardScaler()
Xtrain2 = ss.fit_transform(Xtrain)
# Xtrain2 = pd.DataFrame(ss.fit_transform(Xtrain),columns = Xtrain.columns)
154/41:
from sklearn.preprocessing import StandardScaler

# your code here
ss = StandardScaler()
Xtrain2 = ss.fit_transform(Xtrain)
# Xtrain2 = pd.DataFrame(ss.fit_transform(Xtrain),columns = Xtrain.columns)
Xtrain2
154/42:
from sklearn.preprocessing import StandardScaler

# your code here
ss = StandardScaler()
Xtrain2 = ss.fit_transform(Xtrain)
# Xtrain2 = pd.DataFrame(ss.fit_transform(Xtrain),columns = Xtrain.columns)
Xtrain2 = pd.DataFrame(Xtrain2,,columns = Xtrain.columns)
154/43:
from sklearn.preprocessing import StandardScaler

# your code here
ss = StandardScaler()
Xtrain2 = ss.fit_transform(Xtrain)
# Xtrain2 = pd.DataFrame(ss.fit_transform(Xtrain),columns = Xtrain.columns)
Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtrain2
154/44:
from sklearn.preprocessing import StandardScaler

# your code here
ss = StandardScaler()
Xtrain2 = ss.fit_transform(Xtrain)

Xtest2 = ss.transform(Xtest)
Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2
154/45:
from sklearn.preprocessing import StandardScaler

# your code here
ss = StandardScaler()
Xtrain2 = ss.fit_transform(Xtrain)
Xtest2 = ss.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtrain2,columns = Xtest2.columns)
Xtest2.head()
154/46:
from sklearn.preprocessing import StandardScaler

# your code here
ss = StandardScaler()
Xtrain2 = ss.fit_transform(Xtrain)
Xtest2 = ss.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest2.columns)
Xtest2.head()
154/47:
from sklearn.preprocessing import StandardScaler

# your code here
ss = StandardScaler()
Xtrain2 = ss.fit_transform(Xtrain)
Xtest2 = ss.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest2.head()
154/48:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

%pylab inline
154/49:
data = pd.read_csv('diamonds.csv')
data.head(5)
154/50: data.isnull().sum()
154/51:
# не несет доп информации столбец Unnamed: 0. Он фактически повторяет индекс
data = data.drop(['Unnamed: 0'], axis=1)
data.head()
154/52:
# введем целевую переменную - цена
y = data['price'] # целевая переменная
numericData = data._get_numeric_data()
numericData.corrwith(y)
154/53: # коррелируют carat,x,y,x
154/54:
data = pd.get_dummies(data, columns=['cut', 'color', 'clarity'], drop_first=True)
data.head()
154/55:
y = data['price']
X = data._get_numeric_data().drop('price', axis=1)
154/56:
from sklearn.model_selection import train_test_split

Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.3)
154/57:
from sklearn.preprocessing import StandardScaler

# your code here
ss = StandardScaler()
Xtrain2 = ss.fit_transform(Xtrain)
Xtest2 = ss.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest2.head()
154/58:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
from sklearn.metrics import mean_squared_error

# your code here
lr = LinearRegression()
lr_mse = SGDRegressor(loss='squared_loss', max_iter=50000) 
lr_mse.fit(Xtrain2, ytrain)

train_pred = lr_mse.predict(Xtrain2)
test_pred = lr_mse.predict(Xtest2)

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(y_test, test_pred)}
''')
154/59:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr_mse.predict(Xtrain2)
test_pred = lr_mse.predict(Xtest2)

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(y_test, test_pred)}
''')
154/60:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(y_test, test_pred)}
''')
154/61:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
154/62:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
ytrain
154/63: train_pred
155/1:
def linear_regression(X, y_true, m=0, b=0, epochs=1000, learning_rate=0.0001):
    N = float(len(y_true))
    for i in range(epochs):
        y_pred = m * X + b
        cost = sum([err**2 for err in (y_pred-y_true)])*(1./N)
        
        m_gradient = (2./N)*sum(X*(y_pred-y_true))
        b_gradient = (2./N)*sum(y_pred-y_true)
        
        m = m - learning_rate * m_gradient
        b = b - learning_rate * b_gradient
            
    return m, b, cost
155/2:
import random
import numpy as np
import pandas as pd
from matplotlib import pylab as plt
%pylab inline

num_points = 100
m, b, delta = 1, 0, 1

x = np.linspace(1, 10, num_points)
y = m * x + b + random.uniform(-delta, delta, num_points)

plt.scatter(x,y)
155/3:
m, b, cost = linear_regression(x,y) # обучение

y_pred = m * x + b # предсказание

plt.scatter(x, y, color='blue')
plt.plot(x, y_pred, 'r-')

print('MSE: {}'.format(cost))
155/4:
for lr in [0.1, 0.01, 0.0001]:
    for ep in [10, 100, 1000]:
        print('lr = ', lr)
        print('ep = ', ep)
        m, b, cost = linear_regression(x, y, learning_rate=lr, epochs=ep) # обучение

        y_pred = m * x + b # предсказание

        plt.scatter(x, y, color='blue')
        plt.plot(x, y_pred, 'r-')
        plt.show()

        print('MSE: {}'.format(cost))
155/5:
num_points = 100
m, b, delta = 10, 0, 50

x = np.linspace(1, 10, num_points)
y = m * x**2 + b + random.uniform(-delta, delta, num_points)

plt.scatter(x,y)
155/6:
x2 = x ** 2

m, b, cost = linear_regression(x2,y) # обучение

y_pred = m * x2 + b # предсказание

plt.scatter(x, y, color='blue')
plt.plot(x, y_pred, 'r-')

print('MSE: {}'.format(cost))
155/7:
from sklearn.metrics import r2_score

r2_score(y, y_pred)
155/8:
df = pd.read_csv("weights_heights.csv")
df.head()
155/9:
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(df['Height'], df['Weight'], test_size=0.2)

m, b, cost = linear_regression(X_train, y_train, learning_rate=0.00001)
155/10:
from sklearn.metrics import mean_squared_error

pred_train = m * X_train + b
pred_test = m * X_test + b

print("Train MSE: {}".format(np.sqrt(mean_squared_error(y_train, pred_train))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(y_test, pred_test))))
155/11: X_train.head()
155/12:
from sklearn.linear_model import LinearRegression

X_train2, X_test2, y_train, y_test = train_test_split(df[['Height']], df['Weight'], test_size=0.2)

lr = LinearRegression()
lr.fit(X_train2,y_train)

pred_train = lr.predict(X_train2)
pred_test = lr.predict(X_test2)

print("Train MSE: {}".format(np.sqrt(mean_squared_error(y_train, pred_train))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(y_test, pred_test))))
155/13:
from sklearn.model_selection import cross_val_score

-cross_val_score(lr, df[['Height']], df['Weight'], cv=5, scoring='neg_mean_squared_error').mean()
155/14: lr.fit(df[['Height']], df['Weight'])
155/15:
from sklearn.datasets import load_boston

data = load_boston()
print(data.DESCR)
155/16:
X_full = data.data
y_full = data.target

y_full[:5]
155/17: #your code here
155/18: #your code here
155/19:
import seaborn as sns

data1 = pd.DataFrame(data= np.c_[data['data'], data['target']],
                     columns= list(data['feature_names']) + ['target'])

plt.figure(figsize=(10,10))
corr = data1.corr()
sns.heatmap(corr,annot=True,linewidths=.5, fmt= '.2f',mask=np.zeros_like(corr, dtype=np.bool), \
            cmap=sns.diverging_palette(100,200, as_cmap=True), square=True)
155/20: #your code here
155/21:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

X_train2, X_test2, y_train, y_test = train_test_split(df[['Height']], df['Weight'], test_size=0.2)

lr = LinearRegression()
lr.fit(X_train2,y_train)

pred_train = lr.predict(X_train2)
pred_test = lr.predict(X_test2)

print("Train MSE: {}".format(np.sqrt(mean_squared_error(y_train, pred_train))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(y_test, pred_test))))

print(f'''
train R2={r2_score(y_train, pred_train)}
''')
154/64:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
154/65:
# The coefficients
print('Coefficients: \n', lr.coef_, "\n")
print('Feature:  Weight:')

for feature, coeff in zip(df.columns,regr.coef_.T):
    print(feature, coeff)
154/66:
# The coefficients
print('Coefficients: \n', lr.coef_, "\n")
print('Feature:  Weight:')

for feature, coeff in zip(data.columns,regr.coef_.T):
    print(feature, coeff)
154/67:
# The coefficients
print('Coefficients: \n', lr.coef_, "\n")
print('Feature:  Weight:')

for feature, coeff in zip(data.columns,lr.coef_.T):
    print(feature, coeff)
154/68: numericData.corr()
164/1: Xtrain.head()
164/2:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

%pylab inline
164/3:
data = pd.read_csv('diamonds.csv')
data.head(5)
164/4: data.isnull().sum()
164/5:
# не несет доп информации столбец Unnamed: 0. Он фактически повторяет индекс
data = data.drop(['Unnamed: 0'], axis=1)
data.head()
164/6:
# введем целевую переменную - цена
y = data['price'] # целевая переменная
numericData = data._get_numeric_data()
numericData.corrwith(y)
164/7: numericData.corr()
164/8: # коррелируют carat,x,y,x
164/9:
data = pd.get_dummies(data, columns=['cut', 'color', 'clarity'], drop_first=True)
data.head()
164/10:
y = data['price']
X = data._get_numeric_data().drop('price', axis=1)
164/11:
from sklearn.model_selection import train_test_split

Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.3)
164/12:
from sklearn.preprocessing import StandardScaler

# your code here
ss = StandardScaler()
Xtrain2 = ss.fit_transform(Xtrain)
Xtest2 = ss.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest2.head()
164/13:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
164/14:
# The coefficients
print('Coefficients: \n', lr.coef_, "\n")
print('Feature:  Weight:')

for feature, coeff in zip(data.columns,lr.coef_.T):
    print(feature, coeff)
    clarity_IF
# carat, price, color_J, clarity_***
164/15:
# The coefficients
print('Coefficients: \n', lr.coef_, "\n")
print('Feature:  Weight:')

for feature, coeff in zip(data.columns,lr.coef_.T):
    print(feature, coeff)
    
# carat, price, color_J, clarity_***
164/16: Xtrain.head()
164/17: Xtest.head()
164/18: X.head()
164/19: data.head()
164/20:

X
164/21:
from sklearn.preprocessing import StandardScaler

# fit calculates the parameters (e.g. 𝜇 and 𝜎 in case of StandardScaler) and saves them as an internal object's state
# transform() method to apply the transformation to any particular set of examples
# fit_transform() joins these two steps and is used for the initial fitting of parameters on the training set 𝑥, while also returning the transformed  𝑥

# your code here
ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest2.head()
164/22:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
164/23:
from sklearn.preprocessing import StandardScaler

# fit calculates the parameters (e.g. 𝜇 and 𝜎 in case of StandardScaler) and saves them as an internal object's state
# transform() method to apply the transformation to any particular set of examples
# fit_transform() joins these two steps and is used for the initial fitting of parameters on the training set 𝑥, while also returning the transformed  𝑥

# your code here
ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
scaler
164/24:
from sklearn.preprocessing import StandardScaler

# fit calculates the parameters (e.g. 𝜇 and 𝜎 in case of StandardScaler) and saves them as an internal object's state
# transform() method to apply the transformation to any particular set of examples
# fit_transform() joins these two steps and is used for the initial fitting of parameters on the training set 𝑥, while also returning the transformed  𝑥

# your code here
ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest2.head()
164/25: X.drop(['x', 'y', 'z'], axis=1)
164/26:
X.drop(['x', 'y', 'z'], axis=1)
y
164/27:
from sklearn.model_selection import train_test_split

Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.3)
164/28:
from sklearn.model_selection import train_test_split

Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.3)
164/29:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.3)

ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest2.head()
164/30:
X = X.drop(['x', 'y', 'z'], axis=1)
y
164/31:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.3)

ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest2.head()
164/32:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
164/33:
# попробуем удалить три признака, которые сильно коррелируют с другими
X = X.drop(['x', 'y', 'z'], axis=1)
X
164/34:
# попробуем удалить три признака, которые сильно коррелируют с другими
X1 = X.drop(['x', 'y', 'z'], axis=1)
X1
164/35:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

%pylab inline
164/36:
data = pd.read_csv('diamonds.csv')
data.head(5)
164/37: data.isnull().sum()
164/38:
# не несет доп информации столбец Unnamed: 0. Он фактически повторяет индекс
data = data.drop(['Unnamed: 0'], axis=1)
data.head()
164/39:
# введем целевую переменную - цена
y = data['price'] # целевая переменная
numericData = data._get_numeric_data()
numericData.corrwith(y)
164/40: numericData.corr()
164/41: # коррелируют carat,x,y,x
164/42:
data = pd.get_dummies(data, columns=['cut', 'color', 'clarity'], drop_first=True)
data.head()
164/43:
y = data['price']
X = data._get_numeric_data().drop('price', axis=1)
164/44:
from sklearn.model_selection import train_test_split

Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.3)
164/45:
from sklearn.preprocessing import StandardScaler

# fit calculates the parameters (e.g. 𝜇 and 𝜎 in case of StandardScaler) and saves them as an internal object's state
# transform() method to apply the transformation to any particular set of examples
# fit_transform() joins these two steps and is used for the initial fitting of parameters on the training set 𝑥, while also returning the transformed  𝑥

# your code here
ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest2.head()
164/46:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
164/47:
# попробуем удалить три признака, которые сильно коррелируют с другими
X1 = X.drop(['x', 'y', 'z'], axis=1)
X1
164/48:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(X1, y, test_size=0.3)

ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest2.head()
164/49:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')

# качество модели ухудшилось
164/50: # попробуем удалить другой признак
164/51:
# попробуем удалить другой признак
X2 = X.drop(['x', 'y', 'z'], axis=1)
X2
164/52:
# попробуем удалить другой признак
X2 = X.drop(['carat'], axis=1)
164/53:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(X2, y, test_size=0.3)

ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
164/54:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
164/55:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
from sklearn.metrics import mean_squared_error

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, train_pred))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(ytest, test_pred))))

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
164/56:
# попробуем удалить три признака, которые сильно коррелируют с другими
X1 = X.drop(['x', 'y', 'z'], axis=1)
164/57:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)
print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, train_pred))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(ytest, test_pred))))

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')

# качество модели ухудшилось, но не намного
164/58:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, train_pred))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(ytest, test_pred))))

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
# нельзя удалять данный признак, тк модель стала намного хуже
164/59:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

%pylab inline
164/60:
data = pd.read_csv('diamonds.csv')
data.head(5)
164/61: data.isnull().sum()
164/62:
# не несет доп информации столбец Unnamed: 0. Он фактически повторяет индекс
data = data.drop(['Unnamed: 0'], axis=1)
data.head()
164/63:
# введем целевую переменную - цена
y = data['price'] # целевая переменная
numericData = data._get_numeric_data()
numericData.corrwith(y)
164/64: numericData.corr()
164/65: # коррелируют carat,x,y,x
164/66:
data = pd.get_dummies(data, columns=['cut', 'color', 'clarity'], drop_first=True)
data.head()
164/67:
y = data['price']
X = data._get_numeric_data().drop('price', axis=1)
164/68:
from sklearn.model_selection import train_test_split

Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.3)
164/69:
from sklearn.preprocessing import StandardScaler

# fit calculates the parameters (e.g. 𝜇 and 𝜎 in case of StandardScaler) and saves them as an internal object's state
# transform() method to apply the transformation to any particular set of examples
# fit_transform() joins these two steps and is used for the initial fitting of parameters on the training set 𝑥, while also returning the transformed  𝑥

# your code here
ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest2.head()
164/70:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
from sklearn.metrics import mean_squared_error

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, train_pred))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(ytest, test_pred))))

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
164/71:
# The coefficients
print('Coefficients: \n', lr.coef_, "\n")
print('Feature:  Weight:')

for feature, coeff in zip(data.columns,lr.coef_.T):
    print(feature, coeff)
    
# carat, price, color_J, clarity_***
164/72:
# попробуем удалить три признака, которые сильно коррелируют с другими
X1 = X.drop(['x', 'y', 'z'], axis=1)
164/73:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(X1, y, test_size=0.3)

ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest2.head()
164/74:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)
print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, train_pred))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(ytest, test_pred))))

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')

# качество модели ухудшилось, но не намного
164/75:
# попробуем удалить другой признак
X2 = X.drop(['carat'], axis=1)
164/76:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(X2, y, test_size=0.3)

ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
164/77:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, train_pred))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(ytest, test_pred))))

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
# нельзя удалять данный признак, тк модель стала намного хуже
164/78:
import copy

cols = copy.deepcopy(X.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_x_' + col2
        if col_name not in X.columns:
            X[col_name] = X[col1]*X[col2]
X
164/79: # your code here
164/80:
import copy

cols = copy.deepcopy(X[['carat', 'depth', 'table', 'x', 'y', 'z']])
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_x_' + col2
        if col_name not in X.columns:
            X[col_name] = X[col1]*X[col2]
X
164/81:
import copy

df = X[['carat', 'depth', 'table', 'x', 'y', 'z']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_x_' + col2
        if col_name not in X.columns:
            X[col_name] = X[col1]*X[col2]
X
164/82:
import copy

df = X[['carat', 'depth', 'table', 'x', 'y', 'z']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_x_' + col2
        if col_name not in X.columns:
            X[col_name] = X[col1]*X[col2]
df
164/83:
import copy

df = X[['carat', 'depth', 'table', 'x', 'y', 'z']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_x_' + col2
        if col_name not in df.columns:
            df[col_name] = df[col1]*df[col2]
df
164/84:
import copy

df = X[['carat', 'depth', 'table', 'x', 'y', 'z']]
cols = copy.deepcopy(df.columns)
print(cols)

# for col1 in cols:
#     for col2 in cols:
#         col_name = col1 + '_x_' + col2
#         if col_name not in df.columns:
#             df[col_name] = df[col1]*df[col2]
X
164/85:
import copy

df = X.loc[:, [carat', 'depth', 'table', 'x', 'y', 'z']]
cols = copy.deepcopy(df.columns)
print(cols)

# for col1 in cols:
#     for col2 in cols:
#         col_name = col1 + '_x_' + col2
#         if col_name not in df.columns:
#             df[col_name] = df[col1]*df[col2]
X
164/86:
import copy

df = X.loc[:, ['carat', 'depth', 'table', 'x', 'y', 'z']]
cols = copy.deepcopy(df.columns)
print(cols)

# for col1 in cols:
#     for col2 in cols:
#         col_name = col1 + '_x_' + col2
#         if col_name not in df.columns:
#             df[col_name] = df[col1]*df[col2]
X
164/87:
import copy

df = X.loc[:, ['carat', 'depth', 'table', 'x', 'y', 'z']]
cols = copy.deepcopy(df.columns)
print(cols)

# for col1 in cols:
#     for col2 in cols:
#         col_name = col1 + '_x_' + col2
#         if col_name not in df.columns:
#             df[col_name] = df[col1]*df[col2]
df
164/88:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

%pylab inline
164/89:
data = pd.read_csv('diamonds.csv')
data.head(5)
164/90: data.isnull().sum()
164/91:
# не несет доп информации столбец Unnamed: 0. Он фактически повторяет индекс
data = data.drop(['Unnamed: 0'], axis=1)
data.head()
164/92:
# введем целевую переменную - цена
y = data['price'] # целевая переменная
numericData = data._get_numeric_data()
numericData.corrwith(y)
164/93: numericData.corr()
164/94: # коррелируют carat,x,y,x
164/95:
data = pd.get_dummies(data, columns=['cut', 'color', 'clarity'], drop_first=True)
data.head()
164/96:
y = data['price']
X = data._get_numeric_data().drop('price', axis=1)
164/97:
from sklearn.model_selection import train_test_split

Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.3)
164/98:
from sklearn.preprocessing import StandardScaler

# fit calculates the parameters (e.g. 𝜇 and 𝜎 in case of StandardScaler) and saves them as an internal object's state
# transform() method to apply the transformation to any particular set of examples
# fit_transform() joins these two steps and is used for the initial fitting of parameters on the training set 𝑥, while also returning the transformed  𝑥

# your code here
ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest2.head()
164/99:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
from sklearn.metrics import mean_squared_error

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, train_pred))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(ytest, test_pred))))

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
164/100:
# The coefficients
print('Coefficients: \n', lr.coef_, "\n")
print('Feature:  Weight:')

for feature, coeff in zip(data.columns,lr.coef_.T):
    print(feature, coeff)
    
# carat, price, color_J, clarity_***
164/101:
# попробуем удалить три признака, которые сильно коррелируют с другими
X1 = X.drop(['x', 'y', 'z'], axis=1)
164/102:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(X1, y, test_size=0.3)

ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest2.head()
164/103:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)
print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, train_pred))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(ytest, test_pred))))

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')

# качество модели ухудшилось, но не намного
164/104:
# попробуем удалить другой признак
X2 = X.drop(['carat'], axis=1)
164/105:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(X2, y, test_size=0.3)

ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
164/106:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, train_pred))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(ytest, test_pred))))

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
# нельзя удалять данный признак, тк модель стала намного хуже
164/107:
import copy

df = X.loc[:, ['carat', 'depth', 'table', 'x', 'y', 'z']]
cols = copy.deepcopy(df.columns)
print(cols)

# for col1 in cols:
#     for col2 in cols:
#         col_name = col1 + '_x_' + col2
#         if col_name not in df.columns:
#             df[col_name] = df[col1]*df[col2]
X
164/108:
import copy

df = X.loc[:, ['carat', 'depth', 'table', 'x', 'y', 'z']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_x_' + col2
        if col_name not in df.columns:
            df[col_name] = df[col1]*df[col2]
df
164/109: df1 = df.merge(X, how='left')
164/110: df1 = df.merge(X, how='left')
164/111:
df1 = df.merge(X, how='left')
df1
164/112:
df1 = df.merge(X, how='left')
df1.columns
164/113: df.columns
164/114: X.columns
164/115: df1 = df.merge(X, how='left')
164/116:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(df1, y, test_size=0.3)

ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
164/117:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(df1, y, test_size=0.3)

# ss = StandardScaler()
# scaler = ss.fit(Xtrain)
# Xtrain2 = scaler.fit_transform(Xtrain)
# Xtest2 = scaler.transform(Xtest)

# Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
# Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
df1
164/118:
import copy

df = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_x_' + col2
        if col_name not in df.columns:
            df[col_name] = df[col1]*df[col2]
164/119: df1 = df.merge(X, how='left')
164/120: df1 = df.merge(X, how='left')
164/121:
df1 = df.merge(X, how='left')
df1
164/122:
import copy

df = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_x_' + col2
        if col_name not in df.columns:
            df[col_name] = df[col1]*df[col2]
164/123:
import copy

df = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_x_' + col2
        if col_name not in df.columns:
            df[col_name] = df[col1]*df[col2]
df
164/124:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

%pylab inline
164/125:
data = pd.read_csv('diamonds.csv')
data.head(5)
164/126: data.isnull().sum()
164/127:
# не несет доп информации столбец Unnamed: 0. Он фактически повторяет индекс
data = data.drop(['Unnamed: 0'], axis=1)
data.head()
164/128:
# введем целевую переменную - цена
y = data['price'] # целевая переменная
numericData = data._get_numeric_data()
numericData.corrwith(y)
164/129: numericData.corr()
164/130: # коррелируют carat,x,y,x
164/131:
data = pd.get_dummies(data, columns=['cut', 'color', 'clarity'], drop_first=True)
data.head()
164/132:
y = data['price']
X = data._get_numeric_data().drop('price', axis=1)
164/133:
from sklearn.model_selection import train_test_split

Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.3)
164/134:
from sklearn.preprocessing import StandardScaler

# fit calculates the parameters (e.g. 𝜇 and 𝜎 in case of StandardScaler) and saves them as an internal object's state
# transform() method to apply the transformation to any particular set of examples
# fit_transform() joins these two steps and is used for the initial fitting of parameters on the training set 𝑥, while also returning the transformed  𝑥

# your code here
ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest2.head()
164/135:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
from sklearn.metrics import mean_squared_error

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, train_pred))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(ytest, test_pred))))

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
164/136:
# The coefficients
print('Coefficients: \n', lr.coef_, "\n")
print('Feature:  Weight:')

for feature, coeff in zip(data.columns,lr.coef_.T):
    print(feature, coeff)
    
# carat, price, color_J, clarity_***
164/137:
# попробуем удалить три признака, которые сильно коррелируют с другими
X1 = X.drop(['x', 'y', 'z'], axis=1)
164/138:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(X1, y, test_size=0.3)

ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest2.head()
164/139:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)
print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, train_pred))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(ytest, test_pred))))

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')

# качество модели ухудшилось, но не намного
164/140:
# попробуем удалить другой признак
X2 = X.drop(['carat'], axis=1)
164/141:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(X2, y, test_size=0.3)

ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
164/142:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, train_pred))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(ytest, test_pred))))

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
# нельзя удалять данный признак, тк модель стала работать намного хуже
164/143:
import copy

df = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_x_' + col2
        if col_name not in df.columns:
            df[col_name] = df[col1]*df[col2]
df
164/144:
import copy

df = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)
print(cols)

# for col1 in cols:
#     for col2 in cols:
#         col_name = col1 + '_x_' + col2
#         if col_name not in df.columns:
#             df[col_name] = df[col1]*df[col2]
df
164/145:
import copy

df = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_x_' + col2
        if col_name not in df.columns:
            df[col_name] = df[col1]*df[col2]
df
164/146:
import copy

df = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_x_' + col2
        if col_name not in df.columns:
            print('col1', col1)
            print('col2', col2)
            df[col_name] = df[col1]*df[col2]
df
164/147:
import copy

df = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_x_' + col2
        if col_name not in df.columns:
            df[col_name] = df[col1]*df[col2]
df.columns
164/148:
import copy

df1 = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_' + col2
        if col_name not in df1.columns:
            df1[col_name] = df[col1]*df[col2]
df.columns
164/149:
import copy

df1 = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_' + col2
        if col_name not in df1.columns:
            df1[col_name] = df[col1]*df[col2]
df.columns
164/150:
import copy

df1 = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_' + col2
        if col_name not in df1.columns:
            df1[col_name] = df[col1]*df[col2]
df.columns
164/151:
import copy

df = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_' + col2
        if col_name not in df.columns:
            df[col_name] = df[col1]*df[col2]
df.columns
164/152:
df1 = df.merge(X, how='left')
df1
164/153:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(df1, y, test_size=0.3)

# ss = StandardScaler()
# scaler = ss.fit(Xtrain)
# Xtrain2 = scaler.fit_transform(Xtrain)
# Xtest2 = scaler.transform(Xtest)

# Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
# Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
df1
164/154:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(df1, y, test_size=0.3)

# ss = StandardScaler()
# scaler = ss.fit(Xtrain)
# Xtrain2 = scaler.fit_transform(Xtrain)
# Xtest2 = scaler.transform(Xtest)

# Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
# Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
df1
164/155: y.shape
164/156:
df1.shape
y.shape
164/157:
print(df1.shape)
print(y.shape)
164/158:
print(df1.shape)
print(y.shape)
164/159:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

%pylab inline
164/160:
data = pd.read_csv('diamonds.csv')
data.head(5)
164/161: data.isnull().sum()
164/162:
# не несет доп информации столбец Unnamed: 0. Он фактически повторяет индекс
data = data.drop(['Unnamed: 0'], axis=1)
data.head()
164/163:
# введем целевую переменную - цена
y = data['price'] # целевая переменная
numericData = data._get_numeric_data()
numericData.corrwith(y)
164/164: numericData.corr()
164/165: # коррелируют carat,x,y,x
164/166:
data = pd.get_dummies(data, columns=['cut', 'color', 'clarity'], drop_first=True)
data.head()
164/167:
y = data['price']
X = data._get_numeric_data().drop('price', axis=1)
164/168:
print(df1.shape)
print(y.shape)
164/169:
from sklearn.model_selection import train_test_split

Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.3)
164/170:
from sklearn.preprocessing import StandardScaler

# fit calculates the parameters (e.g. 𝜇 and 𝜎 in case of StandardScaler) and saves them as an internal object's state
# transform() method to apply the transformation to any particular set of examples
# fit_transform() joins these two steps and is used for the initial fitting of parameters on the training set 𝑥, while also returning the transformed  𝑥

# your code here
ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest2.head()
164/171:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
from sklearn.metrics import mean_squared_error

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, train_pred))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(ytest, test_pred))))

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
164/172:
# The coefficients
print('Coefficients: \n', lr.coef_, "\n")
print('Feature:  Weight:')

for feature, coeff in zip(data.columns,lr.coef_.T):
    print(feature, coeff)
    
# carat, price, color_J, clarity_***
164/173:
# попробуем удалить три признака, которые сильно коррелируют с другими
X1 = X.drop(['x', 'y', 'z'], axis=1)
164/174:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(X1, y, test_size=0.3)

ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest2.head()
164/175:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)
print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, train_pred))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(ytest, test_pred))))

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')

# качество модели ухудшилось, но не намного
164/176:
# попробуем удалить другой признак
X2 = X.drop(['carat'], axis=1)
164/177:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(X2, y, test_size=0.3)

ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
164/178:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, train_pred))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(ytest, test_pred))))

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
# нельзя удалять данный признак, тк модель стала работать намного хуже
164/179:
import copy

df = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_' + col2
        if col_name not in df.columns:
            df[col_name] = df[col1]*df[col2]
df.columns
164/180:
df1 = df.merge(X, how='left')
df1
164/181:
print(df1.shape)
print(y.shape)
164/182:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(df1, y, test_size=0.3)

# ss = StandardScaler()
# scaler = ss.fit(Xtrain)
# Xtrain2 = scaler.fit_transform(Xtrain)
# Xtest2 = scaler.transform(Xtest)

# Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
# Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
df1
164/183:
print(X.shape)
print(y.shape)
164/184:
df1 = df.merge(X, how='left')
df.shape
164/185:
df1 = df.join(X)
df.shape
164/186:
import copy

df = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_' + col2
        if col_name not in df.columns:
            df[col_name] = df[col1]*df[col2]
X.columns
164/187:
df1 = pd.merge(df, dataframe2.iloc[:, [4:]], how='left', on='key')
df1
164/188:
df1 = pd.merge(df, dataframe2.iloc[:, [4:23]], how='left', on='key')
df1
164/189:
df1 = pd.merge(df, X.iloc[:, [4:]], how='left', on='key')
df1
164/190: df1
164/191:
df1 = pd.merge(df, X.iloc[:, [4:23]], how='left', on='key')
df1
164/192:
df1 = pd.merge(df, X.loc[:, [4:23]], how='left', on='key')
df1
164/193:
df1 = pd.merge(df, X[4:])
df1
164/194:
df1 = pd.merge(df, X[4:])
df1.shape
164/195:
df1 = pd.merge(df, X[4:])
df.shape
164/196:
df1 = pd.merge(df, X[4:])
df1
164/197:
df1 = df.join(X)
df1
164/198:
df1 = pd.concat([X, df], axis=1)
df1
164/199:
df1 = pd.concat([X, df], axis=1)
df1.columns
164/200:
import copy

df = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_' + col2
        if col_name not in df.columns:
            df[col_name] = df[col1]*df[col2]
df.columns
164/201:
import copy

df = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_' + col2
        if col_name not in df.columns:
            df[col_name] = df[col1]*df[col2]
df = df.drop(['carat', 'depth', 'table'], axis=1, inplace=True)
164/202:
df1 = pd.concat([X, df], axis=1)
df1.columns
164/203:
import copy

df = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_' + col2
        if col_name not in df.columns:
            df[col_name] = df[col1]*df[col2]
df = df.drop(['carat', 'depth', 'table'], axis=1, inplace=True)
df.columns
164/204:
import copy

df = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)
print(cols)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_' + col2
        if col_name not in df.columns:
            df[col_name] = df[col1]*df[col2]
df = df.drop(['carat', 'depth', 'table'], axis=1)
df.columns
164/205:
import copy

df = X.loc[:, ['carat', 'depth', 'table']]
cols = copy.deepcopy(df.columns)

for col1 in cols:
    for col2 in cols:
        col_name = col1 + '_' + col2
        if col_name not in df.columns:
            df[col_name] = df[col1]*df[col2]
df = df.drop(['carat', 'depth', 'table'], axis=1)
df.columns
164/206:
df1 = pd.concat([X, df], axis=1)
df1.columns
164/207:
df1 = pd.concat([X, df], axis=1)
df1
164/208:
print(df1.shape)
print(y.shape)
164/209:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(df1, y, test_size=0.3)

# ss = StandardScaler()
# scaler = ss.fit(Xtrain)
# Xtrain2 = scaler.fit_transform(Xtrain)
# Xtest2 = scaler.transform(Xtest)

# Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
# Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
164/210:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
Xtrain, Xtest, ytrain, ytest = train_test_split(df1, y, test_size=0.3)

ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain2 = scaler.fit_transform(Xtrain)
Xtest2 = scaler.transform(Xtest)

Xtrain2 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest2 = pd.DataFrame(Xtest2,columns = Xtest.columns)
164/211:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# your code here
lr = LinearRegression()
lr.fit(Xtrain2, ytrain)

train_pred = lr.predict(Xtrain2)
test_pred = lr.predict(Xtest2)

print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, train_pred))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(ytest, test_pred))))

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
165/1:
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
165/2:
x = np.concatenate((np.linspace(-3, 0, 500), np.linspace(0, 3, 500)))
np.random.seed(123)
y = np.ones(1000)
w = np.ones(1000)
M = y * x * w

plt.figure(figsize = (8, 6))
plt.plot(x * w, x < 0, label = "$\tilde{Q}(X, w)$, zero-one loss")
plt.plot(M, np.log2(1 + np.exp(-M)), label = "$Q'(X, w)$, logistic loss")
plt.grid()
plt.legend();
165/3:
from sklearn.datasets import load_iris
data = load_iris()
X = pd.DataFrame(data['data'], columns = data['feature_names'])
y = data['target']
X.head()
165/4: y
165/5: print(data.DESCR)
165/6:
# Перекодировка
y[y != 1] = -1
165/7:
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
np.random.seed(123)

X = X[['sepal length (cm)', 'sepal width (cm)']]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)

# Отмасштабируйте признаки
ss = StandardScaler()
X_train = ss.fit_transform(X_train)
X_test = ss.transform(X_test)

plt.scatter(X_train[:, 0], X_train[:, 1], c = y_train)
165/8:
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
165/9:
lr = LogisticRegression()
svm = SVC(kernel = 'linear')

# Обучите логистическую регрессию и SVM
lr.fit(X_train, y_train)
svm.fit(X_train, y_train)

pred_lr = lr.predict(X_test)
pred_svm = svm.predict(X_test)
165/10:
probs_lr = lr.predict_proba(X_test) # честные вероятности

probs_lr[:,1]
165/11:
from sklearn.metrics import accuracy_score, f1_score

f1_score(y_test, pred_lr)
165/12: f1_score(y_test, pred_svm)
165/13: lr.coef_, lr.intercept_
165/14: svm.coef_, svm.intercept_
165/15:
# !pip install mlxtend

# В Колабе, возможно
!pip install mlxtend --upgrade
165/16:
import itertools

import matplotlib.gridspec as gridspec
import matplotlib.pyplot as plt

from mlxtend.plotting import plot_decision_regions

gs = gridspec.GridSpec(1, 2)

fig = plt.figure(figsize=(10,8))

labels = ['Logistic Regression', 'SVM']
for clf, lab, grd in zip([lr, svm],
                         labels,
                         itertools.product([0, 1], repeat=2)):

    ax = plt.subplot(gs[grd[0], grd[1]])
    fig = plot_decision_regions(X = np.array(X_train), y = np.array(y_train), clf=clf, legend=2)
    plt.title(lab)

plt.show()
165/17:
lr1 = LogisticRegression(C = 0.01)
lr2 = LogisticRegression(C = 0.05)
lr3 = LogisticRegression(C = 10)
165/18:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools
gs = gridspec.GridSpec(1, 3)

fig = plt.figure(figsize=(15,8))

labels = ['C = 0.01', 'C = 0.05', 'C = 10']
for clf, lab, grd in zip([lr1, lr2, lr3],
                         labels,
                         itertools.product([0, 1, 2], repeat=2)):
    clf.fit(X_train, y_train)
    ax = plt.subplot(gs[grd[0], grd[1]])
    fig = plot_decision_regions(X = X_train, y = np.array(y_train), clf=clf, legend=2)
    plt.title(lab)

plt.show()
165/19:
svc1 = SVC(C = 0.04, kernel = 'linear')
svc2 = SVC(C = 1, kernel = 'linear')
svc3 = SVC(C = 10, kernel = 'linear')
165/20:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools
gs = gridspec.GridSpec(1, 3)

fig = plt.figure(figsize=(15,8))

labels = ['C = 0.04', 'C = 1', 'C = 10']
for clf, lab, grd in zip([svc1, svc2, svc3],
                         labels,
                         itertools.product([0, 1, 2], repeat=2)):
    clf.fit(X_train, y_train)
    ax = plt.subplot(gs[grd[0], grd[1]])
    fig = plot_decision_regions(X = X_train, y = np.array(y_train), clf=clf, legend=2)
    plt.title(lab)

plt.show()
165/21:
data = pd.read_csv('wineQualityReds.csv', index_col = 0)
data.head()
165/22: lr.coef_, lr.intercept_
165/23: svm.coef_, svm.intercept_
165/24:
# !pip install mlxtend

# В Колабе, возможно
!pip install mlxtend --upgrade
165/25:
data = pd.read_csv('wineQualityReds.csv', index_col = 0)
data.head()
165/26: data['quality'] = (data['quality'] == 5).astype(int)
165/27:
data['quality'] = (data['quality'] == 5).astype(int)
data.head()
165/28:
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)

# Отмасштабируйте признаки
ss = StandardScaler()
X_train = ss.fit_transform(X_train)
X_test = ss.transform(X_test)
165/29:
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)

# Отмасштабируйте признаки
ss = StandardScaler()
X_train = ss.fit_transform(X_train)
X_test = ss.transform(X_test)
165/30:
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)

# Отмасштабируйте признаки
ss = StandardScaler()
X_train = ss.fit_transform(X_train)
X_test = ss.transform(X_test)
166/1:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
166/2:
from sklearn.datasets import load_wine

data = load_wine()
X = pd.DataFrame(data['data'], columns = data['feature_names'])
y = data['target']
X.head(8)
166/3: data.isnull().sum()
166/4:
from sklearn.datasets import load_wine

data = load_wine()
X = pd.DataFrame(data['data'], columns = data['feature_names'])
y = data['target']
X.head(8)
166/5: data.isnull().sum()
166/6: data.head()
166/7:
from sklearn.datasets import load_wine

data = load_wine()
X = pd.DataFrame(data['data'], columns = data['feature_names'])
y = data['target']
X.head(8)
166/8:
from sklearn.datasets import load_wine

data = load_wine()
X = pd.DataFrame(data['data'], columns = data['feature_names'])
y = data['target']
X.head(8)
data
166/9:
from sklearn.datasets import load_wine

data = load_wine()
X = pd.DataFrame(data['data'], columns = data['feature_names'])
y = data['target']
X.head(8)
166/10: data.head(4)
166/11: X.isnull().sum()
166/12:
from sklearn.model_selection import train_test_split

Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.3)
166/13:
from sklearn.model_selection import train_test_split
np.random.seed(42)
Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.3)
166/14: np.random.seed(42)
166/15:
from sklearn.model_selection import train_test_split

Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.3)
166/16: from sklearn.neighbors import KNeighborsClassifier
166/17: !pip install mlxtend
166/18: import mlxtend
166/19: import mlxtend
166/20: import mlxtend
166/21: import mlxtend
166/22:
from sklearn.preprocessing import StandardScaler
ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain1 = scaler.fit_transform(Xtrain)
Xtest1 = scaler.transform(Xtest)

Xtrain1 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest1 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest1.head()
166/23:
from sklearn.preprocessing import StandardScaler
ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain1 = scaler.fit_transform(Xtrain)
Xtest1 = scaler.transform(Xtest)

Xtrain1 = pd.DataFrame(Xtrain1,columns = Xtrain.columns)
Xtest1 = pd.DataFrame(Xtest1,columns = Xtest.columns)
Xtest1.head()
166/24:
from sklearn.neighbors import KNeighborsClassifier

predictors = ['alcohol', 'magnesium']
y
166/25:
from sklearn.neighbors import KNeighborsClassifier

predictors = ['alcohol', 'magnesium']
neighbors = [1, 3, 5, 10, 15, 25]

for n in neighbors:
    kNN = KNeighborsClassifier(n_neighbors=n) 
    kNN.fit(X, y) 
    pred_knn = model.predict(X_test)
166/26:
from sklearn.neighbors import KNeighborsClassifier

predictors = ['alcohol', 'magnesium']
neighbors = [1, 3, 5, 10, 15, 25]
X_train_knn = Xtrain1.loc[1:, predictors]
X_test_knn = Xtest1.loc[1:, predictors]

for i, n in enumerate(neighbors):
    kNN = KNeighborsClassifier(n_neighbors=n) 
    kNN.fit(X_train_knn, ytrain) 
    train_knn = kNN.predict(X_train_knn)
    test_knn = kNN.predict(X_test_knn)
    ac_tr = accuracy_score(ytrain, train_knn)
    ac_tst = accuracy_score(ytest, test_knn)
    print(f'NN:{n} Train: {ac_tr} Test:{ac_tst}')
166/27:
from sklearn.neighbors import KNeighborsClassifier

predictors = ['alcohol', 'magnesium']
neighbors = [1, 3, 5, 10, 15, 25]
X_train_knn = Xtrain1.loc[1:, predictors]
# X_test_knn = Xtest1.loc[1:, predictors]

for i, n in enumerate(neighbors):
    kNN = KNeighborsClassifier(n_neighbors=n) 
    kNN.fit(X_train_knn, ytrain) 
    train_knn = kNN.predict(X_train_knn)
#     test_knn = kNN.predict(X_test_knn)
    ac_tr = accuracy_score(ytrain, train_knn)
#     ac_tst = accuracy_score(ytest, test_knn)
# Test:{ac_tst}
    print(f'NN:{n} Train: {ac_tr} ')
166/28:
from sklearn.neighbors import KNeighborsClassifier

predictors = ['alcohol', 'magnesium']
neighbors = [1, 3, 5, 10, 15, 25]
X_train_knn = Xtrain1[['alcohol', 'magnesium']]
# X_test_knn = Xtest1.loc[1:, predictors]
X_train_knn
# for i, n in enumerate(neighbors):
#     kNN = KNeighborsClassifier(n_neighbors=n) 
#     kNN.fit(X_train_knn, ytrain) 
#     train_knn = kNN.predict(X_train_knn)
# #     test_knn = kNN.predict(X_test_knn)
#     ac_tr = accuracy_score(ytrain, train_knn)
# #     ac_tst = accuracy_score(ytest, test_knn)
# # Test:{ac_tst}
#     print(f'NN:{n} Train: {ac_tr} ')
166/29:
from sklearn.neighbors import KNeighborsClassifier

predictors = ['alcohol', 'magnesium']
neighbors = [1, 3, 5, 10, 15, 25]
X_train_knn = Xtrain1[['alcohol', 'magnesium']]
# X_test_knn = Xtest1.loc[1:, predictors]
X_train_knn
ytrain
# for i, n in enumerate(neighbors):
#     kNN = KNeighborsClassifier(n_neighbors=n) 
#     kNN.fit(X_train_knn, ytrain) 
#     train_knn = kNN.predict(X_train_knn)
# #     test_knn = kNN.predict(X_test_knn)
#     ac_tr = accuracy_score(ytrain, train_knn)
# #     ac_tst = accuracy_score(ytest, test_knn)
# # Test:{ac_tst}
#     print(f'NN:{n} Train: {ac_tr} ')
166/30:
from sklearn.neighbors import KNeighborsClassifier

predictors = ['alcohol', 'magnesium']
neighbors = [1, 3, 5, 10, 15, 25]
X_train_knn = Xtrain1[['alcohol', 'magnesium']]
# X_test_knn = Xtest1.loc[1:, predictors]
X_train_knn
ytrain.size
# for i, n in enumerate(neighbors):
#     kNN = KNeighborsClassifier(n_neighbors=n) 
#     kNN.fit(X_train_knn, ytrain) 
#     train_knn = kNN.predict(X_train_knn)
# #     test_knn = kNN.predict(X_test_knn)
#     ac_tr = accuracy_score(ytrain, train_knn)
# #     ac_tst = accuracy_score(ytest, test_knn)
# # Test:{ac_tst}
#     print(f'NN:{n} Train: {ac_tr} ')
166/31:
from sklearn.neighbors import KNeighborsClassifier

predictors = ['alcohol', 'magnesium']
neighbors = [1, 3, 5, 10, 15, 25]
X_train_knn = Xtrain1[['alcohol', 'magnesium']]
# X_test_knn = Xtest1.loc[1:, predictors]
X_train_knn.size
# ytrain.size
# for i, n in enumerate(neighbors):
#     kNN = KNeighborsClassifier(n_neighbors=n) 
#     kNN.fit(X_train_knn, ytrain) 
#     train_knn = kNN.predict(X_train_knn)
# #     test_knn = kNN.predict(X_test_knn)
#     ac_tr = accuracy_score(ytrain, train_knn)
# #     ac_tst = accuracy_score(ytest, test_knn)
# # Test:{ac_tst}
#     print(f'NN:{n} Train: {ac_tr} ')
166/32:
from sklearn.neighbors import KNeighborsClassifier

predictors = ['alcohol', 'magnesium']
neighbors = [1, 3, 5, 10, 15, 25]
X_train_knn = Xtrain1[['alcohol', 'magnesium']]
# X_test_knn = Xtest1.loc[1:, predictors]
X_train_knn.shape
# ytrain.size
# for i, n in enumerate(neighbors):
#     kNN = KNeighborsClassifier(n_neighbors=n) 
#     kNN.fit(X_train_knn, ytrain) 
#     train_knn = kNN.predict(X_train_knn)
# #     test_knn = kNN.predict(X_test_knn)
#     ac_tr = accuracy_score(ytrain, train_knn)
# #     ac_tst = accuracy_score(ytest, test_knn)
# # Test:{ac_tst}
#     print(f'NN:{n} Train: {ac_tr} ')
166/33:
from sklearn.neighbors import KNeighborsClassifier

predictors = ['alcohol', 'magnesium']
neighbors = [1, 3, 5, 10, 15, 25]
X_train_knn = Xtrain1[['alcohol', 'magnesium']]
# X_test_knn = Xtest1.loc[1:, predictors]
X_train_knn
# for i, n in enumerate(neighbors):
#     kNN = KNeighborsClassifier(n_neighbors=n) 
#     kNN.fit(X_train_knn, ytrain) 
#     train_knn = kNN.predict(X_train_knn)
# #     test_knn = kNN.predict(X_test_knn)
#     ac_tr = accuracy_score(ytrain, train_knn)
# #     ac_tst = accuracy_score(ytest, test_knn)
# # Test:{ac_tst}
#     print(f'NN:{n} Train: {ac_tr} ')
166/34:
from sklearn.neighbors import KNeighborsClassifier

predictors = ['alcohol', 'magnesium']
neighbors = [1, 3, 5, 10, 15, 25]
X_train_knn = Xtrain1[['alcohol', 'magnesium']]
X_test_knn = Xtest1[['alcohol', 'magnesium']]

for i, n in enumerate(neighbors):
    kNN = KNeighborsClassifier(n_neighbors=n) 
    kNN.fit(X_train_knn, ytrain) 
    train_knn = kNN.predict(X_train_knn)
    test_knn = kNN.predict(X_test_knn)
    ac_tr = accuracy_score(ytrain, train_knn)
    ac_tst = accuracy_score(ytest, test_knn)
    print(f'NN:{n} Train: {ac_tr} Test:{ac_tst}')
166/35:
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

predictors = ['alcohol', 'magnesium']
neighbors = [1, 3, 5, 10, 15, 25]
X_train_knn = Xtrain1[['alcohol', 'magnesium']]
X_test_knn = Xtest1[['alcohol', 'magnesium']]

for i, n in enumerate(neighbors):
    kNN = KNeighborsClassifier(n_neighbors=n) 
    kNN.fit(X_train_knn, ytrain) 
    train_knn = kNN.predict(X_train_knn)
    test_knn = kNN.predict(X_test_knn)
    ac_tr = accuracy_score(ytrain, train_knn)
    ac_tst = accuracy_score(ytest, test_knn)
    print(f'NN:{n} Train: {ac_tr} Test:{ac_tst}')
166/36: import mlxtend
166/37:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools
gs = gridspec.GridSpec(3, 2)
166/38:
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

predictors = ['alcohol', 'magnesium']
neighbors = [1, 3, 5, 10, 15, 25]
X_train_knn = Xtrain1[['alcohol', 'magnesium']]
X_test_knn = Xtest1[['alcohol', 'magnesium']]

labels = []
classificators = []

for i, n in enumerate(neighbors):
    kNN = KNeighborsClassifier(n_neighbors=n) 
    classificators.append(kNN)
    labels.appenfd(f'n_neighbors={n}')
    kNN.fit(X_train_knn, ytrain)
    train_knn = kNN.predict(X_train_knn)
    test_knn = kNN.predict(X_test_knn)
    ac_tr = accuracy_score(ytrain, train_knn)
    ac_tst = accuracy_score(ytest, test_knn)
    print(f'NN:{n} Train: {ac_tr} Test:{ac_tst}')
166/39:
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

predictors = ['alcohol', 'magnesium']
neighbors = [1, 3, 5, 10, 15, 25]
X_train_knn = Xtrain1[['alcohol', 'magnesium']]
X_test_knn = Xtest1[['alcohol', 'magnesium']]

labels = []
classificators = []

for i, n in enumerate(neighbors):
    kNN = KNeighborsClassifier(n_neighbors=n) 
    classificators.append(kNN)
    labels.append(f'n_neighbors={n}')
    kNN.fit(X_train_knn, ytrain)
    train_knn = kNN.predict(X_train_knn)
    test_knn = kNN.predict(X_test_knn)
    ac_tr = accuracy_score(ytrain, train_knn)
    ac_tst = accuracy_score(ytest, test_knn)
    print(f'NN:{n} Train: {ac_tr} Test:{ac_tst}')
166/40: classificators
166/41:
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

predictors = ['alcohol', 'magnesium']
neighbors = [1, 3, 5, 10, 15, 25]
X_train_knn = Xtrain1[['alcohol', 'magnesium']]
X_test_knn = Xtest1[['alcohol', 'magnesium']]

labels = []
classificators = []

for i, n in enumerate(neighbors):
    kNN = KNeighborsClassifier(n_neighbors=n) 
    classificators.append(kNN)
    labels.append(f'n_neighbors={n}')
    kNN.fit(X_train_knn, ytrain)
    train_knn = kNN.predict(X_train_knn)
    test_knn = kNN.predict(X_test_knn)
    ac_tr = accuracy_score(ytrain, train_knn)
    ac_tst = accuracy_score(ytest, test_knn)
    print(f'NN:{n} Train: {ac_tr} Test:{ac_tst}')
166/42: classificators
166/43:
classificators
labels
166/44:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools
gs = gridspec.GridSpec(3, 2)
fig = plt.figure(figsize=(10,8))

for i, cl in enumerate(classificators):
    plot_decision_regions(X_test_knn.values, ytest.values, clf = cl, legend = 2)
    plt.title(labels[i])
166/45:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools
gs = gridspec.GridSpec(3, 2)
fig = plt.figure(figsize=(10,8))

for i, cl in enumerate(classificators):
    plot_decision_regions(X_test_knn, ytest, clf = cl, legend = 2)
    plt.title(labels[i])
166/46:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools
gs = gridspec.GridSpec(3, 2)
fig = plt.figure(figsize=(10,8))

# for i, cl in enumerate(classificators):
#     plot_decision_regions(X_test_knn, ytest, clf = cl, legend = 2)
#     plt.title(labels[i])
type X
166/47:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools
gs = gridspec.GridSpec(3, 2)
fig = plt.figure(figsize=(10,8))

# for i, cl in enumerate(classificators):
#     plot_decision_regions(X_test_knn, ytest, clf = cl, legend = 2)
#     plt.title(labels[i])
type X_test_knn
166/48:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools
gs = gridspec.GridSpec(3, 2)
fig = plt.figure(figsize=(10,8))

# for i, cl in enumerate(classificators):
#     plot_decision_regions(X_test_knn, ytest, clf = cl, legend = 2)
#     plt.title(labels[i])
type(X_test_knn)
166/49:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools
gs = gridspec.GridSpec(3, 2)
fig = plt.figure(figsize=(10,8))

# for i, cl in enumerate(classificators):
#     plot_decision_regions(X_test_knn, ytest, clf = cl, legend = 2)
#     plt.title(labels[i])
type(X_test_knn.to_numpy())
166/50:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools
gs = gridspec.GridSpec(3, 2)
fig = plt.figure(figsize=(10,8))

# for i, cl in enumerate(classificators):
#     plot_decision_regions(X_test_knn, ytest, clf = cl, legend = 2)
#     plt.title(labels[i])
type(X_test_knn.values)
166/51:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools
gs = gridspec.GridSpec(3, 2)
fig = plt.figure(figsize=(10,8))

X_test_numpy = X_test_knn.to_numpy()
y_test_numpy = ytest.to_numpy()

# for i, cl in enumerate(classificators):
#     plot_decision_regions(X_test_knn, ytest, clf = cl, legend = 2)
#     plt.title(labels[i])
type(X_test_knn.values)
166/52:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools
gs = gridspec.GridSpec(3, 2)
fig = plt.figure(figsize=(10,8))

X_test_numpy = X_test_knn.to_numpy()
y_test_numpy = ytest.to_numpy()

# for i, cl in enumerate(classificators):
#     plot_decision_regions(X_test_knn, ytest, clf = cl, legend = 2)
#     plt.title(labels[i])
X_test_numpy
166/53:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools
gs = gridspec.GridSpec(3, 2)
fig = plt.figure(figsize=(10,8))

X_test_numpy = X_test_knn.to_numpy()
y_test_numpy = ytest.to_numpy()

# for i, cl in enumerate(classificators):
#     plot_decision_regions(X_test_knn, ytest, clf = cl, legend = 2)
#     plt.title(labels[i])
X_test_numpy
166/54:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools
gs = gridspec.GridSpec(3, 2)
fig = plt.figure(figsize=(10,8))

X_test_numpy = X_test_knn.to_numpy()
y_test_numpy = ytest.to_numpy()

# for i, cl in enumerate(classificators):
#     plot_decision_regions(X_test_knn, ytest, clf = cl, legend = 2)
#     plt.title(labels[i])
166/55:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools
gs = gridspec.GridSpec(3, 2)
fig = plt.figure(figsize=(10,8))

X_test_numpy = X_test_knn.to_numpy()
y_test_numpy = ytest.to_numpy()

# for i, cl in enumerate(classificators):
#     plot_decision_regions(X_test_knn, ytest, clf = cl, legend = 2)
#     plt.title(labels[i])
166/56:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools
gs = gridspec.GridSpec(3, 2)
fig = plt.figure(figsize=(10,8))

# X_test_numpy = X_test_knn.to_numpy()
# y_test_numpy = ytest.to_numpy()

for i, cl in enumerate(classificators):
    plot_decision_regions(X_test_knn, ytest, clf = cl, legend = 2)
    plt.title(labels[i])
166/57:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools
gs = gridspec.GridSpec(3, 2)
fig = plt.figure(figsize=(10,8))

# X_test_numpy = X_test_knn.to_numpy()
# y_test_numpy = ytest.to_numpy()

for i, cl in enumerate(classificators):
    plot_decision_regions(X_test_knn.to_numpy(), ytest, clf = cl, legend = 2)
    plt.title(labels[i])
166/58:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools

gs = gridspec.GridSpec(3, 2)
fig = plt.figure(figsize=(10,8))

# X_test_numpy = X_test_knn.to_numpy()
# y_test_numpy = ytest.to_numpy()

for clf, lab, grd in zip(classificators, labels, itertools.product([0, 1], repeat=2)):
    ax = plt.subplot(gs[grd[0], grd[1]])
    fig = plot_decision_regions(X=X_test_knn, y=ytest, clf=clf, legend=2)
    plt.title(lab)

plt.show()
166/59:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools

gs = gridspec.GridSpec(3, 2)
fig = plt.figure(figsize=(10,8))

X_test_numpy = X_test_knn.to_numpy()
y_test_numpy = ytest.to_numpy()

for clf, lab, grd in zip(classificators, labels, itertools.product([0, 1], repeat=2)):
    ax = plt.subplot(gs[grd[0], grd[1]])
    fig = plot_decision_regions(X=X_test_numpy, y=y_test_numpy, clf=clf, legend=2)
    plt.title(lab)

plt.show()
166/60:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools

gs = gridspec.GridSpec(3, 2)
fig = plt.figure(figsize=(10,8))

for clf, lab, grd in zip(classificators, labels, itertools.product([0, 1], repeat=2)):
    ax = plt.subplot(gs[grd[0], grd[1]])
    fig = plot_decision_regions(X=X_test_knn.to_numpy(), y=ytest.to_numpy(), clf=clf, legend=2)
    plt.title(lab)

plt.show()
166/61:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools

gs = gridspec.GridSpec(3, 2)
fig = plt.figure(figsize=(10,8))

for clf, lab, grd in zip(classificators, labels, itertools.product([0, 1], repeat=2)):
    ax = plt.subplot(gs[grd[0], grd[1]])
    fig = plot_decision_regions(X=X_test_knn.to_numpy(), y=ytest, clf=clf, legend=2)
    plt.title(lab)

plt.show()
166/62:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools

gs = gridspec.GridSpec(2, 3)
fig = plt.figure(figsize=(10,8))

for clf, lab, grd in zip(classificators, labels, itertools.product([0, 1, 2], repeat=2)):
    ax = plt.subplot(gs[grd[0], grd[1]])
    fig = plot_decision_regions(X=X_test_knn.to_numpy(), y=ytest, clf=clf, legend=2)
    plt.title(lab)

plt.show()
166/63:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools

gs = gridspec.GridSpec(2, 3)
fig = plt.figure(figsize=(8, 10))

for clf, lab, grd in zip(classificators, labels, itertools.product([0, 1, 2], repeat=2)):
    ax = plt.subplot(gs[grd[0], grd[1]])
    fig = plot_decision_regions(X=X_test_knn.to_numpy(), y=ytest, clf=clf, legend=2)
    plt.title(lab)

plt.show()
166/64:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools

gs = gridspec.GridSpec(2, 3)
fig = plt.figure(figsize=(15,8))

for clf, lab, grd in zip(classificators, labels, itertools.product([0, 1, 2], repeat=2)):
    ax = plt.subplot(gs[grd[0], grd[1]])
    fig = plot_decision_regions(X=X_test_knn.to_numpy(), y=ytest, clf=clf, legend=2)
    plt.title(lab)

plt.show()
166/65:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools

gs = gridspec.GridSpec(2, 3)
fig = plt.figure(figsize=(15,8))

for clf, lab, grd in zip(classificators, labels, itertools.product([0, 1, 2], repeat=2)):
    ax = plt.subplot(gs[grd[0], grd[1]])
    fig = plot_decision_regions(X=X_test_knn.to_numpy(), y=ytest, clf=clf, zoom_factor=0.7, legend=2)
    plt.title(lab)

plt.show()
166/66:
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

predictors = ['alcohol', 'magnesium']
neighbors = [1, 3, 5, 10, 15, 25]
X_train_knn = Xtrain1[['alcohol', 'magnesium']]
X_test_knn = Xtest1[['alcohol', 'magnesium']]

labels = []
classificators = []

for i, n in enumerate(neighbors):
    kNN = KNeighborsClassifier(n_neighbors=n) 
    kNN.fit(X_train_knn, ytrain)
    classificators.append(kNN)
    labels.append(f'n_neighbors={n}')
    train_knn = kNN.predict(X_train_knn)
    test_knn = kNN.predict(X_test_knn)
    ac_tr = accuracy_score(ytrain, train_knn)
    ac_tst = accuracy_score(ytest, test_knn)
    print(f'NN:{n} Train: {ac_tr} Test:{ac_tst}')
166/67:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools

gs = gridspec.GridSpec(2, 3)
fig = plt.figure(figsize=(15,8))

for clf, lab, grd in zip(classificators, labels, itertools.product([0, 1, 2], repeat=2)):
    ax = plt.subplot(gs[grd[0], grd[1]])
    fig = plot_decision_regions(X=X_test_knn.to_numpy(), y=ytest, clf=clf, zoom_factor=0.7, legend=2)
    plt.title(lab)

plt.show()
166/68:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools

gs = gridspec.GridSpec(2, 3)
fig = plt.figure(figsize=(15,8))

for clf, lab, grd in zip(classificators, labels, itertools.product([0, 1, 2], repeat=2)):
    ax = plt.subplot(gs[grd[0], grd[1]])
    fig = plot_decision_regions(X=X_train_knn.to_numpy(), y=ytrain, clf=clf, zoom_factor=0.7, legend=2)
    plt.title(lab)

plt.show()
166/69:
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import matplotlib.gridspec as gridspec
import itertools

gs = gridspec.GridSpec(2, 3)
fig = plt.figure(figsize=(15,8))

for clf, lab, grd in zip(classificators, labels, itertools.product([0, 1, 2], repeat=2)):
    ax = plt.subplot(gs[grd[0], grd[1]])
    fig = plot_decision_regions(X=X_train_knn.to_numpy(), y=ytrain, clf=clf, legend=2)
    plt.title(lab)

plt.show()
166/70:
Для к=5 и к=10 границы являются наиболее сглаженными. Для к=1 и 3 происходит переобучение модели, тк она опирается на слишком малое число соседей

Для к = 15 и 25 зеленая область как класс почти исчезает, тк слишком много объектов принимает участиеЮ
166/71:
Для к=5 и к=10 границы являются наиболее сглаженными. Для к=1 и 3 происходит переобучение модели, тк она опирается на слишком малое число соседей

Для к = 15 и 25 зеленая область как класс почти исчезает, тк слишком много объектов принимает участие

Также по таблице в 1.3 видно, что лучшие результаты получаются при к=1 и к=10. Однако если установить k=1, то алгоритм будет просто присваивать любому новому наблюдению метку класса ближайшего объекта.
166/72:
data = pd.read_csv('Automobile.csv')
data.head(5)
167/1: data.isnull().sum()
167/2:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
167/3:
data = pd.read_csv('Automobile.csv')
data.head(5)
167/4: data.isnull().sum()
167/5:
data = pd.read_csv('Automobile.csv')
data.head(100)
167/6: data.isna()
167/7: data.value_counts()
167/8: data.dtypes
167/9: df[df['normalized-losses'].str.contains('?')].count()
167/10: data[data['normalized-losses'].str.contains('?')].count()
167/11: data[data['normalized-losses'].str.contains('?')].count
167/12: data[data['normalized-losses'].str.contains('?')]
167/13:
found = data[data['normalized-losses'].str.contains('?')]

print(len(found))
167/14:
found = data[data['normalized-losses'].str.contains('106')]

print(len(found))
167/15:
found = data[data['normalized-losses'].str.contains('?')]

print(len(found))
167/16:
found = data[data['normalized-losses'].str.contains('/?')]

print(len(found))
167/17: data.chape
167/18: data.shape
167/19:
found = data[data['normalized-losses'].str.contains('/?')]

print(found)
167/20:
found = data[data['normalized-losses'].str.contains(''\?')]

print(found)
167/21:
found = data[data['normalized-losses'].str.contains('\?')]

print(found)
167/22:
found = data[data['normalized-losses'].str.contains('\?')]

print(len(found)
167/23:
found = data[data['normalized-losses'].str.contains('\?')]

print(len(found))
167/24: data['normalized-losses'].median()
167/25:
found = data[~data['normalized-losses'].str.contains('\?')]

print(len(found)
167/26:
found = data[~data['normalized-losses'].str.contains('\?')]

print(len(found))
167/27:
found = data[~data['normalized-losses'].str.contains('\?')]
med = found.median()
print(len(found))
print((med))
167/28:
found = data[~data['normalized-losses'].str.contains('\?')]
med = found.median()
print(len(found))
print(med)
167/29:
df = data[~data['normalized-losses'].str.contains('\?')]
med = df['normalized-losses'].median()
print(found)
print(med)
167/30:
df = data[~data['normalized-losses'].str.contains('\?')]
med = df['normalized-losses'].median()

print(med)
167/31:
df = data[~data['normalized-losses'].str.contains('\?')]
med = df.median()

print(med)
167/32:
df2 = data[data['column name'].str.contains('\?')]

data['normalized-losses'].median()
167/33:
df = data[~data['normalized-losses'].str.contains('\?')]
med = df['normalized-losses'].median()

print(med)
167/34: data['normalized-losses'] = data['normalized-losses'].apply(lambda x: if x == '?' med else x)
167/35: data['normalized-losses'] = data['normalized-losses'].apply(lambda x: med if x == '?' else x)
167/36: data['normalized-losses'] = data['normalized-losses'].apply(lambda x: med if x == '?' else x)
167/37:
data['normalized-losses'] = data['normalized-losses'].apply(lambda x: med if x == '?' else x)
data.head()
167/38:
data['normalized-losses'] = data['normalized-losses'].apply(lambda x: round(med) if x == '?' else x)
data.head()
167/39:
data['normalized-losses'] = data['normalized-losses'].apply(lambda x: round(med) if x == '?' else x)
data.head()
167/40:
med = round(med)
data['normalized-losses'] = data['normalized-losses'].apply(lambda x: med if x == '?' else x)
data.head()
167/41:
data['normalized-losses'] = data['normalized-losses'].apply(lambda x: med if x == '?' else x)
data.head()
167/42:
y = data['price']
numericData = data._get_numeric_data()
numericData.corrwith(y)
167/43:
y = data['price']
numericData = data._get_numeric_data()
numericData
167/44:
y = data['price']
numericData = data._get_numeric_data()
numericData.corr()
167/45:
y = data['price']
numericData = data._get_numeric_data()
numericData.corr()
167/46:
numericData = data._get_numeric_data()
numericData.corr()

#
167/47:
y = data['price']
numericData = data._get_numeric_data()
numericData.corr()
167/48: numericData.corrwith(y)
167/49: y
167/50: numericData.corrWith(y)
167/51: numericData.corrwith(y)
167/52: numericData.corrwith(y)
167/53:
y = data['price'].astype(int)
numericData = data._get_numeric_data()
numericData.corr()
167/54:
y = data['price'].astype(int)
numericData = data._get_numeric_data()
numericData.corr()
167/55:
data['price']
# numericData = data._get_numeric_data()
# numericData.corr()
167/56:
data['price'].str.contains('\?')
# numericData = data._get_numeric_data()
# numericData.corr()
167/57:
data['price'].str.contains('\?').count()
# numericData = data._get_numeric_data()
# numericData.corr()
167/58:
data['price'].str.contains('?').count()
# numericData = data._get_numeric_data()
# numericData.corr()
167/59:
data['price'].str.contains('\?').count()
# numericData = data._get_numeric_data()
# numericData.corr()
167/60:
data[data['price'].str.contains('\?')].count()
# numericData = data._get_numeric_data()
# numericData.corr()
167/61:
data[data['price'].str.contains('\?')]
# numericData = data._get_numeric_data()
# numericData.corr()
167/62:
data.str.contains('\?')
# numericData = data._get_numeric_data()
# numericData.corr()
167/63:
data[data['fuel-type'].str.contains('\?')]
# numericData = data._get_numeric_data()
# numericData.corr()
167/64:
data[data['price'].str.contains('\?')]
# numericData = data._get_numeric_data()
# numericData.corr()
167/65: data[data['price'].str.contains('\?')]
167/66: data.drop(data[data['price'].str.contains('\?')], inplace=True)
167/67:
data.drop(data['price'].str.contains('\?'), inplace=True)
data.head
167/68:
# data.drop(data['price'].str.contains('\?'), inplace=True)
data.head()
167/69:
# data.drop(data['price'].str.contains('\?'), inplace=True)
data.shape
167/70:
data.drop(data[data['price'] == '?']), inplace=True)
data.shape
167/71:
data.drop(data[data['price'] == '?'], inplace=True)
data.shape
167/72:
data.drop(data[data['price'] == '?'], inplace=True)
data.shape
167/73:
data['price'] = data['price'].apply(lambda x: None if x == '?' else x)

# data.dropna()
# data.shape
167/74:
data['price'] = data['price'].apply(lambda x: None if x == '?' else x)
data[data['normalized-losses'].str.contains('\?')]
# data.dropna()
# data.shape
167/75:
data['price'] = data['price'].apply(lambda x: None if x == '?' else x)
data[data['price'].str.contains('?')]
# data.dropna()
# data.shape
167/76:
data['price'] = data['price'].apply(lambda x: None if x == '?' else x)
data
# data.dropna()
# data.shape
167/77:
data['price'] = data['price'].apply(lambda x: None if x == '?' else x)

data.dropna()
data.shape
167/78:

numericData = data._get_numeric_data()
numericData.corr()
167/79:
y = data['price']
numericData = data._get_numeric_data()
numericData.corr()
167/80: numericData.corrwith(y)
167/81: y
167/82: data.dtype
167/83: data.dtypes
167/84:
y = data['price'].astype(str).astype(int)

numericData = data._get_numeric_data()
numericData.corr()
167/85:
data['price'] = data['price'].apply(lambda x: None if x == '?' else x)

data.dropna()
data.shape
167/86: data[data.price ==None]
167/87: data[data.price =='None']
167/88: data[data.price =='?']
167/89: data[data.price]
167/90:
data = pd.read_csv('Automobile.csv')
data.head(100)
167/91: data.isnull().sum()
167/92: data.shape
167/93:
df = data[~data['normalized-losses'].str.contains('\?')]
med = df['normalized-losses'].median()

print(med)
167/94:
data['normalized-losses'] = data['normalized-losses'].apply(lambda x: med if x == '?' else x)
data['normalized-losses'] = data['normalized-losses'].apply(lambda x: med if x == '?' else x)data.head()
167/95:
data['normalized-losses'] = data['normalized-losses'].apply(lambda x: med if x == '?' else x)
data['normalized-losses'] = data['normalized-losses'].apply(lambda x: med if x == '?' else x)
data.head()
167/96:
data['normalized-losses'] = data['normalized-losses'].apply(lambda x: med if x == '?' else x)
data.head()
167/97:
df = data[~data['price'].str.contains('\?')]
med = df['price'].median()
167/98:
df = data[~data['price'].str.contains('\?')]
med = df['price'].median()
167/99:
data['price'] = data['price'].apply(lambda x: med if x == '?' else x)
data.head()
167/100:
y = data['price'].astype(str).astype(int)
y
# numericData = data._get_numeric_data()
# numericData.corr()
167/101:
y = data['price'].astype(str).astype(float)
y
# numericData = data._get_numeric_data()
# numericData.corr()
167/102:
y = data['price'].astype(str).astype(float)
y
numericData = data._get_numeric_data()
numericData.corr()
167/103: numericData.corrwith(y)
167/104:
df = data[data['price'].str.contains('\ ?')]
# med = df['price'].median()
df
167/105:
df = data[data['price'].str.contains(' ?')]
# med = df['price'].median()
df
167/106:
df = data[data['price'].str.contains(' ?')]
# med = df['price'].median()
df.head()
167/107:
df = data[data['price'].str.contains(' ?')]
# med = df['price'].median()
df.head(1)
167/108:
df = data[data['price'].str.contains(' ? ')]
# med = df['price'].median()
df.head(1)
167/109:
df = data[data['price'].str.contains(' /? ')]
# med = df['price'].median()
df.head(1)
167/110:
df = data[data['price'].str.contains('\ ?')]
# med = df['price'].median()
167/111:
df = data[data['price'].str.contains('\ ?')]
med = df['price'].median()
167/112:
df = data[~data['price'].str.contains('\?')]
med = df['price'].median()
167/113:
data = pd.read_csv('Automobile.csv')
data.head(100)
167/114: data.isnull().sum()
167/115:
data = pd.read_csv('Automobile.csv')
data.head(100)
167/116: data.isnull().sum()
167/117: data.shape
167/118:
df = data[~data['normalized-losses'].str.contains('\?')]
med = df['normalized-losses'].median()

print(med)
167/119:
data['normalized-losses'] = data['normalized-losses'].apply(lambda x: med if x == '?' else x)
data.head()
167/120:
df = data[~data['price'].str.contains('\?')]
med = df['price'].median()
167/121:
data['price'] = data['price'].apply(lambda x: med if x == '?' else x)
data.head()
167/122: data[data['price'] == ' ?']
167/123: data[data['price'] == ' ? ']
167/124: data[data['price'] == '? ']
167/125:
# прочитав описание на kaggle, делаю вывод, что таких столбцов нет
data.column
167/126:
# прочитав описание на kaggle, делаю вывод, что таких столбцов нет
data.columns
167/127:
data = pd.get_dummies(data, columns=['make', 'fuel-type', 'aspiration', 'num-of-doors', 'body-style', 'drive-wheels', 'engine-location', 'fuel-system' ], drop_first=True)
data.head()
167/128:
data = pd.get_dummies(data, columns=['make', 'fuel-type', 'aspiration', 'num-of-doors', 'engine-type', 'body-style', 'drive-wheels', 'engine-location', 'fuel-system' ], drop_first=True)
data.head()
167/129:
data = pd.read_csv('Automobile.csv')
data.head(100)
167/130:
df = data[~data['normalized-losses'].str.contains('\?')]
med = df['normalized-losses'].median()

print(med)
167/131:
data['normalized-losses'] = data['normalized-losses'].apply(lambda x: med if x == '?' else x)
data.head()
167/132:
df = data[~data['price'].str.contains('\?')]
med = df['price'].median()
167/133:
data['price'] = data['price'].apply(lambda x: med if x == '?' else x)
data.head()
167/134:
# прочитав описание на kaggle, делаю вывод, что таких столбцов нет
data.columns
167/135:
y = data['price'].astype(str).astype(float)
y
numericData = data._get_numeric_data()
numericData.corr()
167/136:
data = pd.get_dummies(data, columns=['make', 'fuel-type', 'aspiration', 'num-of-doors', 'engine-type', 'body-style', 'drive-wheels', 'engine-location', 'fuel-system' ], drop_first=True)
data.head()
167/137:
data = pd.read_csv('Automobile.csv')
data.head(100)
167/138: data.isnull().sum()
167/139: data.shape
167/140:
df = data[~data['normalized-losses'].str.contains('\?')]
med = df['normalized-losses'].median()

print(med)
167/141:
data['normalized-losses'] = data['normalized-losses'].apply(lambda x: med if x == '?' else x)
data.head()
167/142:
df = data[~data['price'].str.contains('\?')]
med = df['price'].median()
167/143:
data['price'] = data['price'].apply(lambda x: med if x == '?' else x)
data.head()
167/144:
# прочитав описание на kaggle, делаю вывод, что таких столбцов нет
data.columns
167/145:
y = data['price'].astype(str).astype(float)
y
numericData = data._get_numeric_data()
numericData.corr()
167/146:
numericData.corrwith(y)

# width, curb-weight, engine-size коррелируют больше всего с price
167/147:
data = pd.get_dummies(data, columns=['make', 'fuel-type', 'num-of-cylinders', 'aspiration', 'num-of-doors', 'engine-type', 'body-style', 'drive-wheels', 'engine-location', 'fuel-system' ], drop_first=True)
dadfdfta.head()
167/148: data = pd.get_dummies(data, columns=['make', 'fuel-type', 'num-of-cylinders', 'aspiration', 'num-of-doors', 'engine-type', 'body-style', 'drive-wheels', 'engine-location', 'fuel-system' ], drop_first=True)
167/149:
data = pd.read_csv('Automobile.csv')
data.head(100)
167/150: data.isnull().sum()
167/151: data.shape
167/152:
df = data[~data['normalized-losses'].str.contains('\?')]
med = df['normalized-losses'].median()

print(med)
167/153:
data['normalized-losses'] = data['normalized-losses'].apply(lambda x: med if x == '?' else x)
data.head()
167/154:
df = data[~data['price'].str.contains('\?')]
med = df['price'].median()
167/155:
data['price'] = data['price'].apply(lambda x: med if x == '?' else x)
data.head()
167/156:
# прочитав описание на kaggle, делаю вывод, что таких столбцов нет
data.columns
167/157:
y = data['price'].astype(str).astype(float)
y
numericData = data._get_numeric_data()
numericData.corr()
167/158:
numericData.corrwith(y)

# width, curb-weight, engine-size коррелируют больше всего с price
167/159: data = pd.get_dummies(data, columns=['make', 'fuel-type', 'num-of-cylinders', 'aspiration', 'num-of-doors', 'engine-type', 'body-style', 'drive-wheels', 'engine-location', 'fuel-system' ], drop_first=True)
167/160: data.head()
167/161: X = data._get_numeric_data().drop('price', axis=1)
167/162: data
167/163: data.co,umns
167/164: data.columns
167/165: X = data.drop('price', axis=1)
167/166: X
167/167: X.dtypes
167/168: data.info()
167/169: data['bore'] = data['bore'].astype(int)
167/170:
data['price'] = data['price'].astype(str).astype(float)
y = data['price']
numericData = data._get_numeric_data()
numericData.corr()
167/171: data.info()
167/172:
data['bore'] = data['bore'].astype(float)
data['stroke'] = data['stroke'].astype(int)
data['normalized-losses'] = data['normalized-losses'].astype(int)
data['horsepower']= data['normalized-losses'].astype(int)
data['peak-rpm']= data['peak-rpm'].astype(int)
167/173:
adata['bore'] = data['bore'].astype(str).astype(float)
data['stroke'] = data['stroke'].astype(int)
data['normalized-losses'] = data['normalized-losses'].astype(int)
data['horsepower']= data['normalized-losses'].astype(int)
data['peak-rpm']= data['peak-rpm'].astype(int)
167/174:
data = pd.read_csv('Automobile.csv', na_values=['?', ' ?', '? '])
data.head(100)
167/175: data.isnull().sum()
167/176:
df = data[~data['normalized-losses'].str.contains('\?')]
med = df['normalized-losses'].median()

print(med)
167/177: data['normalized-losses'].fillna((data['normalized-losses'].mean()), inplace=True)
167/178: data['normalized-losses'].fillna((data['normalized-losses'].mean()), inplace=True)
167/179:
data['normalized-losses'].fillna((data['normalized-losses'].mean()), inplace=True)
data.head()
167/180: data.dropna(inplace=True)
167/181:

data.head()
167/182: data.head()
167/183:
# прочитав описание на kaggle, делаю вывод, что таких столбцов нет
data.columns
167/184:
data['price'] = data['price'].astype(str).astype(float)
y = data['price']
numericData = data._get_numeric_data()
numericData.corr()
167/185:
numericData.corrwith(y)

# width, curb-weight, engine-size коррелируют больше всего с price
167/186: data = pd.get_dummies(data, columns=['make', 'fuel-type', 'num-of-cylinders', 'aspiration', 'num-of-doors', 'engine-type', 'body-style', 'drive-wheels', 'engine-location', 'fuel-system' ], drop_first=True)
167/187: data.head()
167/188: data.info()
167/189: X = data.drop('price', axis=1)
167/190:
from sklearn.model_selection import train_test_split

Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, test_size=0.3)
167/191:
from sklearn.preprocessing import StandardScaler
ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain1 = scaler.fit_transform(Xtrain)
Xtest1 = scaler.transform(Xtest)

Xtrain1 = pd.DataFrame(Xtrain2,columns = Xtrain.columns)
Xtest1 = pd.DataFrame(Xtest2,columns = Xtest.columns)
Xtest1.head()
167/192:
from sklearn.preprocessing import StandardScaler
ss = StandardScaler()
scaler = ss.fit(Xtrain)
Xtrain1 = scaler.fit_transform(Xtrain)
Xtest1 = scaler.transform(Xtest)

Xtrain1 = pd.DataFrame(Xtrain1,columns = Xtrain.columns)
Xtest1 = pd.DataFrame(Xtest1,columns = Xtest.columns)
Xtest1.head()
167/193:
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
from sklearn.metrics import mean_squared_error

lr = LinearRegression()
lr.fit(Xtrain1, ytrain)

train_pred = lr.predict(Xtrain1)
test_pred = lr.predict(Xtest1)

print("Train MSE: {}".format(np.sqrt(mean_squared_error(ytrain, train_pred))))
print("Test MSE: {}".format(np.sqrt(mean_squared_error(ytest, test_pred))))

print(f'''
train R2={r2_score(ytrain, train_pred)}
''')

print(f'''
test R2={r2_score(ytest, test_pred)}
''')
167/194: Xtrain2 (for feature, coeff in zip(Xtrain2.columns,lr.coef_.T))
167/195:
print('Coefficients: \n', lr.coef_, "\n")
print('Feature:  Weight:')

Xtrain2 (for feature, coeff in zip(Xtrain2.columns,lr.coef_.T)):
    print(feature, coeff)
167/196:
print('Coefficients: \n', lr.coef_, "\n")
print('Feature:  Weight:')

for feature, coeff in zip(Xtrain1.columns,lr.coef_.T):
    print(feature, coeff)
167/197:
print('Coefficients: \n', lr.coef_, "\n")
print('Feature:  Weight:')


    print(Xtrain2 (for feature, coeff in zip(Xtrain2.columns,lr.coef_.T)))
167/198:
print('Coefficients: \n', lr.coef_, "\n")
print('Feature:  Weight:')

Xtrain2 (for feature, coeff in zip(Xtrain1.columns,lr.coef_.T):
    print(feature, coeff)
167/199:
print('Coefficients: \n', lr.coef_, "\n")
print('Feature:  Weight:')

Xtrain1 (for feature, coeff in zip(Xtrain1.columns,lr.coef_.T):
167/200:
print('Coefficients: \n', lr.coef_, "\n")
print('Feature:  Weight:')

for feature, coeff in zip(Xtrain1.columns,lr.coef_.T:
167/201:
print('Coefficients: \n', lr.coef_, "\n")
print('Feature:  Weight:')

for feature, coeff in zip(Xtrain1.columns,lr.coef_.T):
    print(coeff, feature)
167/202:
print('Coefficients: \n', lr.coef_, "\n")
print('Feature:  Weight:')

for feature, coeff in zip(Xtrain1.columns,lr.coef_.T):
    print(feature, coeff)
167/203:
print('Coefficients: \n', lr.coef_, "\n")
print('Feature:  Weight:')



cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(lr.coef_))], axis = 1)
cdf
167/204:
cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(lr.coef_))], axis = 1)
cdf
167/205:
cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(lr.coef_))], axis = 1)
cdf.sort_values()
167/206:
cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(lr.coef_))], axis = 1)
cdf.sort_values(by='')
167/207:
cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(lr.coef_))], axis = 1)
cdf.sort_values('2')
167/208:
cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(lr.coef_))], axis = 1)
cdf
167/209:
cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(lr.coef_))], axis = 1)
cdf.sort_values(cdf['2'])
167/210:
cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(lr.coef_))], axis = 1)
cdf.sort_values(by=['2'], ascending=False)
167/211:
cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(lr.coef_))], axis = 1)
cdf = cdf.sort_values(by=['2'], ascending=False)
cdf
167/212:
cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(lr.coef_))], axis = 1)
cdf = cdf.sort_values(by=['0'], ascending=False)
cdf
167/213:
cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(lr.coef_))], axis = 1)
cdf.columns
167/214:
cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(lr.coef_))], axis = 1)
cdf.columns = ['feature', 'value']
167/215:
cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(lr.coef_))], axis = 1)
cdf.columns = ['feature', 'value']
cdf.sort_values('value')
167/216:
cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(lr.coef_))], axis = 1)
cdf.columns = ['feature', 'value']
cdf.sort_values('value')
167/217: from sklearn.linear_model import Lasso, Ridge
167/218:
from sklearn.linear_model import Lasso, 

a = 10
lasso = Lasso(alpha=a)
lasso.fit(Xtrain1, ytrain)

y_pred_l_train = lasso.predict(Xtrain1)
y_pred_l_test = lasso.predict(Xtest1)

print('alpha={}'.format(a))
print('Train MSE:', mean_squared_error(ytrain, y_pred_l_train))
print('Test MSE:', mean_squared_error(ytest, y_pred_l_test))

cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(lasso.coef_))], axis = 1)
cdf.columns = ['feature', 'value']
cdf.sort_values('value')
167/219:
from sklearn.linear_model import Lasso

a = 10
lasso = Lasso(alpha=a)
lasso.fit(Xtrain1, ytrain)

y_pred_l_train = lasso.predict(Xtrain1)
y_pred_l_test = lasso.predict(Xtest1)

print('Train MSE:', mean_squared_error(ytrain, y_pred_l_train))
print('Test MSE:', mean_squared_error(ytest, y_pred_l_test))

cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(lasso.coef_))], axis = 1)
cdf.columns = ['feature', 'value']
cdf.sort_values('value')
167/220:
from sklearn.linear_model import Lasso

a = 10
lasso = Lasso(alpha=a)
lasso.fit(Xtrain1, ytrain)

y_pred_l_train = lasso.predict(Xtrain1)
y_pred_l_test = lasso.predict(Xtest1)

cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(lasso.coef_))], axis = 1)
cdf.columns = ['feature', 'value']
cdf.sort_values('value')
167/221:
from sklearn.linear_model import Ridge

a = 10
ridge = Ridge(alpha=a)
ridge.fit(Xtrain1, ytrain)

y_pred_l_train = ridge.predict(Xtrain1)
y_pred_l_test = ridge.predict(Xtest1)

cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(ridge.coef_))], axis = 1)
cdf.columns = ['feature', 'value']
cdf.sort_values('value')
167/222:
from numpy import linalg as LA
a = np.array([[1, 2, 3], [4, 5, 6]])
167/223:
from numpy import linalg as LA
a = np.array([[1, 2, 3], [4, 5, 6]])
167/224:
from numpy import linalg
a = np.array([[1, 2, 3], [4, 5, 6]])

linalg.norm(a)
167/225:
from numpy import linalg
a = np.array([[1, 2, 3], [4, 5, 6]])

linalg.norm(a)
167/226:
from numpy import linalg
import matplotlib.pyplot as plt
% matplotlib inline

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    lasso = Lasso(alpha=a)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(X_train, y_train)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(norm_lasso)
    r_coef.append(norm_ridge)

print(l_coef)
print(r_coef)
167/227:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    lasso = Lasso(alpha=a)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(X_train, y_train)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(norm_lasso)
    r_coef.append(norm_ridge)

print(l_coef)
print(r_coef)
167/228:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    lasso = Lasso(alpha=a)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(norm_lasso)
    r_coef.append(norm_ridge)

print(l_coef)
print(r_coef)
167/229:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(norm_lasso)
    r_coef.append(norm_ridge)

print(l_coef)
print(r_coef)
167/230:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

print(l_coef)
print(r_coef)
167/231:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

print(l_coef)
print(r_coef)
167/232:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

l_coef.plot(kind='bar',color='purple')

r_coef.plot(kind='bar',color='orange')
167/233:
from numpy import linalg
from matplotlib.pyplot import *

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))
    
plots = pd.DataFrame([l_coef, r_coef], columns=['Lasso', 'Ridge'])

plots
167/234:
from numpy import linalg
from matplotlib.pyplot import *

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))
    
plots = pd.DataFrame([np.array(l_coef), np.array(r_coef)], columns=['Lasso', 'Ridge'])

plots
167/235:
from numpy import linalg
from matplotlib.pyplot import *

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

coeffs = np.array(l_coef, r_coef)
# plots = pd.DataFrame([np.array(l_coef), np.array(r_coef)], columns=['Lasso', 'Ridge'])

coeffs
167/236:
from numpy import linalg
from matplotlib.pyplot import *

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

coeffs = np.array([l_coef, r_coef])
# plots = pd.DataFrame([np.array(l_coef), np.array(r_coef)], columns=['Lasso', 'Ridge'])

coeffs
167/237:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

coeffs = np.array([l_coef, r_coef])
plt.bar(np.arange(len(coeffs)), coeffs)
plt.show()
167/238:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

coeffs = np.array([l_coef, r_coef])
X = np.arange(2)
fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
167/239:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

coeffs = np.array([l_coef, r_coef])
X = np.arange(2)
fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
plt.show()
167/240:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

coeffs = np.array([l_coef, r_coef])
X = np.arange(2)
fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
ax.bar(X + 0.00, l_coef, color = 'b', width = 0.25)
ax.bar(X + 0.25, r_coef, color = 'g', width = 0.25)
plt.show()
167/241:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

coeffs = np.array([l_coef, r_coef])
X = np.arange(2)
fig = plt.figure()
ax.bar(X + 0.00, l_coef, color = 'b', width = 0.25)
ax.bar(X + 0.25, r_coef, color = 'g', width = 0.25)
167/242:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))


X = np.arange(2)
fig = plt.figure()
ax.bar(X + 0.00, l_coef, color = 'b', width = 0.25)
# ax.bar(X + 0.25, r_coef, color = 'g', width = 0.25)
167/243:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))


X = np.arange(1)
fig = plt.figure()
ax.bar(X + 0.00, l_coef, color = 'b', width = 0.25)
# ax.bar(X + 0.25, r_coef, color = 'g', width = 0.25)
167/244:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))


X = np.arange(1)
fig = plt.figure()
ax.bar(X + 0.00, l_coef, color = 'b', width = 0.25)
# ax.bar(X + 0.25, r_coef, color = 'g', width = 0.25)
plt.show()
167/245:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

l_coef.value_counts().plot(kind='bar',color='purple')
# X = np.arange(1)
# fig = plt.figure()
# ax.bar(X + 0.00, l_coef, color = 'b', width = 0.25)
# # ax.bar(X + 0.25, r_coef, color = 'g', width = 0.25)
# plt.show()
167/246:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

np.array(l_coef).value_counts().plot(kind='bar',color='purple')
# X = np.arange(1)
# fig = plt.figure()
# ax.bar(X + 0.00, l_coef, color = 'b', width = 0.25)
# # ax.bar(X + 0.25, r_coef, color = 'g', width = 0.25)
# plt.show()
167/247:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

pd.DataFrame(l_coef).value_counts().plot(kind='bar',color='purple')
# X = np.arange(1)
# fig = plt.figure()
# ax.bar(X + 0.00, l_coef, color = 'b', width = 0.25)
# # ax.bar(X + 0.25, r_coef, color = 'g', width = 0.25)
# plt.show()
167/248:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

pd.DataFrame(l_coef).plot(kind='bar',color='purple')
# X = np.arange(1)
# fig = plt.figure()
# ax.bar(X + 0.00, l_coef, color = 'b', width = 0.25)
# # ax.bar(X + 0.25, r_coef, color = 'g', width = 0.25)
# plt.show()
167/249:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

coeffs = np.array([l_coef, r_coef])
X = np.arange(2)
fig = plt.figure()
ax.bar(X + 0.00, coeffs[0], color = 'b', width = 0.25)
ax.bar(X + 0.25, coeffs[1], color = 'g', width = 0.25)
167/250:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

coeffs = np.array([l_coef, r_coef])
X = np.arange(2)
fig = plt.figure()
fig = plt.figure()
ax = fig.add_axes([0,1])
ax.bar(X + 0.00, coeffs[0], color = 'b', width = 0.25)
ax.bar(X + 0.25, coeffs[1], color = 'g', width = 0.25)
167/251:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

coeffs = np.array(l_coef, r_coef)
X = np.arange(2)
fig = plt.figure()
fig = plt.figure()
ax = fig.add_axes([0,1])
ax.bar(X + 0.00, coeffs[0], color = 'b', width = 0.25)
ax.bar(X + 0.25, coeffs[1], color = 'g', width = 0.25)
167/252:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

coeffs = [l_coef, r_coef]
X = np.arange(2)
fig = plt.figure()
fig = plt.figure()
ax = fig.add_axes([0,1])
ax.bar(X + 0.00, coeffs[0], color = 'b', width = 0.25)
ax.bar(X + 0.25, coeffs[1], color = 'g', width = 0.25)
167/253:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

coeffs = [l_coef, r_coef]
X = np.arange(2)
fig = plt.figure()
fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
ax.bar(X + 0.00, coeffs[0], color = 'b', width = 0.25)
ax.bar(X + 0.25, coeffs[1], color = 'g', width = 0.25)
167/254:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

coeffs =[ [l_coef, r_coef]]
X = np.arange(2)
fig = plt.figure()
fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
ax.bar(X + 0.00, coeffs[0], color = 'b', width = 0.25)
ax.bar(X + 0.25, coeffs[1], color = 'g', width = 0.25)
167/255:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

coeffs = [l_coef, r_coef]
print(coeffs)
X = np.arange(2)
fig = plt.figure()
fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
ax.bar(X + 0.00, coeffs[0], color = 'b', width = 0.25)
ax.bar(X + 0.25, coeffs[1], color = 'g', width = 0.25)
167/256:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

coeffs = [l_coef, r_coef]
print(coeffs)
X = np.arange(2)
fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
ax.bar(X + 0.00, coeffs[0], color = 'b', width = 0.25)
ax.bar(X + 0.25, coeffs[1], color = 'g', width = 0.25)
167/257:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

l_coef = np.array(l_coef)
r_coef = np.array(r_coef)
coeffs = [l_coef, r_coef]
print(coeffs)
X = np.arange(5)
fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
ax.bar(X + 0.00, coeffs[0], color = 'b', width = 0.25)
ax.bar(X + 0.25, coeffs[1], color = 'g', width = 0.25)
167/258:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

l_coef = np.array(l_coef)
r_coef = np.array(r_coef)
coeffs = [l_coef, r_coef]
print(coeffs)
X = np.arange(5)
fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
ax.bar(X + 0.00, coeffs[0], color = 'b', width = 0.25)
ax.bar(X + 0.25, coeffs[1], color = 'g', width = 0.25)
ax.legend(labels=['Лассо', 'ridge'])


# Ridge агрессивнее уменьшает веса, а Лассо зануляет некоторые признаки, поэтому его используют для их отбора.
167/259:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, normalize=True, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

l_coef = np.array(l_coef)
r_coef = np.array(r_coef)
coeffs = [l_coef, r_coef]
print(coeffs)
X = np.arange(5)
fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
ax.bar(X + 0.00, coeffs[0], color = 'b', width = 0.25)
ax.bar(X + 0.25, coeffs[1], color = 'g', width = 0.25)
ax.legend(labels=['Лассо', 'Ridge'])


# Ridge агрессивнее уменьшает веса, а Лассо зануляет некоторые признаки, поэтому его используют для их отбора.
167/260:
from sklearn.linear_model import LassoCV

n_alphas = 500
alphas = np.linspace(1e-10, 5, n_alphas)

lasso_cv = LassoCV(alphas=alphas, cv=5, random_state=42)
lasso_cv.fit(Xtrain1, ytrain)

print(f'Оптимальное значениеL {lasso_cv.alpha_}')
167/261:
from sklearn.linear_model import LassoCV

n_alphas = 500
alphas = np.linspace(1e-10, 5, n_alphas)

lasso_cv = LassoCV(alphas=alphas, cv=5, random_state=42, normalize=True)
lasso_cv.fit(Xtrain1, ytrain)

print(f'Оптимальное значениеL {lasso_cv.alpha_}')
167/262:
from sklearn.linear_model import LassoCV

n_alphas = 500
alphas = np.linspace(1e-10, 5, n_alphas)

lasso_cv = LassoCV(alphas=alphas, cv=5, random_state=42, normalize=True, tol=1e-2)
lasso_cv.fit(Xtrain1, ytrain)

print(f'Оптимальное значениеL {lasso_cv.alpha_}')
167/263:
from sklearn.linear_model import LassoCV

n_alphas = 500
alphas = np.linspace(1e-10, 5, n_alphas)

lasso_cv = LassoCV(alphas=alphas, cv=5, random_state=42, tol=1e-2)
lasso_cv.fit(Xtrain1, ytrain)

print(f'Оптимальное значениеL {lasso_cv.alpha_}')
167/264:
from sklearn.linear_model import LassoCV

n_alphas = 500
alphas = np.linspace(1e-10, 5, n_alphas)

lasso_cv = LassoCV(alphas=alphas, cv=5, random_state=42, tol=1e-2)
lasso_cv.fit(Xtrain1, ytrain)

print(f'Оптимальное значение альфа {lasso_cv.alpha_}')
167/265:
from numpy import linalg
import matplotlib.pyplot as plt

l_coef = []
r_coef = []

for a in [0.1, 1, 10, 100, 200]:
    if a == 0:
        a += 0.00000001
    lasso = Lasso(alpha=a, tol=1e-2)
    ridge = Ridge(alpha=a)
    lasso.fit(Xtrain1, ytrain)
    ridge.fit(Xtrain1, ytrain)
    norm_lasso = linalg.norm(lasso.coef_)
    norm_ridge = linalg.norm(ridge.coef_)
    l_coef.append(round(norm_lasso))
    r_coef.append(round(norm_ridge))

l_coef = np.array(l_coef)
r_coef = np.array(r_coef)
coeffs = [l_coef, r_coef]
print(coeffs)
X = np.arange(5)
fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
ax.bar(X + 0.00, coeffs[0], color = 'b', width = 0.25)
ax.bar(X + 0.25, coeffs[1], color = 'g', width = 0.25)
ax.legend(labels=['Лассо', 'Ridge'])


# Ridge агрессивнее уменьшает веса, а Лассо зануляет некоторые признаки, поэтому его используют для их отбора.
167/266:
from sklearn.linear_model import LassoCV

n_alphas = 500
alphas = np.linspace(1e-10, 5, n_alphas)

lasso_cv = LassoCV(alphas=alphas, cv=5, random_state=42, tol=1e-2)
lasso_cv.fit(Xtrain1, ytrain)
print(lasso_cv.mse_path_)
print(lasso_cv.mse_path_.mean(axis=1))

print(f'Оптимальное значение альфа {lasso_cv.alpha_}')
167/267:
from sklearn.linear_model import LassoCV

n_alphas = 500
alphas = np.linspace(1e-10, 5, n_alphas)

lasso_cv = LassoCV(alphas=alphas, cv=5, random_state=42, tol=1e-2)
lasso_cv.fit(Xtrain1, ytrain)
print(lasso_cv.mse_path_)
print(lasso_cv.mse_path_.mean(axis=1))

plt.plot(model.alphas_, model.mse_path_.mean(axis =1))
plt.xlabel('alpha')
plt.ylabel('mean MSE')
plt.show(

print(f'Оптимальное значение альфа {lasso_cv.alpha_}')
167/268:
from sklearn.linear_model import LassoCV

n_alphas = 500
alphas = np.linspace(1e-10, 5, n_alphas)

lasso_cv = LassoCV(alphas=alphas, cv=5, random_state=42, tol=1e-2)
lasso_cv.fit(Xtrain1, ytrain)
print(lasso_cv.mse_path_)
print(lasso_cv.mse_path_.mean(axis=1))

plt.plot(model.alphas_, model.mse_path_.mean(axis =1))
plt.xlabel('alpha')
plt.ylabel('mean MSE')
plt.show()

print(f'Оптимальное значение альфа {lasso_cv.alpha_}')
167/269:
from sklearn.linear_model import LassoCV

n_alphas = 500
alphas = np.linspace(1e-10, 5, n_alphas)

lasso_cv = LassoCV(alphas=alphas, cv=5, random_state=42, tol=1e-2)
lasso_cv.fit(Xtrain1, ytrain)
print(lasso_cv.mse_path_)
print(lasso_cv.mse_path_.mean(axis=1))

plt.plot(lasso_cv.alphas_, lasso_cv.mse_path_.mean(axis =1))
plt.xlabel('alpha')
plt.ylabel('mean MSE')
plt.show()

print(f'Оптимальное значение альфа {lasso_cv.alpha_}')
167/270:
from sklearn.linear_model import LassoCV

n_alphas = 500
alphas = np.linspace(1e-10, 5, n_alphas)

lasso_cv = LassoCV(alphas=alphas, cv=5, random_state=42, tol=1e-2)
lasso_cv.fit(Xtrain1, ytrain)
# print(lasso_cv.mse_path_, '\n' )
print(lasso_cv.mse_path_.mean(axis=1), '\n')

# plt.plot(lasso_cv.alphas_, lasso_cv.mse_path_.mean(axis =1))
# plt.xlabel('alpha')
# plt.ylabel('mean MSE')
# plt.show()

print(f'Оптимальное значение альфа {lasso_cv.alpha_}')
167/271:
from sklearn.linear_model import LassoCV

n_alphas = 500
alphas = np.linspace(1e-10, 5, n_alphas)

lasso_cv = LassoCV(alphas=alphas, cv=5, random_state=42, tol=1e-2)
lasso_cv.fit(Xtrain1, ytrain)
# print(lasso_cv.mse_path_, '\n' )
print(lasso_cv.mse_path_.mean(axis=1), lasso_cv.alpha_ '\n')

# plt.plot(lasso_cv.alphas_, lasso_cv.mse_path_.mean(axis =1))
# plt.xlabel('alpha')
# plt.ylabel('mean MSE')
# plt.show()

print(f'Оптимальное значение альфа {lasso_cv.alpha_}')
167/272:
from sklearn.linear_model import LassoCV

n_alphas = 500
alphas = np.linspace(1e-10, 5, n_alphas)

lasso_cv = LassoCV(alphas=alphas, cv=5, random_state=42, tol=1e-2)
lasso_cv.fit(Xtrain1, ytrain)
# print(lasso_cv.mse_path_, '\n' )
print(lasso_cv.mse_path_.mean(axis=1), lasso_cv.alpha_, '\n')

# plt.plot(lasso_cv.alphas_, lasso_cv.mse_path_.mean(axis =1))
# plt.xlabel('alpha')
# plt.ylabel('mean MSE')
# plt.show()

print(f'Оптимальное значение альфа {lasso_cv.alpha_}')
167/273:
plt.plot(lasso_cv.alphas_, lasso_cv.mse_path_.mean(axis =1))
plt.xlabel('alpha')
plt.ylabel('mean MSE')
plt.show()

print(f'Оптимальное значение альфа {lasso_cv.alpha_}')
167/274:
plt.plot(lasso_cv.alphas_, lasso_cv.mse_path_.mean(axis =1))
plt.xlabel('alpha')
plt.ylabel('mse_path')
plt.show()

print(f'Оптимальное значение альфа {lasso_cv.alpha_}')
167/275:
from sklearn.linear_model import Lasso

a = 5
lasso = Lasso(alpha=a)
lasso.fit(Xtrain1, ytrain)

y_pred_l_train = lasso.predict(Xtrain1)
y_pred_l_test = lasso.predict(Xtest1)

cdf = pd.concat([pd.DataFrame(Xtrain1.columns),pd.DataFrame(np.transpose(lasso.coef_))], axis = 1)
cdf.columns = ['feature', 'value']
cdf.sort_values('value')

# Некоторые веса сильно уменьшились, например, engine. Также уменьшился num-of-cylinders, но при этом engine, horsepower и curb остались высокими
167/276:
y_pred_l_test = lasso.predict(Xtest1)

print("Test MSE linear regr: {}".format(np.sqrt(mean_squared_error(ytest, test_pred))))
print("Test MSE Lasso: {}".format(np.sqrt(mean_squared_error(ytest, y_pred_l_test))))
167/277:
np.random.seed(12345)
x = np.arange(20)
landmarks = x + np.round(np.random.normal(2, 8, 20)) # сгенерируем случайные метки
random_classes = np.random.randint(0, 4, 20)

fig, ax = plt.subplots(figsize = (10, 7))
scatter = ax.scatter(x, landmarks, c = random_classes)
ax.scatter(4, 7, c = 'r', marker = 'o', label = 'robot position')
legend1 = ax.legend(*scatter.legend_elements(),
                    loc = "lower left", title = "Classes")
ax.add_artist(legend1)

plt.plot()
_ = plt.legend()
_ = plt.grid()
167/278:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T
    print(landmarks)
    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))
    
    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)
    
    for n in range(n_movements):
        robot.move()
    
    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    
    traj = # <ВАШ КОД ЗДЕСЬ>
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/279:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T
    print(landmarks)
    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))
    
    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)
    
    for n in range(n_movements):
        robot.move()
    
    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    
#     traj = # <ВАШ КОД ЗДЕСЬ>
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/280:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T
    print(landmarks)
    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))
    
    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)
    
    for n in range(n_movements):
        robot.move()
    
    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    
#     traj = # <ВАШ КОД ЗДЕСЬ>
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/281:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T
    print(landmarks)
    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))
    
    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)
    
    for n in range(n_movements):
        robot.move()
    
    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    
#     traj = # <ВАШ КОД ЗДЕСЬ>
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/282:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/283:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T
   
    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))
     print(classes)
    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)
    
    for n in range(n_movements):
        robot.move()
    
    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    
#     traj = # <ВАШ КОД ЗДЕСЬ>
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/284:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T
   
    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))
    print(classes)
    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)
    
    for n in range(n_movements):
        robot.move()
    
    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    
#     traj = # <ВАШ КОД ЗДЕСЬ>
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/285:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/286:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T
    print(landmarks)
    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))
    print(classes)
    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)
    
    for n in range(n_movements):
        robot.move()
    
    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    
#     traj = # <ВАШ КОД ЗДЕСЬ>
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/287:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/288:
robot = MobileRobot(3, np.array([10, 20]), landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/289:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/290:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        

        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.kNN.fit(X, y) 
        self.kNN.predict(initial_position)
        new_pos = ''
        self.trajectory.append(new_pos)
        
        # <ВАШ КОД ЗДЕСЬ>
167/291: from sklearn.neighbors import KNeighborsClassifier
167/292:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        

        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.kNN.fit(X, y) 
        self.kNN.predict(initial_position)
        new_pos = ''
        self.trajectory.append(new_pos)
        
        # <ВАШ КОД ЗДЕСЬ>
167/293:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/294:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, std, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/295:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/296:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        

        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y) 
        new_pos = self.knn.predict(initial_position)
        self.trajectory.append(new_pos)
        return new_pos
        
        # <ВАШ КОД ЗДЕСЬ>
167/297:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/298:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        

        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y) 
        new_pos = self.knn.predict(self.initial_position)
        self.trajectory.append(new_pos)
        return new_pos
        
        # <ВАШ КОД ЗДЕСЬ>
167/299:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        

        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y) 
        new_pos = self.knn.predict(self.initial_position)
        self.trajectory.append(new_pos)
        return new_pos
        
        # <ВАШ КОД ЗДЕСЬ>
167/300:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/301:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        

        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y) 
        new_pos = self.knn.predict([self.initial_position])
        self.trajectory.append(new_pos)
        return new_pos
167/302:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        

        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y) 
        new_pos = self.knn.predict([self.initial_position])
        self.trajectory.append(new_pos)
        return new_pos
167/303:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/304:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        

        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y) 
        new_pos = self.knn.predict([self.initial_position])
        self.trajectory.append(new_pos)
        return new_pos
167/305:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/306:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/307:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/308:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/309:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/310:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/311:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/312:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/313:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/314:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/315:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/316:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/317:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y) 
        new_class = self.knn.predict([self.initial_position])
        new_position = self.initial_position + self.mapping[class]
        self.trajectory.append(new_position)
        return new_position
167/318:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y) 
        new_class = self.knn.predict([self.initial_position])
        new_position = self.initial_position + self.mapping[new_class]
        self.trajectory.append(new_position)
        return new_position
167/319:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/320:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y) 
        new_class = self.knn.predict([self.initial_position])
        print('self.initial_position', self.initial_position)
        print('self.mapping[new_class]', self.mapping[new_class])
#         new_position = self.initial_position + self.mapping[new_class]
#         self.trajectory.append(new_position)
#         return new_position
167/321:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/322:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y) 
        new_class = self.knn.predict([self.initial_position])
        print('self.initial_position', self.initial_position)
        print('self.mapping[new_class]', new_class[0])
#         new_position = self.initial_position + self.mapping[new_class]
#         self.trajectory.append(new_position)
#         return new_position
167/323:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/324:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y) 
        new_class = self.knn.predict([self.initial_position])
        print('self.initial_position', self.initial_position)
        print('self.mapping[new_class]', self.mapping[new_class[0]])
#         new_position = self.initial_position + self.mapping[new_class]
#         self.trajectory.append(new_position)
#         return new_position
167/325:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/326:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y) 
        new_class = self.knn.predict([self.initial_position])
        print('self.initial_position', self.initial_position)
        print('self.mapping[new_class]', self.mapping[new_class[0]])
        new_position = self.initial_position + self.mapping[new_class[0]]
#         self.trajectory.append(new_position)
        return new_position
167/327:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/328:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/329:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
167/330:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/331:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y) 
        new_class = self.knn.predict([self.initial_position])
        new_position = self.initial_position + self.mapping[new_class[0]]
        self.trajectory.append(new_position)
        print('new_position', new_position)
        return new_position
167/332:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/333:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append(self.initial_position)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        self.trajectory.append(new_position)
        print('new_position', new_position)
        return new_position
167/334:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/335:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = np.array()
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append(self.initial_position)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        self.trajectory.append(new_position)
        print('new_position', new_position)
        return new_position
167/336:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = np.array()
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append(self.initial_position)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        self.trajectory.append(new_position)
        print('new_position', new_position)
        return new_position
167/337:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/338:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = np.array([])
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append(self.initial_position)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        self.trajectory.append(new_position)
        print('new_position', new_position)
        return new_position
167/339:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/340:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = np.array([])
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            np.append(self.trajectory, self.initial_position)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        np.append(self.trajectory, new_position)
        print('new_position', new_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/341:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/342:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = np.array([])
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            np.append(self.trajectory, self.initial_position)
        print('self.trajectory 1', self.trajectory)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        np.append(self.trajectory, new_position)
        print('new_position', new_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/343:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/344:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = np.array([])
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            np.append(self.trajectory, [self.initial_position])
        print('self.trajectory 1', self.trajectory)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        np.append(self.trajectory, new_position)
        print('new_position', new_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/345:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/346:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = np.array([])
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if self.trajectory.size == 0:
            np.append(self.trajectory, [self.initial_position])
        print('self.trajectory 1', self.trajectory)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        np.append(self.trajectory, new_position)
        print('new_position', new_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/347:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/348:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = np.array([])
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        print('self.trajectory.size', self.trajectory.size)
        if self.trajectory.size == 0:
            np.append(self.trajectory, [self.initial_position])
        print('self.trajectory 1', self.trajectory)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        np.append(self.trajectory, new_position)
        print('new_position', new_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/349:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/350:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = np.array([])
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        print('self.trajectory.size', self.trajectory.size)
        if self.trajectory.size == 0:
            np.concatenate(self.trajectory, [self.initial_position])
        print('self.trajectory 1', self.trajectory)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        np.append(self.trajectory, new_position)
        print('new_position', new_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/351:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/352:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = np.array([])
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        print('self.trajectory.size', self.trajectory.size)
        if self.trajectory.size == 0:
            np.concatenate(self.trajectory, np.array(self.initial_position))
        print('self.trajectory 1', self.trajectory)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        np.append(self.trajectory, new_position)
        print('new_position', new_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/353:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/354:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = np.array([])
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        print('self.trajectory.size', self.trajectory.size)
        if self.trajectory.size == 0:
            np.concatenate((self.trajectory, np.array(self.initial_position)))
        print('self.trajectory 1', self.trajectory)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        np.append(self.trajectory, new_position)
        print('new_position', new_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/355:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/356:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = np.array([])
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        print('self.trajectory.size', self.trajectory.size)
        if self.trajectory.size == 0:
            np.append(self.trajectory, np.array(self.initial_position))
        print('self.trajectory 1', self.trajectory)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        np.append(self.trajectory, new_position)
        print('new_position', new_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/357:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/358:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = np.array([])
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        print('self.trajectory.size', self.trajectory.size)
        if self.trajectory.size == 0:
            self.trajectory = np.append(self.trajectory, self.initial_position)
        print('self.trajectory 1', self.trajectory)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        self.trajectory = np.append(self.trajectory, new_position)
        print('new_position', new_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/359:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/360:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = np.array([])
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = np.array(initial_position)
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        print('self.trajectory.size', self.trajectory.size)
        if self.trajectory.size == 0:
            self.trajectory = np.append(self.trajectory, self.initial_position)
        print('self.trajectory 1', self.trajectory)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        self.trajectory = np.append(self.trajectory, new_position)
        print('new_position', new_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/361:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/362:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = np.array(initial_position)
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        print('self.trajectory.size', self.trajectory.size)
        if self.trajectory.size == 0:
            self.trajectory.append(self.initial_position)
        print('self.trajectory 1', self.trajectory)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        sself.trajectory.append(self.initial_position)
        print('new_position', new_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/363:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/364:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = np.array(initial_position)
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        print('self.trajectory.size', self.trajectory.size)
        if len(self.trajectory) == 0:
            self.trajectory.append(self.initial_position)
        print('self.trajectory 1', self.trajectory)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        sself.trajectory.append(self.initial_position)
        print('new_position', new_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/365:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/366:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = np.array(initial_position)
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append(self.initial_position)
        print('self.trajectory 1', self.trajectory)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        sself.trajectory.append(self.initial_position)
        print('new_position', new_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/367:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/368:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        print('self.trajectory 1', self.trajectory)
        current_position = self.trajectory[-1]
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        sself.trajectory.append(self.initial_position)
        print('new_position', new_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/369:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/370:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
                print('current_position', current_position)
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        sself.trajectory.append(self.initial_position)
        print('new_position', new_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/371:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        print('current_position', current_position)
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        sself.trajectory.append(self.initial_position)
        print('new_position', new_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/372:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/373:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        print('current_position', current_position)
        new_class = self.knn.predict(current_position)
        new_position = self.current_position + self.mapping[new_class[0]]
        sself.trajectory.append(self.initial_position)
        print('current_position', current_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/374:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/375:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        print('current_position', current_position)
        new_class = self.knn.predict(current_position)
        current_position = current_position + self.mapping[new_class[0]]
        sself.trajectory.append([self.current_position])
        print('current_position', current_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/376:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/377:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        print('current_position', current_position)
        new_class = self.knn.predict(current_position)
        current_position = current_position + self.mapping[new_class[0]]
        self.trajectory.append([self.current_position])
        print('current_position', current_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/378:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/379:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        print('current_position', current_position)
        new_class = self.knn.predict(current_position)
        current_position = current_position + self.mapping[new_class[0]]
        self.trajectory.append([current_position])
        print('current_position', current_position)
        print('self.trajectory', self.trajectory)
        return new_position
167/380:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/381:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        print('current_position', current_position)
        new_class = self.knn.predict(current_position)
        current_position = current_position + self.mapping[new_class[0]]
        self.trajectory.append([current_position])
        print('current_position', current_position)
        print('self.trajectory', self.trajectory)
        return current_position
167/382:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/383:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        print('current_position', current_position)
        new_class = self.knn.predict(current_position)
        current_position = current_position + self.mapping[new_class[0]]
        self.trajectory.append(current_position)
        print('current_position', current_position)
        print('self.trajectory', self.trajectory)
        return current_position
167/384:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/385:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        n, p = 10, .2  # number of trials, probability of each trial
        s = np.random.binomial(n, p, 1000)
        print(s)
        new_class = self.knn.predict(current_position)
        current_position = current_position + self.mapping[new_class[0]]
        self.trajectory.append(current_position)

        return current_position
167/386:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/387:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        n, p = 1, .2  # number of trials, probability of each trial
        s = np.random.binomial(n, p, 1000)
        print(s)
        new_class = self.knn.predict(current_position)
        current_position = current_position + self.mapping[new_class[0]]
        self.trajectory.append(current_position)

        return current_position
167/388:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/389:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        n, p = 1, .2  # number of trials, probability of each trial
        s = np.random.binomial(n, p, 1)
        print(s)
        new_class = self.knn.predict(current_position)
        current_position = current_position + self.mapping[new_class[0]]
        self.trajectory.append(current_position)

        return current_position
167/390:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/391:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/392:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/393:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/394:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/395:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/396:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        n, p = 1, .2  # number of trials, probability of each trial
#         np.random.binomial(n,p)
        print(np.random.binomial(n,p))
        new_class = self.knn.predict(current_position)
        current_position = current_position + self.mapping[new_class[0]]
        self.trajectory.append(current_position)

        return current_position
167/397:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/398:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/399:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/400:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/401:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/402:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/403:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/404:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/405:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        n, p = 1, .2  # number of trials, probability of each trial
        new_class = '2' if np.random.binomial(n,p)==1 else self.knn.predict(current_position)
        current_position = current_position + self.mapping[new_class[0]]
        self.trajectory.append(current_position)

        return current_position
167/406:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/407:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T

    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))

    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)
    
    for n in range(n_movements):
        robot.move()
    
    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    
    traj = np.append(empty_array, np.array([[11, 21]]), axis=0)
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/408:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/409:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        n, p = 1, .2  # number of trials, probability of each trial
        new_class = '2' if np.random.binomial(n,p)==1 else self.knn.predict(current_position)
        current_position = current_position + self.mapping[new_class[0]]
        self.trajectory.append(current_position)
167/410:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T

    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))

    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)
    
    for n in range(n_movements):
        robot.move()
    
    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    
    traj = np.append(empty_array, np.array([[11, 21]]), axis=0)
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/411:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/412:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T

    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))

    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)
    
    for n in range(n_movements):
        robot.move()
    
    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    
#     traj = np.append(empty_array, np.array([[11, 21]]), axis=0)
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/413:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T

    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))

    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)
    
#     for n in range(n_movements):
#         robot.move()
    
    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    
#     traj = np.append(empty_array, np.array([[11, 21]]), axis=0)
#     ax.plot(traj[:, 0], traj[:, 1], 
#                c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/414:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/415:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        n, p = 1, .2  # number of trials, probability of each trial
        new_class = '2' if np.random.binomial(n,p)==1 else self.knn.predict(current_position)
        current_position = current_position + self.mapping[new_class[0]]
        self.trajectory.append(current_position)
        return current_position
167/416:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T

    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))

    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)
    moves = [initial_position]

    for n in range(n_movements):
        pos = robot.move()
        moves.append(moves)
    print(moves)
    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    
#     traj = np.append(empty_array, np.array([[11, 21]]), axis=0)
#     ax.plot(traj[:, 0], traj[:, 1], 
#                c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/417:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/418:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        n, p = 1, .2  # number of trials, probability of each trial
        new_class = '2' if np.random.binomial(n,p)==1 else self.knn.predict(current_position)
        current_position = current_position + self.mapping[new_class[0]]
        print('current_position', current_position)
        self.trajectory.append(current_position)
167/419:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/420:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/421:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/422:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/423:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/424:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/425:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/426:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        n, p = 1, .2  # number of trials, probability of each trial
        new_class = '2' if np.random.binomial(n,p)==1 else self.knn.predict(current_position)[0]
        current_position = current_position + self.mapping[new_class]
        print('current_position', current_position)
        self.trajectory.append(current_position)
167/427:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        n, p = 1, .2  # number of trials, probability of each trial
        new_class = '2' if np.random.binomial(n,p)==1 else self.knn.predict(current_position)[0]
        current_position = current_position + self.mapping[new_class]
        print('current_position', current_position)
        self.trajectory.append(current_position)
167/428:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/429:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/430:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/431:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/432:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/433:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/434:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/435:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/436:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/437:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/438:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/439:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/440:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/441:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/442:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/443:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        n, p = 1, .2  # number of trials, probability of each trial
        new_class = '2' if np.random.binomial(n,p)==1 else self.knn.predict(current_position)[0]
        print('new_class', new_class)
        current_position = current_position + self.mapping[new_class]
        print('current_position', current_position)
        self.trajectory.append(current_position)
167/444:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/445:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/446:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/447:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/448:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/449:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/450:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/451:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/452:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        n, p = 1, .2  # number of trials, probability of each trial
        new_class = 2 if np.random.binomial(n,p)==1 else self.knn.predict(current_position)[0]
        print('new_class', new_class)
        current_position = current_position + self.mapping[new_class]
        print('current_position', current_position)
        self.trajectory.append(current_position)
167/453:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/454:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/455:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/456:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/457:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/458:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/459:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/460:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append([self.initial_position])
        current_position = self.trajectory[-1]
        n, p = 1, .2  # number of trials, probability of each trial
        new_class = 2 if np.random.binomial(n,p)==1 else self.knn.predict(current_position)[0]
        current_position = current_position + self.mapping[new_class]
        self.trajectory.append(current_position)
167/461:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T

    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))

    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)

    for n in range(n_movements):
        robot.move()

    print(moves)
    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    print(robot.trajectory)
#     traj = np.append(empty_array, np.array([[11, 21]]), axis=0)
#     ax.plot(traj[:, 0], traj[:, 1], 
#                c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/462:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/463:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T

    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))

    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)

    for n in range(n_movements):
        robot.move()

    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    print(robot.trajectory)
#     traj = np.append(empty_array, np.array([[11, 21]]), axis=0)
#     ax.plot(traj[:, 0], traj[:, 1], 
#                c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/464:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/465:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T

    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))

    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)

    for n in range(n_movements):
        robot.move()

    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    print(robot.trajectory)
    traj = np.append(robot.trajectory, axis=0)
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/466:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/467:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append(self.initial_position)
        current_position = self.trajectory[-1]
        n, p = 1, .2  # number of trials, probability of each trial
        new_class = 2 if np.random.binomial(n,p)==1 else self.knn.predict(current_position)[0]
        current_position = current_position + self.mapping[new_class]
        self.trajectory.append(current_position)
167/468:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/469:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T

    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))

    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)

    for n in range(n_movements):
        robot.move()

    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    print(robot.trajectory)
    traj = np.append(robot.trajectory, axis=0)
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/470:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/471:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append(np.reshape(self.initial_position, (-1, 2)))
        current_position = self.trajectory[-1]
        n, p = 1, .2  # number of trials, probability of each trial
        new_class = 2 if np.random.binomial(n,p)==1 else self.knn.predict(current_position)[0]
        current_position = current_position + self.mapping[new_class]
        self.trajectory.append(current_position)
167/472:
robot = MobileRobot(3, np.array([10, 20]), np.vstack((x, x + np.round(np.random.normal(0, 2, len(x))))).T,
                    np.random.randint(0, 4, size = len(x)))
robot.move()
robot.move()
167/473:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T

    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))

    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)

    for n in range(n_movements):
        robot.move()

    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    print(robot.trajectory)
    traj = np.append(robot.trajectory, axis=0)
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/474:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/475:
# x = np.arange(30)
# conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
robot.trajectory
167/476:
# x = np.arange(30)
# conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
robot.trajectory
167/477:
# x = np.arange(30)
# conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
robot.trajectory
167/478:
# x = np.arange(30)
# conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
 new = np.reshape(robot.trajectory, (-1, ncols))
167/479:
# x = np.arange(30)
# conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
np.reshape(robot.trajectory, (-1, ncols))
167/480:
# x = np.arange(30)
# conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
np.reshape(robot.trajectory, (-1, 2))
167/481:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T

    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))

    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)

    for n in range(n_movements):
        robot.move()

    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    print(robot.trajectory)
    new = np.reshape(a, (-1, ncols))

    traj = np.reshape(robot.trajectory, (-1, 2))
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/482:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/483:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T

    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))

    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)

    for n in range(n_movements):
        robot.move()

    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    print(robot.trajectory)

    traj = np.reshape(robot.trajectory, (-1, 2))
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/484:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/485:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T

    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))

    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)

    for n in range(n_movements):
        robot.move()

    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)

    traj = np.reshape(robot.trajectory, (-1, 2))
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/486:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/487:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/488:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/489:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append(np.reshape(self.initial_position, (-1, 2)))
        current_position = self.trajectory[-1]
        n, p = 1, .8  # number of trials, probability of each trial
        new_class = 2 if np.random.binomial(n,p)==1 else self.knn.predict(current_position)[0]
        current_position = current_position + self.mapping[new_class]
        self.trajectory.append(current_position)
167/490:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T

    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))

    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)

    for n in range(n_movements):
        robot.move()

    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)

    traj = np.reshape(robot.trajectory, (-1, 2))
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/491:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/492:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/493:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/494:
class MobileRobot():
    
    def __init__(self, k, initial_position, landmarks, classes):
        '''
        Attributes:
        ------
        k: int
            Number of neighbours
            
        initial_position: ndarray
            Initial position of the robot as a point, e.g. (-1, 1)
            
        landmarks: ndarray
            numpy array of shape (n_landmarks, 2) with the euclidean positions of points
        
        classes: ndarray
            numpy array of shape (n_landmarks, ) with class of landmark for each point in landmarks
        
        '''
        # Store the history of movements
        self.trajectory = []
        self.k = k
        self.landmarks = landmarks
        self.classes = classes
        self.initial_position = initial_position
        
        # kNN Classifier for determining the classes of landmarks
        self.knn = KNeighborsClassifier(n_neighbors=k)
        
        # Mapping between classes of points and movements
        self.mapping = {0: np.array([1, 0]), 
                        1: np.array([-1, 0]),
                        2: np.array([0, 1]),
                        3: np.array([0, -1])}
        
    def move(self):
        X = self.landmarks
        y = self.classes
        self.knn.fit(X, y)
        if len(self.trajectory) == 0:
            self.trajectory.append(np.reshape(self.initial_position, (-1, 2)))
        current_position = self.trajectory[-1]
        n, p = 1, .2  # number of trials, probability of each trial
        new_class = 2 if np.random.binomial(n,p)==1 else self.knn.predict(current_position)[0]
        current_position = current_position + self.mapping[new_class]
        self.trajectory.append(current_position)
167/495:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T

    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))

    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)

    for n in range(n_movements):
        robot.move()

    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    print(robot.trajectory)
    traj = np.reshape(robot.trajectory, (-1, 2))
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/496:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/497: conduct_experiment(x, mean = 3, std = 10, k = 10, n_movements = 50)
167/498: conduct_experiment(x, mean = 3, std = 10, k = 1, n_movements = 50)
167/499: conduct_experiment(x, mean = 3, std = 10, k = 3, n_movements = 50)
167/500: conduct_experiment(x, mean = 3, std = 10, k = 20, n_movements = 50)
167/501:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/502:
def conduct_experiment(x,
                       mean = 0,
                       std = 2, 
                       n_movements = 10, 
                       k = 3, 
                       initial_position = np.array([10, 20])):
    
    np.random.seed(12345)
    # Generate random landmarks
    landmarks = np.vstack((x, x + np.round(np.random.normal(mean, std, len(x))))).T

    # Generate random classes of landmarks
    classes = np.random.randint(0, 4, size = len(x))

    # Conduct experiment
    robot = MobileRobot(k, initial_position, landmarks, classes)

    for n in range(n_movements):
        robot.move()

    fig, ax = plt.subplots(figsize = (10, 8))
    scatter = ax.scatter(landmarks[:, 0], landmarks[:, 1], c = classes)
    legend1 = ax.legend(*scatter.legend_elements(),
                        loc="lower left", title="classes")
    ax.add_artist(legend1)
    traj = np.reshape(robot.trajectory, (-1, 2))
    ax.plot(traj[:, 0], traj[:, 1], 
               c = 'r', marker = 'o', label = 'robot position')

    plt.plot()
    _ = plt.legend()
    _ = plt.grid()
167/503:
x = np.arange(30)
conduct_experiment(x, mean = 3, std = 10, k = 5, n_movements = 50)
167/504: conduct_experiment(x, mean = 3, std = 10, k = 10, n_movements = 50)
167/505: conduct_experiment(x, mean = 3, std = 10, k = 1, n_movements = 50)
167/506: conduct_experiment(x, mean = 3, std = 10, k = 3, n_movements = 50)
167/507: conduct_experiment(x, mean = 3, std = 10, k = 20, n_movements = 50)
170/1:
import numpy as np
import pandas as pd

from scipy import stats

import seaborn as sns
import matplotlib.pyplot as plt

plt.style.use('ggplot')
170/2:
# воспользуемся формулой
# Если {\displaystyle a=k\sigma }a=k\sigma , где {\displaystyle \sigma }\sigma  — стандартное отклонение и {\displaystyle k>0}k>0, то получаем

{\displaystyle \mathbb {P} \left(|X-\mu |\geqslant k\sigma \right)\leqslant {\frac {1}{k^{2}}}}{\mathbb  {P}}\left(|X-\mu |\geqslant k\sigma \right)\leqslant {\frac  {1}{k^{2}}}.
170/3:
# воспользуемся формулой для a=k\sigma
#
170/4:
# воспользуемся формулой для a=k\sigma
#
170/5: воспользуемся формулой для a=k\sigma
170/6:
# n1) для норм распределения
norm_rv = stats.norm(loc=0, scale=1)
170/7:
# n1) для норм распределения
norm_rv = stats.norm(loc=0, scale=1)
170/8:
# n1) для норм распределения
norm_rv = stats.norm(loc=0, scale=1)

for i in [2,3]:
    print(f'P({-i} < X < {i}) = Ф({i})-Ф({-i}) = ', norm_rv.cdf(xi)-norm_rv.cdf(-i) )
170/9:
# n1) для норм распределения
norm_rv = stats.norm(loc=0, scale=1)

for i in [2,3]:
    print(f'P({-i} < X < {i}) = Ф({i})-Ф({-i}) = ', norm_rv.cdf(i)-norm_rv.cdf(-i) )
170/10:
# n1) для норм распределения
norm_rv = stats.norm(loc=0, scale=1)

for i in [2,3]:
    print(f'P({-i} < X < {i}) = Ф({i})-Ф({-i}) = ', norm_rv.cdf(i)-norm_rv.cdf(-i) )
170/11:
# n1) для норм распределения
norm_rv = stats.norm(loc=0, scale=1)

for i in [2,3]:
    print(f'P({-i} < X < {i}) = Ф({i})-Ф({-i}) = ', norm_rv.cdf(i)-norm_rv.cdf(-i) )
170/12:
# n1) для норм распределения
norm_rv = stats.norm(loc=0, scale=1)

for i in [2,3]:
    print(f'P({-i} < X < {i}) = Ф({i})-Ф({-i}) = ', norm_rv.cdf(i)-norm_rv.cdf(-i) )
    
# В нормальном распределении лежат 95% и 99% значений в пределах 2 и 3 сигм соответственно, то есть почти все значения. Все значения более 3 сигм можно считать выбросами
# Для произвольной случайной величины процент ее значений составляет 75% и 88%, что значительно меньше, чем для нормального распределения
170/13:
dice = np.arange(1,7)
dice
170/14:
np.seed(1)
dice = np.rand(3)
dice
170/15:
np.random.seed(1)
dice = np.random.rand(3)
dice
170/16:
np.random.seed(1)
dice = np.random.randit(10, 20, 1)
dice
170/17:
np.random.seed(1)
dice = np.random.randint(10, 20, 1)
dice
170/18:
np.random.seed(1)
dice = np.random.randint(10, 20, 1)[0]
dice
170/19:
np.random.seed(1)
dice = np.random.randint(10, 20, 1)[0]
dice
170/20:
np.random.seed(1)
dice = np.random.randint(10, 20, 1)[0]
dice
170/21:
np.random.seed(1)
dice = np.random.randint(10, 20, 1)[0]
dice
170/22:
np.random.seed(2)
dice = np.random.randint(10, 20, 1)[0]
dice
170/23:
np.random.seed(2)
dice = np.random.randint(10, 20, 1)[0]
dice
170/24:
np.random.seed(2)
dice = np.random.randint(10, 20, 1)[0]
dice
170/25:
np.random.seed(2)
t = np.random.randint(10, 20, 1)[0]
t
170/26:
df = pd.read_csv('../data/youtube_data.csv', sep='\t')
cols = ['likeCount', 'commentCount']
df = df[cols].dropna()
df = df.query('likeCount<1e6 and commentCount<100e3')
170/27:
df = pd.read_csv('./data/youtube_data.csv', sep='\t')
cols = ['likeCount', 'commentCount']
df = df[cols].dropna()
df = df.query('likeCount<1e6 and commentCount<100e3')
170/28: sns.scatterplot(data=df, x='likeCount',y='commentCount', );
170/29:
np.random.seed(2)
t = stat.uniform(10, 10).rvs(5)
t
170/30:
import numpy as np
import pandas as pd

from scipy import stats

import seaborn as sns
import matplotlib.pyplot as plt

plt.style.use('ggplot')
170/31:
np.random.seed(2)
t = stats.uniform(10, 10).rvs(5)
t
170/32:
np.random.seed(2)
t = stats.uniform(10, 10).rvs(1)
t
170/33:
np.random.seed(2)
t = stats.uniform(10, 10).rvs(1)
t
170/34:
np.random.seed(2)
t = stats.uniform(10, 10).rvs(1)
t
170/35:
np.random.seed(2)
t = stats.uniform(10, 10).rvs(1)
t
170/36:
# np.random.seed(2)
t = stats.uniform(10, 10).rvs(1)
t
170/37:
# np.random.seed(2)
t = stats.uniform(10, 10).rvs(1)
t
170/38:
# np.random.seed(2)
t = stats.uniform(10, 10).rvs(1)
t
170/39:
# np.random.seed(2)
t = stats.uniform(10, 10).rvs(1)
t
170/40:
# np.random.seed(2)
t = stats.uniform(10, 10).rvs(1)
t
170/41:
# np.random.seed(2)
t = stats.uniform(10, 10).rvs(1)
t
170/42:
# np.random.seed(2)
t = stats.uniform(10, 10).rvs(1)
t
170/43:
# np.random.seed(2)
t = stats.uniform(10, 10).rvs(1)
t
170/44:
# np.random.seed(2)
t = stats.uniform(10, 10).rvs(1)
t
170/45:
np.random.seed(2)
t = stats.uniform(10, 10).rvs(1)
t
170/46:
np.random.seed(2)
t = stats.uniform(10, 10).rvs(1)
t
170/47:
np.random.seed(2)
t = stats.uniform(10, 10).rvs(1)
t
170/48:
t = stats.uniform(10, 10).rvs(1, random_state=111)
t
170/49:
t = stats.uniform(10, 10).rvs(1, random_state=10)
t
170/50:
t = stats.uniform(10, 10).rvs(1, random_state=10)
t
170/51:
t = stats.uniform(10, 10).rvs(1, random_state=10)
t
170/52:
t = stats.uniform(10, 10).rvs(1, random_state=10)
t
170/53:
t = stats.uniform(10, 10).rvs(1, random_state=10)
t
170/54:
uniform_rv = stats.uniform(10, 10)
t = uniform_rv.rvs(1, random_state=10)
t
170/55:
n = 100
M = 1000
sample = uniform_rv.rvs(n)
170/56:
n = 100
M = 1000
sample = uniform_rv.rvs(n)
sample.shape
170/57:
n = 100
M = 1000
sample = uniform_rv.rvs(n)
sample[:10]
170/58:
n = 100
M = 1000
# sample = uniform_rv.rvs(n)
samples = [uniform_rv.rvs(n) for i in range(M)]
samples
170/59:
n = 100
M = 1000
# sample = uniform_rv.rvs(n)
samples = [uniform_rv.rvs(n) for i in range(M)]
samples.shape
170/60:
n = 100
M = 1000
# sample = uniform_rv.rvs(n)
samples = [uniform_rv.rvs(n) for i in range(M)]
samples.size
170/61:
n = 100
M = 1000
# sample = uniform_rv.rvs(n)
samples = [uniform_rv.rvs(n) for i in range(M)]
samples.shape()
170/62:
n = 100
M = 1000
# sample = uniform_rv.rvs(n)
samples = [uniform_rv.rvs(n) for i in range(M)]
samples.len
170/63:
n = 100
M = 1000
# sample = uniform_rv.rvs(n)
samples = [uniform_rv.rvs(n) for i in range(M)]
samples.len()
170/64:
n = 100
M = 1000
# sample = uniform_rv.rvs(n)
samples = [uniform_rv.rvs(n) for i in range(M)]
len(samples)
170/65:
n = 100
M = 1000
samples = uniform_rv.rvs(size = (n, M))
samples.shape
170/66:
theta1 = 2* np.mean(samples, axis = 0)
theta2 = (n_obs + 1)/n_obs*np.max(samples, axis=0)
170/67:
theta1 = 2* np.mean(samples, axis = 0)
theta2 = (n + 1)/n*np.max(samples, axis=0)
170/68:
plt.figure(figsize=(12,6))

plt.hist(theta_1, bins=100, alpha=0.5, label='Moment method')
plt.hist(theta_2, bins=50, alpha=0.5, label='ML method')
plt.legend();
170/69:
plt.figure(figsize=(12,6))

plt.hist(theta1, bins=100, alpha=0.5, label='Moment method')
plt.hist(theta2, bins=50, alpha=0.5, label='ML method')
plt.legend();
170/70:
plt.figure(figsize=(12,6))

plt.hist(theta1, bins=50, alpha=0.5, label='Moment method')
plt.hist(theta2, bins=50, alpha=0.5, label='ML method')
plt.legend();
170/71:
plt.figure(figsize=(12,6))

plt.hist(theta1, alpha=0.5, label='Moment method')
plt.hist(theta2, alpha=0.5, label='ML method')
plt.legend();
170/72:
# mm
theta1 = 2* np.mean(samples, axis = 0)
# ml
theta2 = (n + 1)/n*np.max(samples, axis=0)
170/73: theta1.mean(), theta2.mean()
170/74:
# mm
theta1 = 2* np.mean(samples, axis = 0)
# ml
theta2 = np.max(samples, axis=0)
170/75: theta1.mean(), theta2.mean()
170/76: theta1.mean(), theta2.mean()
170/77: theta1.mean(), theta2.mean()
170/78:
# mm
theta1 = 2*np.mean(samples, axis = 0)
# ml
theta2 = np.max(samples, axis=0)
170/79:
# mm
theta1 = 2*np.mean(samples, axis = 0)
# ml
theta2 = np.max(samples, axis=0)
170/80:
# mm
theta1 = 2*np.mean(samples, axis = 0)
# ml
theta2 = np.max(samples, axis=0)
170/81:
# mm
theta1 = 2*np.mean(samples, axis = 0)
# ml
theta2 = np.max(samples, axis=0)
170/82:
# mm
theta1 = 2*np.mean(samples, axis = 0)
# ml
theta2 = np.max(samples, axis=0)
170/83:
n = 100
M = 1000
samples = uniform_rv.rvs(size = (n, M))
samples.shape
170/84:
# mm
theta1 = 2*np.mean(samples, axis = 0)
# ml
theta2 = np.max(samples, axis=0)
170/85: np.mean(samples, axis = 0)
170/86: np.mean(samples, axis = 0).shape
170/87:
# mm
theta1 = 2*np.mean(samples, axis=0)

# ml
theta2 = (n + 1)/n*np.max(samples, axis=0)
170/88: theta1.mean(), theta2.mean()
170/89:
plt.figure(figsize=(12,6))

plt.hist(theta1, alpha=0.5, label='Moment method')
plt.hist(theta2, b alpha=0.5, label='ML method')
plt.legend();
170/90:
plt.figure(figsize=(12,6))

plt.hist(theta1, alpha=0.5, label='Moment method')
plt.hist(theta2, alpha=0.5, label='ML method')
plt.legend();
171/1:
import numpy as np
import pandas as pd

from scipy import stats
import matplotlib.pyplot as plt
import seaborn as sns

plt.style.use('ggplot')  # стиль для графиков
%matplotlib inline
171/2:
norm_rv = stats.norm(loc=300, scale=100)

# вся генеральная совокупность 
x_mamont = norm_rv.rvs(size = 10**4)

np.mean(x_mamont) # настоящее среднее
171/3:
# Команда нам не подходит, так как она всю матрицу сделает без повторений
# np.random.choice(x_mamont, size=(n,m), replace=False)

n = 100
number_of_samples = 200

th_od = np.zeros(number_of_samples)
th_pe = np.zeros(number_of_samples)
th_ap = np.zeros(number_of_samples)

for i in range(number_of_samples):
    x_sample = np.random.choice(x_mamont, size=n, replace=False)
    x_mean = np.mean(x_sample)
    th_od[i] = x_mean
    th_pe[i] = x_mean - 4200/n
    th_ap[i] = x_mean - 5*(n+1)/n
171/4: th_od.shape
171/5:
# посмотрим на оценки E(\hat \theta)
np.mean(th_od), np.mean(th_pe), np.mean(th_ap)
171/6:
plt.figure(figsize=(12,6))

df = pd.DataFrame(zip(th_od, th_pe, th_ap), columns = ['Одэхингум', 'Пэпина', 'Апониви'])
sns.boxplot(data = df,);
171/7:
norm_rv = stats.norm(loc=300, scale=100)

# вся генеральная совокупность 
x_mamont = norm_rv.rvs(size = 10**6)

theta_real = np.mean(x_mamont) # настоящее среднее
theta_real
171/8:
theta_hat = np.zeros((100, 50))

for n in range(100, 10100, 100): # поднимаемся выше и видим больше мамонтов
    
    # 50 выборок с повторениями для простоты 
    x_sample = np.random.choice(x_mamont, size = (n, 50), replace=False)
    
    # 50 разных оценок 
    x_mean = np.mean(x_sample, axis=0) 
    
    theta_hat[n//100 - 1] = x_mean                # состоятельная, несмещенная
    #theta_hat[n//100 - 1] = (x_mean - 4200/n)     # состоятельная, несмещенная ассимптотические
    #theta_hat[n//100 - 1] = (x_mean - 5*(n+1)/n)   # несостоятельная
171/9: theta_hat.shape
171/10:
plt.figure(figsize=(14,8))
plt.plot(range(100, 10100, 100), theta_hat, c='grey', alpha = 0.3)

plt.xlabel('Количество наблюдений', size=24)
plt.ylabel('Оценка параметра', size=24)

plt.hlines(theta_real, 0, 100, color='blue', lw=4, label='реальное значение')
plt.legend(fontsize=20);
171/11: uniform_rv = stats.uniform(0, 5)
171/12:
n_obs = 100

# 1000 выборок размера n_obs
x = uniform_rv.rvs(size = (n_obs, 1000))
x.shape
171/13:
# первая оценка 
theta_1 = 2*np.mean(x, axis=0)

# вторая оценка 
theta_2 = (n_obs + 1)/n_obs*np.max(x, axis=0)
171/14: theta_1.mean(), theta_2.mean()
171/15:
plt.figure(figsize=(12,6))
plt.hist(theta_1, bins=100, alpha=0.5, label='Moment method')
plt.hist(theta_2, bins=50, alpha=0.5, label='ML method')
plt.legend();
171/16: np.var(theta_1)
171/17: np.var(theta_2)
171/18: np.mean(x, axis=0)
171/19: uniform_rv = stats.uniform(10, 10)
171/20:
n_obs = 100

# 1000 выборок размера n_obs
x = uniform_rv.rvs(size = (n_obs, 1000))
x.shape
171/21: np.mean(x, axis=0)
171/22:
# первая оценка 
theta_1 = 2*np.mean(x, axis=0)

# вторая оценка 
theta_2 = (n_obs + 1)/n_obs*np.max(x, axis=0)
171/23: theta_1.mean(), theta_2.mean()
171/24:
plt.figure(figsize=(12,6))
plt.hist(theta_1, bins=100, alpha=0.5, label='Moment method')
plt.hist(theta_2, bins=50, alpha=0.5, label='ML method')
plt.legend();
170/91:
theta = 17
uniform_rv = stats.uniform(10, theta)
170/92:
n = 100
M = 1000
samples = uniform_rv.rvs(size = (n, M))
samples.shape
170/93:
# mm
theta1 = 2*np.mean(samples, axis=0)

# ml
theta2 = (n + 1)/n*np.max(samples, axis=0)
170/94: theta1.mean(), theta2.mean()
170/95:
plt.figure(figsize=(12,6))

plt.hist(theta1, alpha=0.5, label='Moment method')
plt.hist(theta2, alpha=0.5, label='ML method')
plt.legend();
170/96:
theta = 17
uniform_rv = stats.uniform(0, theta)
170/97:
n = 100
M = 1000
samples = uniform_rv.rvs(size = (n, M))
samples.shape
170/98:
# mm
theta1 = 2*np.mean(samples, axis=0)

# ml
theta2 = (n + 1)/n*np.max(samples, axis=0)
170/99:
theta = stats.uniform(1, random_state=10)
uniform_rv = stats.uniform(10, theta)
theta
170/100:
theta = stats.uniform(1, random_state=10)[0]
uniform_rv = stats.uniform(10, theta)
theta
170/101:
theta = stats.uniform.rvc(1, random_state=10)[0]
uniform_rv = stats.uniform(10, theta)
theta
170/102:
theta = stats.uniform.rvs(1, random_state=10)
uniform_rv = stats.uniform(10, theta)
theta
170/103:
theta = stats.uniform.rvs(20, random_state=10)
uniform_rv = stats.uniform(10, theta)
theta
170/104:
theta = stats.uniform.rvs(20, random_state=10)
uniform_rv = stats.uniform(10, theta)
theta
170/105:
theta = stats.uniform.rvs(20, random_state=10)
uniform_rv = stats.uniform(10, theta)
theta
170/106:
theta = stats.uniform.rvs(10, random_state=10)
uniform_rv = stats.uniform(10, theta)
theta
170/107:
theta = stats.uniform.rvs(10, random_state=10)
uniform_rv = stats.uniform(10, theta)
theta
170/108:
theta = stats.uniform.rvs(17, random_state=10)
uniform_rv = stats.uniform(10, theta)
theta
170/109:
theta = stats.uniform.rvs(17, random_state=10)
uniform_rv = stats.uniform(0, theta)
theta
170/110:
n = 100
M = 1000
samples = uniform_rv.rvs(size = (n, M))
samples.shape
170/111:
# mm
theta1 = 2*np.mean(samples, axis=0)

# ml
theta2 = (n + 1)/n*np.max(samples, axis=0)
170/112: theta1.mean(), theta2.mean()
170/113:
plt.figure(figsize=(12,6))

plt.hist(theta1, alpha=0.5, label='Moment method')
plt.hist(theta2, alpha=0.5, label='ML method')
plt.legend();
170/114: theta1
170/115:
# mm
MSE1 = np.mean(theta1 - theta)

# ml
MSE2 =
170/116:
# mm
MSE1 = np.mean(theta1 - theta)
MSE1
# ml
# MSE2 =
170/117: MSE = theta1^2/300
170/118: MSE = np.power(theta1, 2)/300
170/119:
MSE = np.power(theta1, 2)/300
MSE
170/120:
# mm
MSE1 = np.mean(theta1 - theta)
MSE1
# ml
# MSE2 =
170/121:
MSE = np.power(theta, 2)/300
MSE
170/122:
# mm
MSE1 = np.mean(np.power(theta1 - theta), 2)
MSE1
# ml
# MSE2 =
170/123:
# mm
MSE1 = np.mean(np.power(theta1 - theta), 2)
MSE1
# ml
# MSE2 =
170/124:
MSE =theta1 - theta
MSE
170/125:
# mm
MSE1 = np.mean(np.power(theta1 - theta), 2)
MSE1
# ml
# MSE2 =
170/126:
MSE =theta1 - theta
np.power(MSE, 2)
170/127:
# mm
delta1 = theta1 - theta
MSE1 = np.mean(np.power(delta1), 2)
MSE1
# ml
# MSE2 =
170/128:
# mm
delta1 = theta1 - theta
MSE1 = np.mean(np.power(delta1, 2))
MSE1
# ml
# MSE2 =
170/129:
# mm
delta1 = theta1 - theta
MSE1 = np.mean(np.power(delta1, 2))
print(MSE1)
# ml
delta2 = theta2 - theta
MSE2 = np.mean(np.power(delta2, 2))
print(MSE2)
172/1:
theta = stats.uniform.rvs(17, random_state=10)
uniform_rv = stats.uniform(0, theta)
theta
172/2: # Правило 3 сигм
172/3:
import numpy as np
import pandas as pd

from scipy import stats

import seaborn as sns
import matplotlib.pyplot as plt

plt.style.use('ggplot')
172/4:
# n1) для норм распределения
norm_rv = stats.norm(loc=0, scale=1)

for i in [2,3]:
    print(f'P({-i} < X < {i}) = Ф({i})-Ф({-i}) = ', norm_rv.cdf(i)-norm_rv.cdf(-i) )
    
# В нормальном распределении лежат 95% и 99% значений в пределах 2 и 3 сигм соответственно, то есть почти все значения. Все значения более 3 сигм можно считать выбросами
# Для произвольной случайной величины процент ее значений составляет 75% и 88%, что значительно меньше, чем для нормального распределения
172/5:
theta = stats.uniform.rvs(17, random_state=10)
uniform_rv = stats.uniform(0, theta)
theta
172/6:
n = 100
M = 1000
samples = uniform_rv.rvs(size = (n, M))
samples.shape
172/7:
# mm
theta1 = 2*np.mean(samples, axis=0)

# ml
theta2 = (n + 1)/n*np.max(samples, axis=0)
172/8: theta1.mean(), theta2.mean()
172/9:
plt.figure(figsize=(12,6))

plt.hist(theta1, alpha=0.5, label='Moment method')
plt.hist(theta2, alpha=0.5, label='ML method')
plt.legend();
172/10:
# mm
delta1 = theta1 - theta
MSE1 = np.mean(np.power(delta1, 2))
print(MSE1)
# ml
delta2 = theta2 - theta
MSE2 = np.mean(np.power(delta2, 2))
print(MSE2)

#  у оценки максимального правдоподобия разброс оказался меньше
172/11:
theta = stats.uniform.rvs(17, random_state=10)
uniform_rv = stats.uniform(0, theta)
theta
172/12:
theta = stats.uniform.rvs(10, random_state=10)
uniform_rv = stats.uniform(0, theta)
theta
172/13:
n = 50
samples = uniform_rv.rvs(т)
samples.shape
172/14:
n = 50
samples = uniform_rv.rvs(n)
samples.shape
172/15:
n = 50
sample = uniform_rv.rvs(n)
sample.shape
172/16:
theta = stats.uniform.rvs(10, random_state=10)
uniform_rv = stats.uniform(0, theta)
theta
172/17:
theta = stats.uniform.rvs(10, random_state=16)
uniform_rv = stats.uniform(0, theta)
theta
172/18:
theta = stats.uniform.rvs(10, random_state=16)
uniform_rv = stats.uniform(0, theta)
theta
172/19:
theta = stats.uniform.rvs(10, 10, random_state=16)
uniform_rv = stats.uniform(0, theta)
theta
172/20:
theta = stats.uniform.rvs(10, 10, random_state=16)
uniform_rv = stats.uniform(0, theta)
theta
172/21:
theta = stats.uniform.rvs(10, 10, random_state=16)
uniform_rv = stats.uniform(0, theta)
theta
172/22:
theta = stats.uniform.rvs(10, 10, random_state=18)
uniform_rv = stats.uniform(0, theta)
theta
172/23:
theta = stats.uniform.rvs(10, 10, random_state=18)
uniform_rv = stats.uniform(0, theta)
theta
172/24:
theta = stats.uniform.rvs(10, 10)
uniform_rv = stats.uniform(0, theta)
theta
172/25:
theta = stats.uniform.rvs(10, 10)
uniform_rv = stats.uniform(0, theta)
theta
172/26:
theta = stats.uniform.rvs(10, 10)
uniform_rv = stats.uniform(0, theta)
theta
172/27:
theta = stats.uniform.rvs(10, 10)
uniform_rv = stats.uniform(0, theta)
theta
172/28:
theta = stats.uniform.rvs(10, 10)
uniform_rv = stats.uniform(0, theta)
theta
172/29:
theta = stats.uniform.rvs(10, 10)
uniform_rv = stats.uniform(0, theta)
theta
172/30:
theta = stats.uniform.rvs(10, 10, random_state=16)
uniform_rv = stats.uniform(0, theta)
theta
172/31:
theta = stats.uniform.rvs(10, 10, random_state=16)
uniform_rv = stats.uniform(0, theta)
theta
172/32:
theta = stats.uniform.rvs(10, 10, random_state=16)
uniform_rv = stats.uniform(0, theta)
theta
172/33:
theta = stats.uniform.rvs(10, 10, random_state=100)
uniform_rv = stats.uniform(0, theta)
theta
172/34:
theta = stats.uniform.rvs(17, 10, random_state=10)
uniform_rv = stats.uniform(0, theta)
theta
172/35:
theta = stats.uniform.rvs(10, 10, random_state=10)
uniform_rv = stats.uniform(0, theta)
theta
172/36:
n = 100
M = 1000
samples = uniform_rv.rvs(size = (n, M))
samples.shape
172/37:
# mm
theta1 = 2*np.mean(samples, axis=0)

# ml
theta2 = (n + 1)/n*np.max(samples, axis=0)
172/38: theta1.mean(), theta2.mean()
172/39:
plt.figure(figsize=(12,6))

plt.hist(theta1, alpha=0.5, label='Moment method')
plt.hist(theta2, alpha=0.5, label='ML method')
plt.legend();
172/40:
# mm
delta1 = theta1 - theta
MSE1 = np.mean(np.power(delta1, 2))
print(MSE1)
# ml
delta2 = theta2 - theta
MSE2 = np.mean(np.power(delta2, 2))
print(MSE2)

#  у оценки максимального правдоподобия разброс оказался меньше
172/41:
theta = stats.uniform.rvs(10, 10, random_state=100)
uniform_rv = stats.uniform(0, theta)
theta
172/42:
n = 50
sample = uniform_rv.rvs(n)
sample.shape
172/43:
# асимптотический интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mean = sample.mean() 
# var_hat = df.price.var(ddof=1) # delta degrees of freedom
# n = sample.count()

# margin = z_crit*np.sqrt(var_hat/n)

# left = mu_hat - margin
# right = mu_hat + margin

# print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/44:
# асимптотический интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mean = sample.mean()
z_crit
# var_hat = df.price.var(ddof=1) # delta degrees of freedom
# n = sample.count()

# margin = z_crit*np.sqrt(var_hat/n)

# left = mu_hat - margin
# right = mu_hat + margin

# print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/45:
# асимптотический интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mean = sample.mean()
z_crit
# var_hat = df.price.var(ddof=1) # delta degrees of freedom
# n = sample.count()

# margin = z_crit*np.sqrt(var_hat/n)

# left = mu_hat - margin
# right = mu_hat + margin

# print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/46:
# асимптотический интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mean = sample.mean()
z_crit
# var_hat = df.price.var(ddof=1) # delta degrees of freedom
# n = sample.count()

# margin = z_crit*np.sqrt(var_hat/n)

# left = mu_hat - margin
# right = mu_hat + margin

# print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/47:
# асимптотический интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mean = sample.mean()
mean
# var_hat = df.price.var(ddof=1) # delta degrees of freedom
# n = sample.count()

# margin = z_crit*np.sqrt(var_hat/n)

# left = mu_hat - margin
# right = mu_hat + margin

# print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/48:
# асимптотический интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mean = sample.mean()
mean
# var_hat = df.price.var(ddof=1) # delta degrees of freedom
# n = sample.count()

# margin = z_crit*np.sqrt(var_hat/n)

# left = mu_hat - margin
# right = mu_hat + margin

# print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/49:
# асимптотический интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mean = sample.mean()
mean
# var_hat = df.price.var(ddof=1) # delta degrees of freedom
# n = sample.count()

# margin = z_crit*np.sqrt(var_hat/n)

# left = mu_hat - margin
# right = mu_hat + margin

# print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/50:
# асимптотический интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mean = sample.mean()
n = sample.count()
n
# margin = z_crit*np.sqrt(var_hat/n)

# left = mu_hat - margin
# right = mu_hat + margin

# print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/51:
# асимптотический интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mean = sample.mean()
n = sample.len()
n
# margin = z_crit*np.sqrt(var_hat/n)

# left = mu_hat - margin
# right = mu_hat + margin

# print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/52:
# асимптотический интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mean = sample.mean()
n = sample.size
n
# margin = z_crit*np.sqrt(var_hat/n)

# left = mu_hat - margin
# right = mu_hat + margin

# print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/53:
# асимптотический интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mean = sample.mean()
n = sample.size
n
margin = 1+ z_crit/(n*sqrt(3))
margin
# left = mu_hat - margin
# right = mu_hat + margin

# print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/54:
# асимптотический интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mean = sample.mean()
n = sample.size
n
margin = 1+ z_crit/(n*np.sqrt(3))
margin
# left = mu_hat - margin
# right = mu_hat + margin

# print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/55:
# асимптотический интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mean = sample.mean()
n = sample.size
n
margin = 1+ z_crit/(n*np.sqrt(3))
margin
# left = mu_hat - margin
# right = mu_hat + margin

# print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/56:
# асимптотический интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mean = sample.mean()
n = sample.size
n
margin = 1+ z_crit/(n*np.sqrt(3))
margin
# left = mu_hat - margin
# right = mu_hat + margin

# print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/57:
# асимптотический интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mean = sample.mean()
n = sample.size
n
margin = 1+ z_crit/(n*np.sqrt(3))
margin
# left = mu_hat - margin
# right = mu_hat + margin

# print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/58:
# асимптотический интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mean = sample.mean()
n = sample.size
margin = z_crit/(n*np.sqrt(3))
left = mean / (1 + margin)
right = mean / (1 - margin)

print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/59:
# асимптотический интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mean = 2*sample.mean()
n = sample.size
margin = z_crit/(n*np.sqrt(3))
left = mean / (1 + margin)
right = mean / (1 - margin)

print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/60:
# асимптотический интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

doubled_mean = 2*sample.mean()
n = sample.size
margin = z_crit/(n*np.sqrt(3))
left = doubled_mean / (1 + margin)
right = doubled_mean / (1 - margin)

print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/61:
# асимптотический дов интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

doubled_mean = 2*sample.mean()
n = sample.size
margin = z_crit/(n*np.sqrt(3))
left = doubled_mean / (1 + margin)
right = doubled_mean / (1 - margin)

print("Асимпт доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/62:
# асимптотический дов интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

doubled_mean = 2*sample.mean()
n = sample.size
margin = z_crit/(n*np.sqrt(3))
left = doubled_mean / (1 + margin)
right = doubled_mean / (1 - margin)

print("Асимпт доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/63:
# асимптотический дов интервал для mm оценки

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

doubled_mean = 2*sample.mean()
n = sample.size
margin = z_crit/(n*np.sqrt(3))
left = doubled_mean / (1 + margin)
right = doubled_mean / (1 - margin)

print("Асимпт доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/64:
# точный дов интервал для ml оценки

alpha = 0.05

theta_ml = np.max(sample, axis=0)
n = sample.size

left = theta_ml
right = theta_ml / np.power(alpha,(1/n))

print("Точный доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/65:
# точный дов интервал для ml оценки

alpha = 0.05

theta_ml = np.max(sample, axis=0)
n = sample.size

left = theta_ml
right = theta_ml / np.power(alpha,(1/n))

print("Точный доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/66:
# точный дов интервал для ml оценки

alpha = 0.05

theta_ml = np.max(sample, axis=0)
n = sample.size

left = theta_ml
right = theta_ml / np.power(alpha,(1/n))

print("Точный доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/67:
# ml
delta2 = theta2 - theta
MSE2 = np.mean(np.power(delta2, 2))
print(MSE2)

# mm
delta1 = theta1 - theta
MSE1 = np.mean(np.power(delta1, 2))
print(MSE1)

#  у оценки максимального правдоподобия разброс оказался меньше
172/68:
# ml
delta2 = theta2 - theta
MSE2 = np.mean(np.power(delta2, 2))
print(MSE2)

# mm
delta1 = theta1 - theta
MSE1 = np.mean(np.power(delta1, 2))
print(MSE1)

#  у оценки максимального правдоподобия разброс оказался меньше
172/69: # Правило 3 сигм
172/70:
import numpy as np
import pandas as pd

from scipy import stats

import seaborn as sns
import matplotlib.pyplot as plt

plt.style.use('ggplot')
172/71:
# n1) для норм распределения
norm_rv = stats.norm(loc=0, scale=1)

for i in [2,3]:
    print(f'P({-i} < X < {i}) = Ф({i})-Ф({-i}) = ', norm_rv.cdf(i)-norm_rv.cdf(-i) )
    
# В нормальном распределении лежат 95% и 99% значений в пределах 2 и 3 сигм соответственно, то есть почти все значения. Все значения более 3 сигм можно считать выбросами
# Для произвольной случайной величины процент ее значений составляет 75% и 88%, что значительно меньше, чем для нормального распределения
172/72:
theta = stats.uniform.rvs(10, 10, random_state=10)
uniform_rv = stats.uniform(0, theta)
theta
172/73:
n = 100
M = 1000
samples = uniform_rv.rvs(size = (n, M))
samples.shape
172/74:
# mm
theta1 = 2*np.mean(samples, axis=0)

# ml
theta2 = (n + 1)/n*np.max(samples, axis=0)
172/75: theta1.mean(), theta2.mean()
172/76:
plt.figure(figsize=(12,6))

plt.hist(theta1, alpha=0.5, label='Moment method')
plt.hist(theta2, alpha=0.5, label='ML method')
plt.legend();
172/77:
# ml
delta2 = theta2 - theta
MSE2 = np.mean(np.power(delta2, 2))
print(MSE2)

# mm
delta1 = theta1 - theta
MSE1 = np.mean(np.power(delta1, 2))
print(MSE1)

#  у оценки максимального правдоподобия разброс оказался меньше
172/78:
theta = stats.uniform.rvs(10, 10, random_state=100)
uniform_rv = stats.uniform(0, theta)
theta
172/79:
n = 50
sample = uniform_rv.rvs(n)
sample.shape
172/80:
# точный дов интервал для ml оценки для параметра  𝜃  уровня доверия  (1−𝛼)  с помощью оценки  max(𝑋1,...,𝑋𝑛)

alpha = 0.05

theta_ml = np.max(sample, axis=0)
n = sample.size

left = theta_ml
right = theta_ml / np.power(alpha,(1/n))

print("Точный доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/81:
# асимптотический дов интервал для mm оценки  𝜃=2𝑋

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

doubled_mean = 2*sample.mean()
n = sample.size
margin = z_crit/(n*np.sqrt(3))
left = doubled_mean / (1 + margin)
right = doubled_mean / (1 - margin)

print("Асимпт доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
172/82:
df = pd.read_csv('./data/youtube_data.csv', sep='\t')
cols = ['likeCount', 'commentCount']
df = df[cols].dropna()
df = df.query('likeCount<1e6 and commentCount<100e3')
172/83: sns.scatterplot(data=df, x='likeCount',y='commentCount', );
172/84:
df = pd.read_csv("../data/coals.csv", index_col=0)
df.head()
174/1: import pandas as pd
174/2:
import numpy as np
import pandas as pd

data = pd.read_csv('./data.adult.csv')
data
174/3: data.isnull().sum()
174/4: data.isna()
174/5: data.isnull().sum()
174/6: '?' in data
174/7: '?' in data.values
174/8: data.head(100)
174/9: data.head(50)
174/10: data = data.replace('?', NaN)
174/11: data = data.replace('?', np.nan)
174/12:
data = data.replace('?', np.nan)
data.head(50)
174/13:
data = data.replace('?', np.nan)
data.innull.sum()
174/14:
data = data.replace('?', np.nan)
data.isnull.sum()
174/15:
data = data.replace('?', np.nan)
data.isnull().sum()
174/16:
data = data.replace('?', np.nan)
data.shape
174/17:
data = data.replace('?', np.nan)
data.shape
174/18:
data.dropna(inplace=True)
data.shape
174/19:
X = data.drop(columns='>50K,<=50K')
y = data['>50K,<=50K'].apply(lambda x: 1 if x == '>50K' else 0)
174/20:
X = data.drop(columns='>50K,<=50K')
y = data['>50K,<=50K'].apply(lambda x: 1 if x == '>50K' else 0)
y
174/21:
numericData = data._get_numeric_data()
numericData.head()
174/22:
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
174/23:
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
174/24:
numericData = data._get_numeric_data()
X_num = numericData
numericData.head()
175/1:
theta = stats.uniform.rvs(10, 10, random_state=11)
uniform_rv = stats.uniform(0, theta)
theta
175/2: # Правило 3 сигм
175/3:
import numpy as np
import pandas as pd

from scipy import stats

import seaborn as sns
import matplotlib.pyplot as plt

plt.style.use('ggplot')
175/4:
# n1) для норм распределения
norm_rv = stats.norm(loc=0, scale=1)

for i in [2,3]:
    print(f'P({-i} < X < {i}) = Ф({i})-Ф({-i}) = ', norm_rv.cdf(i)-norm_rv.cdf(-i) )
    
# В нормальном распределении лежат 95% и 99% значений в пределах 2 и 3 сигм соответственно, то есть почти все значения. Все значения более 3 сигм можно считать выбросами
# Для произвольной случайной величины процент ее значений составляет 75% и 88%, что значительно меньше, чем для нормального распределения
175/5:
theta = stats.uniform.rvs(10, 10, random_state=10)
uniform_rv = stats.uniform(0, theta)
theta
175/6:
n = 100
M = 1000
samples = uniform_rv.rvs(size = (n, M))
samples.shape
175/7:
# mm
theta1 = 2*np.mean(samples, axis=0)

# ml
theta2 = (n + 1)/n*np.max(samples, axis=0)
175/8: theta1.mean(), theta2.mean()
175/9:
plt.figure(figsize=(12,6))

plt.hist(theta1, alpha=0.5, label='Moment method')
plt.hist(theta2, alpha=0.5, label='ML method')
plt.legend();
175/10:
# ml
delta2 = theta2 - theta
MSE2 = np.mean(np.power(delta2, 2))
print(MSE2)

# mm
delta1 = theta1 - theta
MSE1 = np.mean(np.power(delta1, 2))
print(MSE1)

#  у оценки максимального правдоподобия разброс оказался меньше
175/11:
theta = stats.uniform.rvs(10, 10, random_state=100)
uniform_rv = stats.uniform(0, theta)
theta
175/12:
n = 50
sample = uniform_rv.rvs(n)
sample.shape
175/13:
# точный дов интервал для ml оценки для параметра  𝜃  уровня доверия  (1−𝛼)  с помощью оценки  max(𝑋1,...,𝑋𝑛)

alpha = 0.05

theta_ml = np.max(sample, axis=0)
n = sample.size

left = theta_ml
right = theta_ml / np.power(alpha,(1/n))

print("Точный доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
175/14:
# асимптотический дов интервал для mm оценки  𝜃=2𝑋

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

doubled_mean = 2*sample.mean()
n = sample.size
margin = z_crit/(n*np.sqrt(3))
left = doubled_mean / (1 + margin)
right = doubled_mean / (1 - margin)

print("Асимпт доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
175/15:
theta = stats.uniform.rvs(10, 10, random_state=11)
uniform_rv = stats.uniform(0, theta)
theta
175/16:
df = pd.read_csv('./data/youtube_data.csv', sep='\t')
cols = ['likeCount', 'commentCount']
df = df[cols].dropna()
df = df.query('likeCount<1e6 and commentCount<100e3')
175/17: sns.scatterplot(data=df, x='likeCount',y='commentCount', );
175/18:
df = pd.read_csv("../data/coals.csv", index_col=0)
df.head()
175/19:
df = pd.read_csv("./data/coals.csv", index_col=0)
df.head()
175/20:
theta = stats.uniform.rvs(10, 10, random_state=1111)
uniform_rv = stats.uniform(0, theta)
theta
175/21:
theta = stats.uniform.rvs(10, 10, random_state=11)
uniform_rv = stats.uniform(0, theta)
theta
175/22:
theta = stats.uniform.rvs(10, 10, random_state=21)
uniform_rv = stats.uniform(0, theta)
theta
175/23:
theta = stats.uniform.rvs(10, 10, random_state=300)
uniform_rv = stats.uniform(0, theta)
theta
175/24:
n = 100
M = 1000
samples = uniform_rv.rvs(size = (n, M))
samples.shape
175/25:
# mm
theta1 = 2*np.mean(samples, axis=0)

# ml
theta2 = (n + 1)/n*np.max(samples, axis=0)

theta2
175/26:
# mm
theta1 = 2*np.mean(samples, axis=0)

# ml
theta2 = (n + 1)/n*np.max(samples, axis=0)
175/27: theta1
175/28:
theta1_check = theta1.apply(lambda x: False if x > theta True)

theta2_check = theta2.apply(lambda x: False if x > theta True)
175/29:
theta1_check = theta1.apply(lambda x: False if x > theta else True)

theta2_check = theta2.apply(lambda x: False if x > theta else True)
175/30:
theta1_check = theta1.apply(lambda x: False if x > theta else True)

theta2_check = theta2.apply(lambda x: False if x > theta else True)
175/31:
theta1_check = theta1[theta1<theta]

# theta2_check = theta2.apply(lambda x: False if x > theta else True)
175/32:
theta1_check = theta1[theta1<theta]
theta1_check
# theta2_check = theta2.apply(lambda x: False if x > theta else True)
175/33:
theta1_check = theta1[theta1<theta]
theta1_check.shape
# theta2_check = theta2.apply(lambda x: False if x > theta else True)
175/34:
theta1_check = theta1[theta1<theta]
theta1_check
# theta2_check = theta2.apply(lambda x: False if x > theta else True)
175/35:
theta1_check = theta1[theta1<=theta]
theta1_check
# theta2_check = theta2.apply(lambda x: False if x > theta else True)
175/36:
alpha = 0.05

ml_intervals = []

for sample in samples:
    theta_ml = np.max(sample, axis=0)
    n = sample.size

    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals.append((left, right))
    
ml_intervals
175/37:
alpha = 0.05

ml_intervals = []

for sample in samples:
    theta_ml = np.max(sample, axis=0)
    n = sample.size

    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals.append((left, right))
175/38:
alpha = 0.05

ml_intervals_corr = []

for sample in samples:
    theta_ml = (n + 1)/n*np.max(samples, axis=0)
    n = sample.size

    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals_corr.append((left, right))
ml_intervals_corr
175/39:
theta = stats.uniform.rvs(10, 10, random_state=300)
uniform_rv = stats.uniform(0, theta)
theta
175/40:
n = 100
M = 1000
samples = uniform_rv.rvs(size = (n, M))
samples.shape
175/41:
alpha = 0.05

ml_intervals_corr = []

for sample in samples:
    theta_ml = (n + 1)/n*np.max(samples, axis=0)
    n = sample.size
    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals_corr.append((left, right))

ml_intervals_corr
175/42:
alpha = 0.05

ml_intervals = []

for sample in samples:
    theta_ml = np.max(sample, axis=0)
    n = sample.size

    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals.append((left, right))
175/43:
alpha = 0.05

ml_intervals = []

for sample in samples:
    theta_ml = np.max(sample, axis=0)
    n = sample.size

    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals.append((left, right))
ml_intervals
175/44:
alpha = 0.05

ml_intervals = []

for sample in samples:
    theta_ml = np.max(sample, axis=0)
    n = sample.size

    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals.append((left, right))
175/45:
alpha = 0.05

ml_intervals_corr = []

for sample in samples:
    theta_ml = (n + 1)/n*np.max(sample, axis=0)
    n = sample.size
    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals_corr.append((left, right))

ml_intervals_corr
175/46:
alpha = 0.05

ml_intervals_corr = []

for sample in samples:
    theta_ml = (n + 1)/n*np.max(sample, axis=0)
    n = sample.size
    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals_corr.append((left, right))
175/47:
alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mm_intervals = []

for sample in samples:
    doubled_mean = 2*sample.mean()
    n = sample.size
    margin = z_crit/(n*np.sqrt(3))
    left = doubled_mean / (1 + margin)
    right = doubled_mean / (1 - margin)
    mm_intervals.append((left, right))
mm_intervals
175/48:
alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mm_intervals = []

for sample in samples:
    doubled_mean = 2*sample.mean()
    n = sample.size
    margin = z_crit/(n*np.sqrt(3))
    left = doubled_mean / (1 + margin)
    right = doubled_mean / (1 - margin)
    mm_intervals.append((left, right))
175/49:
for interval in mm_intervals:
    print(interval)
175/50:
ml_intervals_check = 0
for interval in ml_intervals:
    if theta >= interval[0] && interval <=interval[1]:
        ml_intervals_check += 1
        
print('res', ml_intervals_check)

ml_intervals
175/51:
ml_intervals_check = 0
for interval in ml_intervals:
    if theta >= interval[0] and interval <=interval[1]:
        ml_intervals_check += 1
        
print('res', ml_intervals_check)

ml_intervals
175/52:
ml_intervals_check = 0
for interval in ml_intervals:
    print(interval)
    if theta >= interval[0] and interval <=interval[1]:
        ml_intervals_check += 1
        
print('res', ml_intervals_check)

ml_intervals
175/53:
ml_intervals_check = 0
for interval in ml_intervals:
    print(interval[]0)
    if theta >= interval[0] and interval <=interval[1]:
        ml_intervals_check += 1
        
print('res', ml_intervals_check)

ml_intervals
175/54:
ml_intervals_check = 0
for interval in ml_intervals:
    print(interval[0])
    if theta >= interval[0] and interval <=interval[1]:
        ml_intervals_check += 1
        
print('res', ml_intervals_check)

ml_intervals
175/55:
ml_intervals_check = 0
for interval in ml_intervals:
    print(interval[1])
    if theta >= interval[0] and interval <=interval[1]:
        ml_intervals_check += 1
        
print('res', ml_intervals_check)

ml_intervals
175/56:
ml_intervals_check = 0
for interval in ml_intervals:
    print(type(interval))
    if theta >= interval[0] and interval <=interval[1]:
        ml_intervals_check += 1
        
print('res', ml_intervals_check)

ml_intervals
175/57:
ml_intervals_check = 0
for interval in ml_intervals:
    print(type(interval[0]))
    if theta >= interval[0] and interval <=interval[1]:
        ml_intervals_check += 1
        
print('res', ml_intervals_check)

ml_intervals
175/58:
ml_intervals_check = 0
for interval in ml_intervals:
    print(type(interval[0].values))
    if theta >= interval[0] and interval <=interval[1]:
        ml_intervals_check += 1
        
print('res', ml_intervals_check)

ml_intervals
175/59:
ml_intervals_check = 0
for interval in ml_intervals:
    print(type(interval[0].value))
    if theta >= interval[0] and interval <=interval[1]:
        ml_intervals_check += 1
        
print('res', ml_intervals_check)

ml_intervals
175/60:
ml_intervals_check = 0
for interval in ml_intervals:
    print(type(interval[0].astype('float')))
    if theta >= interval[0] and interval <=interval[1]:
        ml_intervals_check += 1
        
print('res', ml_intervals_check)

ml_intervals
175/61:
ml_intervals_check = 0
for interval in ml_intervals:
    print(interval[0].item())
    if theta >= interval[0] and interval <=interval[1]:
        ml_intervals_check += 1
        
print('res', ml_intervals_check)

ml_intervals
175/62:
ml_intervals_check = 0
for interval in ml_intervals:
    print(interval[0].item())
    if theta >= interval[0] and theta <=interval[1]:
        ml_intervals_check += 1
        
print('res', ml_intervals_check)

ml_intervals
175/63:
ml_intervals_check = 0
for interval in ml_intervals:
    if theta >= interval[0] and theta <=interval[1]:
        ml_intervals_check += 1
        
print('res', ml_intervals_check)
175/64:
ml_intervals_corr_check = 0
for interval in ml_intervals_corr:
    if theta >= interval[0] and theta <=interval[1]:
        ml_intervals_corr_check += 1
ml_intervals_corr_check
175/65:
mm_intervals_check = 0
for interval in mm_intervals:
    if theta >= interval[0] and theta <=interval[1]:
        mm_intervals_check += 1
mm_intervals_check
177/1:
param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']}
]

sgd_pipeline = Pipeline(
#     StandardScaler(),
    GridSearchCV(SGDClassifier(), param_grid)
)


sgd_res = cross_validate(sgd_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)


print('SGD result:', sgd_res)
177/2:
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import cross_validate
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import PolynomialFeatures, StandardScaler
from category_encoders.leave_one_out import LeaveOneOutEncoder
from sklearn import model_selection
from sklearn.pipeline import Pipeline
177/3:
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import cross_validate
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import PolynomialFeatures, StandardScaler
from category_encoders.leave_one_out import LeaveOneOutEncoder

from sklearn import model_selection
from sklearn.pipeline import Pipeline
177/4: pip install --upgrade category_encoders
177/5:
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import cross_validate
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import PolynomialFeatures, StandardScaler
from category_encoders.leave_one_out import LeaveOneOutEncoder

from sklearn import model_selection
from sklearn.pipeline import Pipeline
177/6:
param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']}
]

sgd_pipeline = Pipeline(
#     StandardScaler(),
    GridSearchCV(SGDClassifier(), param_grid)
)


sgd_res = cross_validate(sgd_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)


print('SGD result:', sgd_res)
177/7:
param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']}
]

sgd_pipeline = Pipeline([
#     StandardScaler(),
    GridSearchCV(SGDClassifier(), param_grid)
]])


sgd_res = cross_validate(sgd_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)


print('SGD result:', sgd_res)
177/8:
param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']}
]

sgd_pipeline = Pipeline([
#     StandardScaler(),
    GridSearchCV(SGDClassifier(), param_grid)
])


sgd_res = cross_validate(sgd_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)


print('SGD result:', sgd_res)
177/9:
param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']}
]

sgd_pipeline = Pipeline(
    GridSearchCV(SGDClassifier(), param_grid)
)


sgd_res = cross_validate(sgd_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)


print('SGD result:', sgd_res)
177/10:
param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']}
]

sgd_pipeline = Pipeline(GridSearchCV(SGDClassifier(), param_grid))


sgd_res = cross_validate(sgd_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)


print('SGD result:', sgd_res)
177/11:
param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']}
]

sgd_pipeline = Pipeline([
#     StandardScaler(),
    GridSearchCV(SGDClassifier(), param_grid)
])


sgd_res = cross_validate(sgd_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)


print('SGD result:', sgd_res)
177/12:
param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']}
]

sgd_pipeline = Pipeline(
#     StandardScaler(),
    GridSearchCV(SGDClassifier(), param_grid)
)


sgd_res = cross_validate(sgd_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)


print('SGD result:', sgd_res)
177/13:
param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']}
]

sgd_pipeline = Pipeline(
#     StandardScaler(),
    GridSearchCV(SGDClassifier(), param_grid)
)


sg_res = cross_validate(sgd_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)


print('SGD result:', sdg_res)
177/14:
param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']}
]

sgd_pipeline = Pipeline(
#     StandardScaler(),
    GridSearchCV(SGDClassifier(), param_grid)
)


sgd_res = cross_validate(sgd_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)


print('SGD result:', sgd_res)
177/15:
param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']}
]

sgd_pipeline = Pipeline([('sdg',SGDClassifier)])

grid_pipeline = GridSearchCV(sgd_pipeline, param_grid)
sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)


print('SGD result:', sgd_res)
177/16:
numericData = data._get_numeric_data()
X_num = numericData
numericData.head()
177/17:
import numpy as np
import pandas as pd

data = pd.read_csv('./data.adult.csv')
data
177/18: data.isnull().sum()
177/19:
data = data.replace('?', np.nan)
data.shape
177/20:
data.dropna(inplace=True)
data.shape
177/21:
X = data.drop(columns='>50K,<=50K')
y = data['>50K,<=50K'].apply(lambda x: 1 if x == '>50K' else 0)
y
177/22:
numericData = data._get_numeric_data()
X_num = numericData
numericData.head()
177/23: pip install --upgrade category_encoders
177/24:
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import cross_validate
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import PolynomialFeatures, StandardScaler
from category_encoders.leave_one_out import LeaveOneOutEncoder

from sklearn import model_selection
from sklearn.pipeline import Pipeline
177/25:
param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']}
]

sgd_pipeline = Pipeline([('sdg',SGDClassifier)])

grid_pipeline = GridSearchCV(sgd_pipeline, param_grid)
sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)


print('SGD result:', sgd_res)
177/26:
param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']}
]

sgd_pipeline = Pipeline([('sdg',SGDClassifier)])

grid_pipeline = GridSearchCV(sgd_pipeline, param_grid)
sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)


print('SGD result:', sgd_res)
177/27:
param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']}
]

sgd_pipeline = Pipeline([('sdg', SGDClassifier(loss="hinge", penalty="l2",))])

grid_pipeline = GridSearchCV(sgd_pipeline, param_grid)
sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)


print('SGD result:', sgd_res)
177/28:
param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']}
]

sgd_pipeline = Pipeline([('sdg', SGDClassifier(loss="hinge",  tol=1e-3))])

grid_pipeline = GridSearchCV(sgd_pipeline, param_grid)
sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)


print('SGD result:', sgd_res)
177/29:
param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']}
]

sgd_pipeline = Pipeline([('sdg', SGDClassifier(loss="hinge",  tol=1e-3))])

grid_pipeline = GridSearchCV(sgd_pipeline, param_grid)
# sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)


print('SGD result:', grid_pipeline)
177/30:
param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']}
]

sgd_pipeline = Pipeline([('sdg', SGDClassifier(loss="hinge",  tol=1e-3))])

grid_pipeline = GridSearchCV(sgd_pipeline, param_grid)
# sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)
grid_pipeline.fit(X_num, y)

print('SGD result:', grid_pipeline)
177/31:
param_grid = [
    "loss" : ["hinge"],
    "alpha" : [0.0001, 0.001, 0.01, 0.1],
]

sgd_pipeline = Pipeline([('sdg', SGDClassifier(loss="hinge",  tol=1e-3))])

grid_pipeline = GridSearchCV(sgd_pipeline, param_grid)
# sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)
grid_pipeline.fit(X_num, y)

print('SGD result:', grid_pipeline)
177/32:
param_grid = {
    "loss" : ["hinge"],
    "alpha" : [0.0001, 0.001, 0.01, 0.1],
}

sgd_pipeline = Pipeline([('sdg', SGDClassifier(loss="hinge",  tol=1e-3))])

grid_pipeline = GridSearchCV(sgd_pipeline, param_grid)
# sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)
grid_pipeline.fit(X_num, y)

print('SGD result:', grid_pipeline)
177/33:
param_grid = {
    "alpha" : [0.0001, 0.001, 0.01, 0.1],
}

sgd_pipeline = Pipeline([('sdg', SGDClassifier(loss="hinge",  tol=1e-3))])

grid_pipeline = GridSearchCV(sgd_pipeline, param_grid)
# sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)
grid_pipeline.fit(X_num, y)

print('SGD result:', grid_pipeline)
177/34:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
    "alpha" : [0.0001, 0.001, 0.01, 0.1],
    "penalty" : ["l2", "l1", "none"],
}

sgd_pipeline = Pipeline([('sdg', SGDClassifier(loss="hinge",  tol=1e-3))])

grid_pipeline = GridSearchCV(sgd_pipeline, param_grid=params)
# sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)
grid_pipeline.fit(X_num, y)

print('SGD result:', grid_pipeline)
177/35:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
    "alpha" : [0.0001, 0.001, 0.01, 0.1],
    "penalty" : ["l2", "l1", "none"],
}

sgd_pipeline = Pipeline([('sdg', SGDClassifier(tol=1e-3))])

grid_pipeline = GridSearchCV(sgd_pipeline, param_grid=params)
# sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)
grid_pipeline.fit(X_num, y)

print('SGD result:', grid_pipeline)
177/36:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
    "alpha" : [0.0001, 0.001, 0.01, 0.1],
    "penalty" : ["l2", "l1", "none"],
}

sgd_pipeline = Pipeline([('sdg', SGDClassifier(tol=1e-3))])

grid_pipeline = GridSearchCV(sgd_pipeline)
# sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)
grid_pipeline.fit(X_num, y)

print('SGD result:', grid_pipeline)
177/37:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
    "alpha" : [0.0001, 0.001, 0.01, 0.1],
    "penalty" : ["l2", "l1", "none"],
}

model = SGDClassifier(max_iter=1000)

grid_pipeline = GridSearchCV(model, param_grid=params)
# sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)
grid_pipeline.fit(X_num, y)

print('SGD result:', grid_pipeline)
177/38:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

model = SGDClassifier(max_iter=10000, tol=1e-3)

grid_pipeline = GridSearchCV(model, param_grid=params)
# sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)
grid_pipeline.fit(X_num, y)

print('SGD result:', grid_pipeline)
177/39:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

model = SGDClassifier(max_iter=10000, tol=1e-3)

grid_pipeline = GridSearchCV(model, param_grid=params)
sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)
# grid_pipeline.fit(X_num, y)

print('SGD result:', sgd_res)
177/40:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

model = SGDClassifier(max_iter=10000, tol=1e-3)

grid_pipeline = GridSearchCV(model, param_grid=params)
sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)
# grid_pipeline.fit(X_num, y)

print('SGD result:', sgd_res)
177/41:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

model = SGDClassifier(max_iter=10000, tol=1e-3)

grid_pipeline = GridSearchCV(model, param_grid=params)
sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)

print('SGD result:', sgd_res['test_score'])
177/42:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

model = SGDClassifier(max_iter=10000, tol=1e-3)

grid_pipeline = GridSearchCV(model, param_grid=params)
sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)

print('SGD result:', sgd_res)
177/43:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

model = SGDClassifier(max_iter=10000, tol=1e-3)

grid_pipeline = GridSearchCV(model, param_grid=params)
sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)

print(sgd_res)
177/44:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

model = SGDClassifier(max_iter=10000, tol=1e-3)

grid_pipeline = GridSearchCV(model, param_grid=params)
sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)

sgd_res
177/45:
k_range = list(range(1, 100))
param_grid = dict(n_neighbors=k_range)

knn = SGDClassifier(max_iter=10000, tol=1e-3)

grid_pipeline = GridSearchCV(knn, param_grid=params)
knn_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)

knn_res
177/46:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

model = SGDClassifier(max_iter=10000, tol=1e-3)

grid_pipeline = GridSearchCV(model, param_grid=params)
sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)

sgd_res
177/47: import matplotlib.pyplot as plt
177/48:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)
sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)

sgd_res
177/49:
results = pd.DataFrame(grid_sgd.cv_results_)
results.columns
177/50:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)
sgd_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)

sgd_res
177/51:
results = pd.DataFrame(grid_sgd.cv_results_)
results.columns
177/52:
results = pd.DataFrame(grid_sgd.cv_results_)
results.columns
177/53:
results = pd.DataFrame(grid_sgd.grid_scores_)
results.columns
177/54:
results = pd.DataFrame(grid_sgd.grid_scores_)
results.columns
177/55:
results = pd.DataFrame(grid_sgd.grid_scores_)
grid_sgd
177/56:
results = pd.DataFrame(grid_sgd.grid_scores_)
grid_sgd
177/57:
# results = pd.DataFrame(grid_sgd.grid_scores_)
grid_sgd
177/58:
k_range = list(range(1, 100))
param_grid = dict(n_neighbors=k_range)

knn = SGDClassifier(max_iter=10000, tol=1e-3)

grid_pipeline = GridSearchCV(knn, param_grid=params)
knn_res = cross_validate(grid_pipeline, X_num, y, cv=5, scoring='f1', return_train_score=True)

knn_res['test_score']
177/59:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)
sgd_res = cross_validate(grid_sgd, X_num, y, cv=5, scoring='f1', return_train_score=True)

sgd_res
177/60:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd)
sgd_res = cross_validate(grid_sgd, X_num, y, cv=5, scoring='f1', return_train_score=True)

sgd_res
177/61:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

sgd = SGDClassifier(max_iter=10000, tol=1e-3)

# grid_sgd = GridSearchCV(sgd, param_grid=params)
sgd_res = cross_validate(sgd, X_num, y, cv=5, scoring='f1', return_train_score=True)

sgd_res
177/62:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)
sgd_res = cross_validate(sgd, X_num, y, cv=5, scoring='f1', return_train_score=True)

sgd_res
177/63:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)
sgd_res = cross_validate(sgd, X_num, y, cv=5, scoring='f1', return_train_score=True)

sgd_res
177/64:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)
sgd_res = cross_validate(sgd, X_num, y, cv=5, scoring='f1', return_train_score=True)

sgd_res
177/65:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)
sgd_res = cross_validate(sgd, X_num, y, cv=5, scoring='f1', return_train_score=True)

sgd_res
177/66:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)
sgd_res = cross_validate(sgd, X_num, y, cv=5, scoring='f1', return_train_score=True)

sgd_res
177/67:
params = {
    "loss" : ["hinge"],
}

sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)
sgd_res = cross_validate(sgd, X_num, y, cv=5, scoring='f1', return_train_score=True)

sgd_res
177/68:
params = {
    "loss" : ["hinge"],
}

sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)
sgd_res = cross_validate(sgd, X_num, y, cv=5, scoring='f1', return_train_score=True)

sgd_res
177/69:
params = {
    "loss" : ["hinge"],
}

sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)
sgd_res = cross_validate(sgd, X_num, y, cv=5, scoring='f1', return_train_score=True)

sgd_res
177/70:
params = {
    "loss" : ["hinge"],
}

sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)
sgd_res = cross_validate(sgd, X_num, y, cv=5, scoring='f1', return_train_score=True)

sgd_res
177/71:
params = {
    "loss" : ["hinge"],
}

sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)
sgd_res = cross_validate(sgd, X_num, y, cv=5, scoring='f1', return_train_score=True)

sgd_res
177/72:
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import KFold
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import PolynomialFeatures, StandardScaler
from category_encoders.leave_one_out import LeaveOneOutEncoder

from sklearn import model_selection
from sklearn.pipeline import Pipeline
import matplotlib.pyplot as plt
177/73:
k_range = list(range(1, 100))
param_grid = dict(n_neighbors=k_range)

knn = SGDClassifier(max_iter=10000, tol=1e-3)

knn_grid = GridSearchCV(knn, param_grid=params)
KFold(n_splits=5, random_state=113, shuffle=True)

knn_res['test_score']
177/74:
k_range = list(range(1, 100))
param_grid = dict(n_neighbors=k_range)

knn = SGDClassifier(max_iter=10000, tol=1e-3)

knn_grid = GridSearchCV(knn, param_grid=params)
kfold = KFold(n_splits=5, random_state=113, shuffle=True)

cv_results = model_selection.cross_val_score(knn_grid, X_num, y, cv=kfold, scoring=scoring)


knn_res['cv_results']
177/75:
k_range = list(range(1, 100))
param_grid = dict(n_neighbors=k_range)

knn = SGDClassifier(max_iter=10000, tol=1e-3)

knn_grid = GridSearchCV(knn, param_grid=params)
kfold = KFold(n_splits=5, random_state=113)
cv_results = model_selection.cross_val_score(knn_grid, X_num, y, cv=kfold, scoring='f1')


knn_res['cv_results']
177/76:
k_range = list(range(1, 100))
param_grid = dict(n_neighbors=k_range)

knn = SGDClassifier(max_iter=10000, tol=1e-3)

knn_grid = GridSearchCV(knn, param_grid=params)
kfold = KFold(n_splits=5, random_state=113, shuffle=True)
cv_results = model_selection.cross_val_score(knn_grid, X_num, y, cv=kfold, scoring='f1')


knn_res['cv_results']
177/77:
k_range = list(range(1, 100))
param_grid = dict(n_neighbors=k_range)

knn = SGDClassifier(max_iter=10000, tol=1e-3)

knn_grid = GridSearchCV(knn, param_grid=params)
kfold = KFold(n_splits=5, random_state=113, shuffle=True)
cv_results = model_selection.cross_val_score(knn_grid, X_num, y, cv=kfold, scoring='f1')


cv_results
177/78:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}

sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)
sgd_res = cross_validate(grid_sgd, X_num, y, cv=5, scoring='f1', return_train_score=True)

sgd_res
177/79:
kf = KFold(n_splits=5)
for train, test in kf.split(X_num, y):
   print("%s %s" % (train, test)
177/80:
kf = KFold(n_splits=5)
for train, test in kf.split(X_num, y):
    print("%s %s" % (train, test)
177/81:
kf = KFold(n_splits=5)
for train, test in kf.split(X_num, y):
    print("%s %s" % (train, test))
177/82:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)

kf = KFold(n_splits=5)
for train, test in kf.split(X_num, y):
    print(X[train])
#     X_d = svd.fit_transform(X_num)
#     X_d_test = svd.transform(test_data_centered)
#     clf.fit(X_d, train_labels)   
#     scores.append(sklearn.metrics.accuracy_score(test_labels, clf.predict(X_d_test)))

all_scores.append(scores)
all_k.append(clf.best_params_['n_neighbors'])
177/83:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)

kf = KFold(n_splits=5)
for train, test in kf.split(X_num, y):
    print(train)
#     X_d = svd.fit_transform(X_num)
#     X_d_test = svd.transform(test_data_centered)
#     clf.fit(X_d, train_labels)   
#     scores.append(sklearn.metrics.accuracy_score(test_labels, clf.predict(X_d_test)))

all_scores.append(scores)
all_k.append(clf.best_params_['n_neighbors'])
177/84:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)

kf = KFold(n_splits=5)
for train, test in kf.split(X_num, y):
    print(train.head)
#     X_d = svd.fit_transform(X_num)
#     X_d_test = svd.transform(test_data_centered)
#     clf.fit(X_d, train_labels)   
#     scores.append(sklearn.metrics.accuracy_score(test_labels, clf.predict(X_d_test)))

all_scores.append(scores)
all_k.append(clf.best_params_['n_neighbors'])
177/85:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)

kf = KFold(n_splits=5)
for train, test in kf.split(X_num, y):
    print(train.head())
#     X_d = svd.fit_transform(X_num)
#     X_d_test = svd.transform(test_data_centered)
#     clf.fit(X_d, train_labels)   
#     scores.append(sklearn.metrics.accuracy_score(test_labels, clf.predict(X_d_test)))

all_scores.append(scores)
all_k.append(clf.best_params_['n_neighbors'])
177/86:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)

kf = KFold(n_splits=5)
for train, test in kf.split(X_num, y):
    print(train
#     X_d = svd.fit_transform(X_num)
#     X_d_test = svd.transform(test_data_centered)
#     clf.fit(X_d, train_labels)   
#     scores.append(sklearn.metrics.accuracy_score(test_labels, clf.predict(X_d_test)))

all_scores.append(scores)
all_k.append(clf.best_params_['n_neighbors'])
177/87:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)

kf = KFold(n_splits=5)
for train, test in kf.split(X_num, y):
    print(train)
#     X_d = svd.fit_transform(X_num)
#     X_d_test = svd.transform(test_data_centered)
#     clf.fit(X_d, train_labels)   
#     scores.append(sklearn.metrics.accuracy_score(test_labels, clf.predict(X_d_test)))

all_scores.append(scores)
all_k.append(clf.best_params_['n_neighbors'])
177/88:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, param_grid=params)

kf = KFold(n_splits=5)
for train_index, test_index in kf.split(X_num, y):
    print(train)
#     X_d = svd.fit_transform(X_num)
#     X_d_test = svd.transform(test_data_centered)
#     clf.fit(X_d, train_labels)   
#     scores.append(sklearn.metrics.accuracy_score(test_labels, clf.predict(X_d_test)))

all_scores.append(scores)
all_k.append(clf.best_params_['n_neighbors'])
177/89:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=params)
177/90:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=params)
grid_sgd
177/91:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=params)
grid_sgd.fit(X_num, y)

clf.best_score_                                  

clf.best_estimator_.C
177/92:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=params)
grid_sgd.fit(X_num, y)

grid_sgd.best_score_                                  

grid_sgd.best_estimator_.C
177/93:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=params)
grid_sgd.fit(X_num, y)

print('best score:', grid.best_score_)
print('best params:', grid.best_params_)
177/94:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=params)
grid_sgd.fit(X_num, y)

print('best score:', grid_sgd.best_score_)
print('best params:', grid_sgd.best_params_)
178/1:
import numpy as np
import pandas as pd

data = pd.read_csv('./data.adult.csv')
data
178/2: data.isnull().sum()
178/3:
data = data.replace('?', np.nan)
data.shape
178/4:
data.dropna(inplace=True)
data.shape
178/5:
X = data.drop(columns='>50K,<=50K')
y = data['>50K,<=50K'].apply(lambda x: 1 if x == '>50K' else 0)
y
178/6:
numericData = data._get_numeric_data()
X_num = numericData
numericData.head()
178/7:
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import KFold
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import PolynomialFeatures, StandardScaler
from category_encoders.leave_one_out import LeaveOneOutEncoder

from sklearn import model_selection
from sklearn.pipeline import Pipeline
import matplotlib.pyplot as plt
178/8:
k_range = list(range(1, 100))
param_grid = dict(n_neighbors=k_range)

knn = SGDClassifier(max_iter=10000, tol=1e-3)

knn_grid = GridSearchCV(knn, cv=5, param_grid=params)
knn_grid.fit(X_num, y)

print('best score:', knn_grid.best_score_)
print('best params:', knn_grid.best_params_)
print(knn_grid.cv_results_)
178/9:
k_range = list(range(1, 100))
params = dict(n_neighbors=k_range)

knn = SGDClassifier(max_iter=10000, tol=1e-3)

knn_grid = GridSearchCV(knn, cv=5, param_grid=params)
knn_grid.fit(X_num, y)

print('best score:', knn_grid.best_score_)
print('best params:', knn_grid.best_params_)
print(knn_grid.cv_results_)
178/10:
k_range = list(range(1, 100))
params = dict(n_neighbors=k_range)

knn = KNeighborsClassifier()

knn_grid = GridSearchCV(knn, cv=5, param_grid=params)
knn_grid.fit(X_num, y)

print('best score:', knn_grid.best_score_)
print('best params:', knn_grid.best_params_)
print(knn_grid.cv_results_)
178/11:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=params)
grid_sgd.fit(X_num, y)

print('best score:', grid_sgd.best_score_)
print('best params:', grid_sgd.best_params_)
178/12:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=params)
grid_sgd.fit(X_num, y)

print('best score:', grid_sgd.best_score_)
print('best params:', grid_sgd.best_params_)
178/13:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=params)
grid_sgd.fit(X_num, y)

print('best score:', grid_sgd.best_score_)
print('best params:', grid_sgd.best_params_)
178/14: np.random.seed(1)
178/15:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=params)
grid_sgd.fit(X_num, y)

print('best score:', grid_sgd.best_score_)
print('best params:', grid_sgd.best_params_)
print(knn_grid.cv_results_)
178/16:
params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=params)
grid_sgd.fit(X_num, y)

print('best score:', grid_sgd.best_score_)
print('best params:', grid_sgd.best_params_)
print(grid_sgd.cv_results_)
178/17:
k_range = [0.1, 1, 50, 100, 1000]
params = dict(n_neighbors=k_range)

knn = KNeighborsClassifier()

knn_grid = GridSearchCV(knn, cv=5, param_grid=params)
knn_grid.fit(X_num, y)

print('best score:', knn_grid.best_score_)
print('best params:', knn_grid.best_params_)
print(knn_grid.cv_results_)
178/18:
k_range = [1, 11, 51, 101, 1001]
params = dict(n_neighbors=k_range)

knn = KNeighborsClassifier()

knn_grid = GridSearchCV(knn, cv=5, param_grid=params)
knn_grid.fit(X_num, y)

print('best score:', knn_grid.best_score_)
print('best params:', knn_grid.best_params_)
print(knn_grid.cv_results_)
178/19:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 

plt.figure(figsize = (8, 6))

plt.grid()
plt.legend();

plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x,y) 
plt.show()
178/20:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
y
plt.figure(figsize = (8, 6))

plt.grid()
plt.legend();

plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x,y) 
plt.show()
178/21:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
print('y', y)
plt.figure(figsize = (8, 6))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x,y) 
plt.show()
178/22:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
print('y', y)
plt.figure(figsize = (8, 6))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, markersize=40)
plt.show()
178/23:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
print('y', y)
plt.figure(figsize = (8, 6))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.scatter(x, y, markersize=40)
plt.show()
178/24:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
print('y', y)
plt.figure(figsize = (8, 6))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, markersize=40)
178/25:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
print('y', y)
plt.figure(figsize = (8, 6))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=40)
178/26:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
print('y', y)
plt.figure(figsize = (12, 6))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=40)
178/27:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
print('y', y)
plt.figure(figsize = (12, 6))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
178/28:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
plt.figure(figsize = (12, 6))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
178/29:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
plt.figure(figsize = (12, 6))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
plt.fill_between(x, knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score'],
                    knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score'], alpha=0.2,
                    color="navy")
178/30:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
plt.figure(figsize = (12, 6))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
plt.fill_between(x, knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score'],
                    knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score'], alpha=0.2,
                    color="darkorange")
178/31:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
plt.figure(figsize = (20, 6))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
plt.fill_between(x, knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score'],
                    knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score'], alpha=0.2,
                    color="darkorange")
178/32:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
plt.figure(figsize = (12, 15))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
plt.fill_between(x, knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score'],
                    knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score'], alpha=0.2,
                    color="darkorange")
178/33:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
plt.figure(figsize = (12, 10))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
plt.fill_between(x, knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score'],
                    knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score'], alpha=0.2,
                    color="darkorange")
178/34:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
dov_int_l = knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score']
print('dov_int_l', dov_int_l)

plt.figure(figsize = (12, 10))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
plt.plot(x, x + 3, linestyle='dotted');


# plt.fill_between(x, knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score'],
#                     knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score'], alpha=0.2,
#                     color="darkorange")
178/35:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
dov_int_l = knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score']
print('dov_int_l', dov_int_l)

plt.figure(figsize = (12, 10))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
# plt.plot(x, x + 3, linestyle='dotted');


# plt.fill_between(x, knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score'],
#                     knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score'], alpha=0.2,
#                     color="darkorange")
178/36:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
dov_int_l = knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score']
print('mean_test_score', knn_grid.cv_results_['mean_test_score'])
print('std_test_score', knn_grid.cv_results_['std_test_score'])
print('dov_int_l', dov_int_l)

plt.figure(figsize = (12, 10))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
# plt.plot(x, x + 3, linestyle='dotted');


# plt.fill_between(x, knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score'],
#                     knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score'], alpha=0.2,
#                     color="darkorange")
178/37:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
dov_int_l = knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score']
dov_int_r = knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score']
print('mean_test_score', knn_grid.cv_results_['mean_test_score'])
print('std_test_score', knn_grid.cv_results_['std_test_score'])
print('dov_int_l', dov_int_l)
print('dov_int_r', dov_int_r)

plt.figure(figsize = (12, 10))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
# plt.plot(x, x + 3, linestyle='dotted');


# plt.fill_between(x, knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score'],
#                     knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score'], alpha=0.2,
#                     color="darkorange")
178/38:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
dov_int_l = knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score']
dov_int_r = knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score']


plt.figure(figsize = (12, 10))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
plt.plot(dov_int_l, y, color="darkorange", linestyle='dotted');
plt.plot(dov_int_r, y, color="darkorange", linestyle='dotted');


# plt.fill_between(x, knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score'],
#                     knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score'], alpha=0.2,
#                     color="darkorange")
178/39:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
dov_int_l = knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score']
dov_int_r = knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score']


plt.figure(figsize = (12, 10))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
# plt.plot(x, y, marker=".", markersize=20)
plt.plot(dov_int_l, y, color="darkorange", linestyle='dotted');
plt.plot(dov_int_r, y, color="darkorange", linestyle='dotted');


# plt.fill_between(x, knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score'],
#                     knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score'], alpha=0.2,
#                     color="darkorange")
178/40:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
dov_int_l = knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score']
dov_int_r = knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score']


plt.figure(figsize = (12, 10))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
# plt.plot(x, y, marker=".", markersize=20)
plt.plot(x, dov_int_l, color="darkorange", linestyle='dotted');
plt.plot(x, dov_int_r, color="darkorange", linestyle='dotted');


# plt.fill_between(x, knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score'],
#                     knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score'], alpha=0.2,
#                     color="darkorange")
178/41:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
dov_int_l = knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score']
dov_int_r = knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score']


plt.figure(figsize = (12, 10))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
plt.plot(x, dov_int_l, color="darkorange", linestyle='dotted');
plt.plot(x, dov_int_r, color="darkorange", linestyle='dotted');


# plt.fill_between(x, knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score'],
#                     knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score'], alpha=0.2,
#                     color="darkorange")
178/42: np.random.seed(123)
178/43:
k_range = [1, 11, 13, 51, 101, 1001]
knn_params = dict(n_neighbors=k_range)

knn = KNeighborsClassifier()

knn_grid = GridSearchCV(knn, cv=5, param_grid=knn_params)
knn_grid.fit(X_num, y)

print('best score:', knn_grid.best_score_)
print('best params:', knn_grid.best_params_)
178/44:
import numpy as np
import pandas as pd

data = pd.read_csv('./data.adult.csv')
data
178/45: data.isnull().sum()
178/46:
data = data.replace('?', np.nan)
data.shape
178/47:
data.dropna(inplace=True)
data.shape
178/48:
X = data.drop(columns='>50K,<=50K')
y = data['>50K,<=50K'].apply(lambda x: 1 if x == '>50K' else 0)
y
178/49:
numericData = data._get_numeric_data()
X_num = numericData
numericData.head()
178/50:
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import KFold
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import PolynomialFeatures, StandardScaler
from category_encoders.leave_one_out import LeaveOneOutEncoder

from sklearn import model_selection
from sklearn.pipeline import Pipeline
import matplotlib.pyplot as plt
178/51: np.random.seed(123)
178/52:
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import KFold
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import PolynomialFeatures, StandardScaler
from category_encoders.leave_one_out import LeaveOneOutEncoder

from sklearn import model_selection
from sklearn.pipeline import Pipeline
import matplotlib.pyplot as plt
178/53: np.random.seed(123)
178/54:
k_range = [1, 11, 13, 51, 101, 1001]
knn_params = dict(n_neighbors=k_range)

knn = KNeighborsClassifier()

knn_grid = GridSearchCV(knn, cv=5, param_grid=knn_params)
knn_grid.fit(X_num, y)

print('best score:', knn_grid.best_score_)
print('best params:', knn_grid.best_params_)
178/55:
k_range = [1, 11, 13, 51, 101, 1001]
knn_params = dict(n_neighbors=k_range)

knn = KNeighborsClassifier()

knn_grid = GridSearchCV(knn, cv=5, param_grid=knn_params)
knn_grid.fit(X_num, y)

print('best score:', knn_grid.best_score_)
print('best params:', knn_grid.best_params_)
178/56:
k_range = [1, 11, 13, 51, 101, 1001]
knn_params = dict(n_neighbors=k_range)

knn = KNeighborsClassifier()

knn_grid = GridSearchCV(knn, cv=5, param_grid=knn_params)
knn_grid.fit(X_num, y)

print('best score:', knn_grid.best_score_)
print('best params:', knn_grid.best_params_)
178/57:
sgd_params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=sgd_params)
grid_sgd.fit(X_num, y)

print('best score:', grid_sgd.best_score_)
print('best params:', grid_sgd.best_params_)
178/58:
sgd_params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=sgd_params)
grid_sgd.fit(X_num, y)

print('best score:', grid_sgd.best_score_)
print('best params:', grid_sgd.best_params_)
178/59:
sgd_params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=sgd_params)
grid_sgd.fit(X_num, y)

print('best score:', grid_sgd.best_score_)
print('best params:', grid_sgd.best_params_)
178/60:
np.random.seed(123)
sgd_params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=sgd_params)
grid_sgd.fit(X_num, y)

print('best score:', grid_sgd.best_score_)
print('best params:', grid_sgd.best_params_)
178/61:
np.random.seed(123)
sgd_params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=sgd_params)
grid_sgd.fit(X_num, y)

print('best score:', grid_sgd.best_score_)
print('best params:', grid_sgd.best_params_)
178/62:
np.random.seed(123)
sgd_params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=sgd_params)
grid_sgd.fit(X_num, y)

print('best score:', grid_sgd.best_score_)
print('best params:', grid_sgd.best_params_)
178/63:
x = sgd_params['loss']
y = sgd_params.cv_results_['mean_test_score'] 
dov_int_l = sgd_params.cv_results_['mean_test_score'] - sgd_params.cv_results_['std_test_score']
dov_int_r = sgd_params.cv_results_['mean_test_score'] + sgd_params.cv_results_['std_test_score']


plt.figure(figsize = (12, 10))

plt.grid()
plt.title("SGD params") 
plt.xlabel("loss function") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
plt.plot(x, dov_int_l, color="darkorange", linestyle='dotted');
plt.plot(x, dov_int_r, color="darkorange", linestyle='dotted');
178/64:
x = sgd_params['loss']
y = grid_sgd.cv_results_['mean_test_score'] 
dov_int_l = grid_sgd.cv_results_['mean_test_score'] - grid_sgd.cv_results_['std_test_score']
dov_int_r = grid_sgd.cv_results_['mean_test_score'] + grid_sgd.cv_results_['std_test_score']


plt.figure(figsize = (12, 10))

plt.grid()
plt.title("SGD params") 
plt.xlabel("loss function") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
plt.plot(x, dov_int_l, color="darkorange", linestyle='dotted');
plt.plot(x, dov_int_r, color="darkorange", linestyle='dotted');
178/65:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
dov_int_l = knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score']
dov_int_r = knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score']


plt.figure(figsize = (12, 10))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
plt.plot(x, dov_int_l, color="darkorange", linestyle='dotted');
plt.plot(x, dov_int_r, color="darkorange", linestyle='dotted');
178/66:
k_range = [1, 11, 13, 17, 51, 101, 1001]
knn_params = dict(n_neighbors=k_range)

knn = KNeighborsClassifier()

knn_grid = GridSearchCV(knn, cv=5, param_grid=knn_params)
knn_grid.fit(X_num, y)

print('best score:', knn_grid.best_score_)
print('best params:', knn_grid.best_params_)
178/67:
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import KFold
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import PolynomialFeatures, StandardScaler
from category_encoders.leave_one_out import LeaveOneOutEncoder

from sklearn import model_selection
from sklearn.pipeline import Pipeline
import matplotlib.pyplot as plt
178/68: np.random.seed(123)
178/69:
import numpy as np
import pandas as pd

data = pd.read_csv('./data.adult.csv')
data
178/70: data.isnull().sum()
178/71:
data = data.replace('?', np.nan)
data.shape
178/72:
data.dropna(inplace=True)
data.shape
178/73:
X = data.drop(columns='>50K,<=50K')
y = data['>50K,<=50K'].apply(lambda x: 1 if x == '>50K' else 0)
y
178/74:
numericData = data._get_numeric_data()
X_num = numericData
numericData.head()
178/75:
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import KFold
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import PolynomialFeatures, StandardScaler
from category_encoders.leave_one_out import LeaveOneOutEncoder

from sklearn import model_selection
from sklearn.pipeline import Pipeline
import matplotlib.pyplot as plt
178/76: np.random.seed(123)
178/77:
k_range = [1, 11, 13, 17, 51, 101, 1001]
knn_params = dict(n_neighbors=k_range)

knn = KNeighborsClassifier()

knn_grid = GridSearchCV(knn, cv=5, param_grid=knn_params)
knn_grid.fit(X_num, y)

print('best score:', knn_grid.best_score_)
print('best params:', knn_grid.best_params_)
178/78:
np.random.seed(123)
sgd_params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=sgd_params)
grid_sgd.fit(X_num, y)

print('best score:', grid_sgd.best_score_)
print('best params:', grid_sgd.best_params_)
178/79:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
dov_int_l = knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score']
dov_int_r = knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score']


plt.figure(figsize = (12, 10))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
plt.plot(x, dov_int_l, color="darkorange", linestyle='dotted');
plt.plot(x, dov_int_r, color="darkorange", linestyle='dotted');
178/80:
x = sgd_params['loss']
y = grid_sgd.cv_results_['mean_test_score'] 
dov_int_l = grid_sgd.cv_results_['mean_test_score'] - grid_sgd.cv_results_['std_test_score']
dov_int_r = grid_sgd.cv_results_['mean_test_score'] + grid_sgd.cv_results_['std_test_score']


plt.figure(figsize = (12, 10))

plt.grid()
plt.title("SGD params") 
plt.xlabel("loss function") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
plt.plot(x, dov_int_l, color="darkorange", linestyle='dotted');
plt.plot(x, dov_int_r, color="darkorange", linestyle='dotted');
178/81:
from sklearn.linear_model import LogisticRegression
np.random.seed(123)
sgd_params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=sgd_params)
grid_sgd.fit(X_num, y)

print('best score:', grid_sgd.best_score_)
print('best params:', grid_sgd.best_params_)
178/82:
import numpy as np
import pandas as pd

data = pd.read_csv('./data.adult.csv')
data
178/83: data.isnull().sum()
178/84:
data = data.replace('?', np.nan)
data.shape
178/85:
data.dropna(inplace=True)
data.shape
178/86:
X = data.drop(columns='>50K,<=50K')
y = data['>50K,<=50K'].apply(lambda x: 1 if x == '>50K' else 0)
y
178/87:
numericData = data._get_numeric_data()
X_num = numericData
numericData.head()
178/88:
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import KFold
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import PolynomialFeatures, StandardScaler
from category_encoders.leave_one_out import LeaveOneOutEncoder

from sklearn import model_selection
from sklearn.pipeline import Pipeline
import matplotlib.pyplot as plt
178/89: np.random.seed(123)
178/90:
import numpy as np
import pandas as pd

data = pd.read_csv('./data.adult.csv')
data
178/91: data.isnull().sum()
178/92:
data = data.replace('?', np.nan)
data.shape
178/93:
data.dropna(inplace=True)
data.shape
178/94:
X = data.drop(columns='>50K,<=50K')
y = data['>50K,<=50K'].apply(lambda x: 1 if x == '>50K' else 0)
y
178/95:
numericData = data._get_numeric_data()
X_num = numericData
numericData.head()
178/96:
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import KFold
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import PolynomialFeatures, StandardScaler
from category_encoders.leave_one_out import LeaveOneOutEncoder

from sklearn import model_selection
from sklearn.pipeline import Pipeline
import matplotlib.pyplot as plt
178/97: np.random.seed(123)
178/98:
k_range = [1, 11, 13, 17, 19, 21, 51, 101, 1001]
knn_params = dict(n_neighbors=k_range)

knn = KNeighborsClassifier()

knn_grid = GridSearchCV(knn, cv=5, param_grid=knn_params)
knn_grid.fit(X_num, y)

print('best score:', knn_grid.best_score_)
print('best params:', knn_grid.best_params_)
178/99:
np.random.seed(123)
sgd_params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=sgd_params)
grid_sgd.fit(X_num, y)

print('best score:', grid_sgd.best_score_)
print('best params:', grid_sgd.best_params_)
178/100:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
dov_int_l = knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score']
dov_int_r = knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score']


plt.figure(figsize = (12, 10))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
plt.plot(x, dov_int_l, color="darkorange", linestyle='dotted');
plt.plot(x, dov_int_r, color="darkorange", linestyle='dotted');
178/101:
x = sgd_params['loss']
y = grid_sgd.cv_results_['mean_test_score'] 
dov_int_l = grid_sgd.cv_results_['mean_test_score'] - grid_sgd.cv_results_['std_test_score']
dov_int_r = grid_sgd.cv_results_['mean_test_score'] + grid_sgd.cv_results_['std_test_score']


plt.figure(figsize = (12, 10))

plt.grid()
plt.title("SGD params") 
plt.xlabel("loss function") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
plt.plot(x, dov_int_l, color="darkorange", linestyle='dotted');
plt.plot(x, dov_int_r, color="darkorange", linestyle='dotted');
178/102:
from sklearn.linear_model import LogisticRegression
np.random.seed(123)
sgd_params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=sgd_params)
grid_sgd.fit(X_num, y)

print('best score:', grid_sgd.best_score_)
print('best params:', grid_sgd.best_params_)
178/103:
k_range = [1, 11, 13, 17, 19, 21, 51, 101]
knn_params = dict(n_neighbors=k_range)

knn = KNeighborsClassifier()

knn_grid = GridSearchCV(knn, cv=5, param_grid=knn_params)
knn_grid.fit(X_num, y)

print('best score:', knn_grid.best_score_)
print('best params:', knn_grid.best_params_)
178/104:
import numpy as np
import pandas as pd

data = pd.read_csv('./data.adult.csv')
data
178/105: data.isnull().sum()
178/106:
data = data.replace('?', np.nan)
data.shape
178/107:
data.dropna(inplace=True)
data.shape
178/108:
X = data.drop(columns='>50K,<=50K')
y = data['>50K,<=50K'].apply(lambda x: 1 if x == '>50K' else 0)
y
178/109:
numericData = data._get_numeric_data()
X_num = numericData
numericData.head()
178/110:
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import KFold
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import PolynomialFeatures, StandardScaler
from category_encoders.leave_one_out import LeaveOneOutEncoder

from sklearn import model_selection
from sklearn.pipeline import Pipeline
import matplotlib.pyplot as plt
178/111: np.random.seed(123)
178/112:
k_range = [1, 11, 13, 17, 19, 21, 51, 101]
knn_params = dict(n_neighbors=k_range)

knn = KNeighborsClassifier()

knn_grid = GridSearchCV(knn, cv=5, param_grid=knn_params)
knn_grid.fit(X_num, y)

print('best score:', knn_grid.best_score_)
print('best params:', knn_grid.best_params_)
178/113:
np.random.seed(123)
sgd_params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=sgd_params)
grid_sgd.fit(X_num, y)

print('best score:', grid_sgd.best_score_)
print('best params:', grid_sgd.best_params_)
178/114:
x = k_range
y = knn_grid.cv_results_['mean_test_score'] 
dov_int_l = knn_grid.cv_results_['mean_test_score'] - knn_grid.cv_results_['std_test_score']
dov_int_r = knn_grid.cv_results_['mean_test_score'] + knn_grid.cv_results_['std_test_score']


plt.figure(figsize = (12, 10))

plt.grid()
plt.title("KNN params") 
plt.xlabel("n_neighbours") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
plt.plot(x, dov_int_l, color="darkorange", linestyle='dotted');
plt.plot(x, dov_int_r, color="darkorange", linestyle='dotted');
178/115:
x = sgd_params['loss']
y = grid_sgd.cv_results_['mean_test_score'] 
dov_int_l = grid_sgd.cv_results_['mean_test_score'] - grid_sgd.cv_results_['std_test_score']
dov_int_r = grid_sgd.cv_results_['mean_test_score'] + grid_sgd.cv_results_['std_test_score']


plt.figure(figsize = (12, 10))

plt.grid()
plt.title("SGD params") 
plt.xlabel("loss function") 
plt.ylabel("score") 
plt.plot(x, y, marker=".", markersize=20)
plt.plot(x, dov_int_l, color="darkorange", linestyle='dotted');
plt.plot(x, dov_int_r, color="darkorange", linestyle='dotted');
178/116:
from sklearn.linear_model import LogisticRegression
np.random.seed(123)
sgd_params = {
    "loss" : ["hinge", "log", "squared_hinge", "modified_huber"],
}
sgd = SGDClassifier(max_iter=10000, tol=1e-3)

grid_sgd = GridSearchCV(sgd, cv=5, param_grid=sgd_params)
grid_sgd.fit(X_num, y)

print('best score:', grid_sgd.best_score_)
print('best params:', grid_sgd.best_params_)
178/117:
from sklearn.linear_model import LogisticRegression
c_range = [1, 11, 13, 17, 19, 21, 51, 101]
lr_params = dict(C=c_range)

lr = LogisticRegression()

lr_grid = GridSearchCV(lr, cv=5, param_grid=lr_params)
lr_grid.fit(X_num, y)

print('best score:', lr_grid.best_score_)
print('best params:', lr_grid.best_params_)
178/118:
import numpy as np
import pandas as pd

data = pd.read_csv('./data.adult.csv')
data
178/119: data.isnull().sum()
178/120:
data = data.replace('?', np.nan)
data.shape
178/121:
data.dropna(inplace=True)
data.shape
178/122:
X = data.drop(columns='>50K,<=50K')
y = data['>50K,<=50K'].apply(lambda x: 1 if x == '>50K' else 0)
y
178/123:
numericData = data._get_numeric_data()
X_num = numericData
numericData.head()
178/124:
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import KFold
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import PolynomialFeatures, StandardScaler
from category_encoders.leave_one_out import LeaveOneOutEncoder

from sklearn import model_selection
from sklearn.pipeline import Pipeline
import matplotlib.pyplot as plt
178/125:
from sklearn.linear_model import LogisticRegression
c_range = [1, 11, 13, 17, 19, 21, 51, 101]
lr_params = dict(C=c_range)

lr = LogisticRegression()

lr_grid = GridSearchCV(lr, cv=5, param_grid=lr_params)
lr_grid.fit(X_num, y)

print('best score:', lr_grid.best_score_)
print('best params:', lr_grid.best_params_)
178/126:
from sklearn.linear_model import LogisticRegression
c_range = [0.01, 0.05, 1, 3, 11, 51, 101, 1000]
lr_params = dict(C=c_range)

lr = LogisticRegression()

lr_grid = GridSearchCV(lr, cv=5, param_grid=lr_params)
lr_grid.fit(X_num, y)

print('best score:', lr_grid.best_score_)
print('best params:', lr_grid.best_params_)
178/127:
from sklearn.linear_model import LogisticRegression
c_range = [0.01, 0.05, 1, 3, 11, 51, 101, 1000]
lr_params = dict(C=c_range)

lr = LogisticRegression()

lr_grid = GridSearchCV(lr, cv=5, param_grid=lr_params)
lr_grid.fit(X_num, y)

print('best score:', lr_grid.best_score_)
print('best params:', lr_grid.best_params_)
178/128:
from sklearn.linear_model import LogisticRegression
np.random.seed(123)
c_range = [0.01, 0.05, 1, 3, 11, 51, 101, 1000]
lr_params = dict(C=c_range)

lr = LogisticRegression()

lr_grid = GridSearchCV(lr, cv=5, param_grid=lr_params)
lr_grid.fit(X_num, y)

print('best score:', lr_grid.best_score_)
print('best params:', lr_grid.best_params_)
178/129:
from sklearn.svm import SVC
np.random.seed(123)

svc_range = [0.01, 0.05, 1, 3, 10, 100, 1000]
svc_params = dict(C=c_range)

svc = SVC(kernel = 'linear')

svc_grid = GridSearchCV(svc, cv=5, param_grid=svc_params)
svc_grid.fit(X_num, y)

print('best score:', svc_grid.best_score_)
print('best params:', svc_grid.best_params_)
179/1:
import numpy as np
import pandas as pd

data = pd.read_csv('./data.adult.csv')
data
179/2:
data = data.replace('?', np.nan)
data.shape
179/3:
data.dropna(inplace=True)
data.shape
179/4:
X = data.drop(columns='>50K,<=50K')
y = data['>50K,<=50K'].apply(lambda x: 1 if x == '>50K' else 0)
y
179/5:
numericData = data._get_numeric_data()
X_num = numericData
numericData.head()
179/6:
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import KFold
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import PolynomialFeatures, StandardScaler
from category_encoders.leave_one_out import LeaveOneOutEncoder

from sklearn import model_selection
from sklearn.pipeline import Pipeline
import matplotlib.pyplot as plt
179/7: np.random.seed(123)
179/8:
from sklearn.linear_model import LogisticRegression
np.random.seed(123)
c_range = [0.01, 0.05, 1, 3, 11, 51, 101, 1000]
lr_params = dict(C=c_range)

lr = LogisticRegression()

lr_grid = GridSearchCV(lr, cv=5, param_grid=lr_params)
lr_grid.fit(X_num, y)

print('best score:', lr_grid.best_score_)
print('best params:', lr_grid.best_params_)
179/9:
from sklearn.svm import SVC
np.random.seed(123)

svc_range = [0.01, 1, 10, 100, 1000]
svc_params = dict(C=svc_range)

svc = SVC(kernel='linear')

svc_grid = GridSearchCV(svc, cv=5, param_grid=svc_params)
svc_grid.fit(X_num, y)

print('best score:', svc_grid.best_score_)
print('best params:', svc_grid.best_params_)
180/1:
import numpy as np
import pandas as pd

data = pd.read_csv('./data.adult.csv')
data
180/2: data.isnull().sum()
180/3:
data = data.replace('?', np.nan)
data.shape
180/4:
data.dropna(inplace=True)
data.shape
180/5:
X = data.drop(columns='>50K,<=50K')
y = data['>50K,<=50K'].apply(lambda x: 1 if x == '>50K' else 0)
y
180/6:
numericData = data._get_numeric_data()
X_num = numericData
numericData.head()
180/7:
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import KFold
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import PolynomialFeatures, StandardScaler
from category_encoders.leave_one_out import LeaveOneOutEncoder

from sklearn import model_selection
from sklearn.pipeline import Pipeline
import matplotlib.pyplot as plt
180/8: np.random.seed(123)
180/9:
from sklearn.linear_model import LogisticRegression
np.random.seed(123)
c_range = [0.01, 0.05, 1, 3, 11, 51, 101, 1000]
lr_params = dict(C=c_range)

lr = LogisticRegression()

lr_grid = GridSearchCV(lr, cv=5, param_grid=lr_params, n_jobs=3)
lr_grid.fit(X_num, y)

print('best score:', lr_grid.best_score_)
print('best params:', lr_grid.best_params_)
180/10:
from sklearn.svm import SVC
np.random.seed(123)

svc_range = [0.01, 1, 10, 100, 1000]
svc_params = dict(C=svc_range)

svc = SVC(kernel='linear')

svc_grid = GridSearchCV(svc, cv=5, param_grid=svc_params, n_jobs=3)
svc_grid.fit(X_num, y)

print('best score:', svc_grid.best_score_)
print('best params:', svc_grid.best_params_)
184/1:
theta = stats.uniform.rvs(10, 10, random_state=300)
uniform_rv = stats.uniform(0, theta)
theta
184/2:
import numpy as np
import pandas as pd

from scipy import stats

import seaborn as sns
import matplotlib.pyplot as plt

plt.style.use('ggplot')
184/3:
theta = stats.uniform.rvs(10, 10, random_state=300)
uniform_rv = stats.uniform(0, theta)
theta
184/4:
theta = stats.uniform.rvs(10, 10, random_state=300)
uniform_rv = stats.uniform(0, theta)
theta
184/5:
theta = stats.uniform.rvs(10, 10, random_state=1000)
uniform_rv = stats.uniform(0, theta)
theta
184/6:
n = 100
M = 1000
samples = uniform_rv.rvs(size = (n, M))
samples.shape
184/7:
theta = stats.uniform.rvs(10, 10, random_state=10)
uniform_rv = stats.uniform(0, theta)
theta
184/8:
n = 100
M = 1000
samples = uniform_rv.rvs(size = (n, M))
samples.shape
184/9:
# mm
theta1 = 2*np.mean(samples, axis=0)

# ml
theta2 = (n + 1)/n*np.max(samples, axis=0)
184/10: theta1.mean(), theta2.mean()
184/11: theta1
184/12:
plt.figure(figsize=(12,6))

plt.hist(theta1, alpha=0.5, label='Moment method')
plt.hist(theta2, alpha=0.5, label='ML method')
plt.legend();
184/13:
# ml
delta2 = theta2 - theta
MSE2 = np.mean(np.power(delta2, 2))
print(MSE2)

# mm
delta1 = theta1 - theta
MSE1 = np.mean(np.power(delta1, 2))
print(MSE1)

#  у оценки максимального правдоподобия разброс оказался меньше
184/14:
# ml
delta2 = theta2 - theta
MSE2 = np.mean(np.power(delta2, 2))
print(MSE2)

# mm
delta1 = theta1 - theta
MSE1 = np.mean(np.power(delta1, 2))
print(MSE1)

#  у оценки максимального правдоподобия разброс оказался меньше
184/15:
alpha = 0.05

ml_intervals = []

for sample in samples:
    theta_ml = np.max(sample, axis=0)
    n = sample.size

    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals.append((left, right))
184/16:
alpha = 0.05

ml_intervals = []

for sample in samples:
    theta_ml = np.max(sample, axis=0)
    n = sample.size

    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals.append((left, right))
    
ml_intervals
184/17:
# точный дов интервал для ml оценки для параметра  𝜃  уровня доверия  (1−𝛼)  с помощью оценки  max(𝑋1,...,𝑋𝑛)

alpha = 0.05

theta_ml = np.max(sample, axis=0)
n = sample.size

left = theta_ml
right = theta_ml / np.power(alpha,(1/n))

print("Точный доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
184/18:
theta = stats.uniform.rvs(10, 10, random_state=100)
uniform_rv = stats.uniform(0, theta)
theta
184/19:
n = 50
sample = uniform_rv.rvs(n)
sample.shape
184/20:
# точный дов интервал для ml оценки для параметра  𝜃  уровня доверия  (1−𝛼)  с помощью оценки  max(𝑋1,...,𝑋𝑛)

alpha = 0.05

theta_ml = np.max(sample, axis=0)
n = sample.size

left = theta_ml
right = theta_ml / np.power(alpha,(1/n))

print("Точный доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
184/21:
# асимптотический дов интервал для mm оценки  𝜃=2𝑋

alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

doubled_mean = 2*sample.mean()
n = sample.size
margin = z_crit/(n*np.sqrt(3))
left = doubled_mean / (1 + margin)
right = doubled_mean / (1 - margin)

print("Асимпт доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
184/22:
alpha = 0.05

ml_intervals = []

for sample in samples:
    theta_ml = np.max(sample, axis=0)
    print(theta_ml)
    n = sample.size

    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals.append((left, right))
    
# ml_intervals
184/23:
alpha = 0.05

ml_intervals = []

for sample in samples:
    theta_ml = np.max(sample, axis=1)
    print(theta_ml)
    n = sample.size

    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals.append((left, right))
    
# ml_intervals
184/24:
alpha = 0.05

ml_intervals = []

for sample in samples:
    theta_ml = np.max(sample, axis=0)
    print(theta_ml)
    n = sample.size

    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals.append((left, right))
    
# ml_intervals
184/25:
# mm
theta1 = 2*np.mean(samples, axis=0)

# ml
theta2 = (n + 1)/n*np.max(samples, axis=0)
184/26: theta1
184/27: theta1.shape
184/28:
theta = stats.uniform.rvs(10, 10, random_state=1000)
uniform_rv = stats.uniform(0, theta)
theta
184/29:
n = 100
M = 1000
samples = uniform_rv.rvs(size = (n, M))
samples.shape
184/30: samples
184/31:
for sample in samples:
    print(sample)
184/32:
for sample in samples:
    print(np.max(sample, axis=0)
184/33:
for sample in samples:
    print(np.max(sample, axis=0))
184/34:
alpha = 0.05

ml_intervals = []

for sample in samples:
    theta_ml = np.max(sample, axis=0)
    n = sample.size

    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals.append((left, right))
    
ml_intervals
184/35:
alpha = 0.05

ml_intervals = []

for sample in samples:
    theta_ml = np.max(sample, axis=0)
    n = sample.size

    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals.append((left, right))
184/36:
alpha = 0.05

ml_intervals_corr = []

for sample in samples:
    theta_ml = (n + 1)/n*np.max(sample, axis=0)
    n = sample.size
    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals_corr.append((left, right))
ml_intervals_corr
184/37:
alpha = 0.05

ml_intervals_corr = []

for sample in samples:
    theta_ml = (n + 1)/n*np.max(sample, axis=0)
    n = sample.size
    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals_corr.append((left, right))
184/38:
alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mm_intervals = []

for sample in samples:
    doubled_mean = 2*sample.mean()
    n = sample.size
    margin = z_crit/(n*np.sqrt(3))
    left = doubled_mean / (1 + margin)
    right = doubled_mean / (1 - margin)
    mm_intervals.append((left, right))
184/39:
ml_intervals_check = 0
for interval in ml_intervals:
    if theta >= interval[0] and theta <=interval[1]:
        ml_intervals_chml_intervals_correck += 1
184/40:
# частота  покрытия ml
ml_intervals_check = 0
for interval in ml_intervals:
    if theta >= interval[0] and theta <=interval[1]:
        ml_intervals_check += 1
184/41:
# частота  покрытия ml
ml_intervals_check = 0
for interval in ml_intervals:
    if theta >= interval[0] and theta <=interval[1]:
        ml_intervals_check += 1
    ml_intervals_check
184/42:
# частота  покрытия ml
ml_intervals_check = 0
for interval in ml_intervals:
    if theta >= interval[0] and theta <=interval[1]:
        ml_intervals_check += 1
ml_intervals_check
184/43:
ml_intervals_corr_check = 0
for interval in ml_intervals_corr:
    if theta >= interval[0] and theta <=interval[1]:
        ml_intervals_corr_check += 1
ml_intervals_corr_check
184/44:
mm_intervals_check = 0
for interval in mm_intervals:
    if theta >= interval[0] and theta <=interval[1]:
        mm_intervals_check += 1
mm_intervals_check
184/45:
# частота  покрытия ml
ml_intervals_check = 0
for interval in ml_intervals:
    print(interval)
    if theta >= interval[0] and theta <=interval[1]:
        ml_intervals_check += 1
ml_intervals_check
184/46:
# частота  покрытия ml
print(theta)
ml_intervals_check = 0
for interval in ml_intervals:
    print(interval)
    if theta >= interval[0] and theta <=interval[1]:
        ml_intervals_check += 1
ml_intervals_check
184/47:
# частота  покрытия ml
print(theta)
ml_intervals_check = 0
for interval in ml_intervals:
    print(interval)
    if round(theta,4) >= interval[0] and round(theta,4) <=interval[1]:
        ml_intervals_check += 1
ml_intervals_check
184/48:
# частота  покрытия ml
print(theta)
ml_intervals_check = 0
for interval in ml_intervals:
    print(interval)
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_check += 1
ml_intervals_check
184/49:
# частота  покрытия ml
print(theta)
ml_intervals_check = 0
for interval in ml_intervals:
    print(interval)
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_check += 1
# ml_intervals_check
184/50:
# частота  покрытия ml
print(theta)
ml_intervals_check = 0
for interval in ml_intervals:
    print(interval)
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_check += 1
# ml_intervals_check
184/51:
# частота  покрытия ml
print(theta)
ml_intervals_check = 0
for interval in ml_intervals:
    print(interval)
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_check += 1
# ml_intervals_check
184/52:
# частота  покрытия ml
print(theta)
ml_intervals_check = 0
for interval in ml_intervals:
#     print(interval)
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_check += 1
# ml_intervals_check
184/53:
# частота  покрытия ml
print(theta)
ml_intervals_check = 0
for interval in ml_intervals:
    print(round(theta,4) >= round(interval[0], 4))
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_check += 1
# ml_intervals_check
184/54:
# частота  покрытия ml
print(theta)
ml_intervals_check = 0
for interval in ml_intervals:
    print(ound(theta,4) <= round(interval[1],4))
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_check += 1
# ml_intervals_check
184/55:
# частота  покрытия ml
print(theta)
ml_intervals_check = 0
for interval in ml_intervals:
    print(round(theta,4) <= round(interval[1],4))
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_check += 1
# ml_intervals_check
184/56:
# частота  покрытия ml
print(theta)
ml_intervals_check = 0
for interval in ml_intervals:
    print(round(theta,4) <= round(interval[1],4))
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_check += 1
# ml_intervals_check
184/57:
# частота  покрытия ml
print(theta)
ml_intervals_check = 0
for interval in ml_intervals:
    print(round(theta,4) <= round(interval[1],4))
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_check += 1
ml_intervals_check
184/58:
# частота  покрытия ml
print(theta)
ml_intervals_check = 0
for interval in ml_intervals:
#     print(round(theta,4) <= round(interval[1],4))
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_check += 1
ml_intervals_check
184/59:
# частота  покрытия ml
print(theta)
ml_intervals_check = 0
for interval in ml_intervals:
#     print(round(theta,4) <= round(interval[1],4))
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_check += 1
print(ml_intervals_check)
print('ml_intervals', ml_intervals.size)
184/60:
# частота  покрытия ml
print(theta)
ml_intervals_check = 0
for interval in ml_intervals:
#     print(round(theta,4) <= round(interval[1],4))
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_check += 1
print(ml_intervals_check)
print('ml_intervals', len(ml_intervals))
184/61:
# частота  покрытия ml
ml_intervals_check = 0
for interval in ml_intervals:
#     print(round(theta,4) <= round(interval[1],4))
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_check += 1
print('уровень покрытия', ml_intervals_check/len(ml_intervals))
184/62:
# частота  покрытия ml
ml_intervals_check = 0
for interval in ml_intervals:
#     print(round(theta,4) <= round(interval[1],4))
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_check += 1
print('уровень покрытия', ml_intervals_check/len(ml_intervals))
print('уровень альфа', 1-alpha)
184/63:
# частота  покрытия ml с корректировкой
ml_intervals_corr_check = 0
for interval in ml_intervals_corr:
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_corr_check += 1
ml_intervals_corr_check
184/64:
# частота  покрытия ml с корректировкой
ml_intervals_corr_check = 0
for interval in ml_intervals_corr:
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_corr_check += 1
ml_intervals_corr_check
184/65:
alpha = 0.05

ml_intervals_corr = []

for sample in samples:
    theta_ml = (n + 1)*np.max(sample, axis=0)/n
    n = sample.size
    left = theta_ml
    right = theta_ml / np.power(alpha,(1/n))
    ml_intervals_corr.append((left, right))
184/66:
# частота  покрытия ml с корректировкой
ml_intervals_corr_check = 0
for interval in ml_intervals_corr:
    round(theta,4) >= round(interval[0], 4)
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_corr_check += 1
print('уровень покрытия', ml_intervals_check/len(ml_intervals))
print('уровень альфа', 1-alpha)
184/67:
# частота  покрытия ml с корректировкой
ml_intervals_corr_check = 0
for interval in ml_intervals_corr:
    round(theta,4) >= round(interval[0], 4)
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_corr_check += 1
print('уровень покрытия', ml_intervals_corr_check/len(ml_intervals_corr))
print('уровень альфа', 1-alpha)
184/68: ml_intervals_corr
184/69:
theta
ml_intervals_corr
184/70:
print('theta', theta)
ml_intervals_corr
184/71:
# частота  покрытия ml с корректировкой
ml_intervals_corr_check = 0
for interval in ml_intervals_corr:
    print(round(theta,4) >= round(interval[0], 4) )
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_corr_check += 1
print('уровень покрытия', ml_intervals_corr_check/len(ml_intervals_corr))
print('уровень альфа', 1-alpha)
184/72:
# частота  покрытия ml с корректировкой
ml_intervals_corr_check = 0
for interval in ml_intervals_corr:
    print(round(theta,4) >= round(interval[0], 4) )
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_corr_check += 1
print('уровень покрытия', ml_intervals_corr_check/len(ml_intervals_corr))
184/73:
# частота  покрытия ml с корректировкой
ml_intervals_corr_check = 0
for interval in ml_intervals_corr:
    print(round(theta,4) >= round(interval[0], 4) )
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_corr_check += 1
print('уровень покрытия', ml_intervals_corr_check/len(ml_intervals_corr))
184/74:
# частота  покрытия ml с корректировкой
ml_intervals_corr_check = 0
for interval in ml_intervals_corr:
    print(round(theta,4) >= round(interval[0], 4) )
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_corr_check += 1
print('уровень покрытия', ml_intervals_corr_check/len(ml_intervals_corr))
184/75:
# частота  покрытия ml с корректировкой
ml_intervals_corr_check = 0
for interval in ml_intervals_corr:
    print(round(theta,4) >= round(interval[0], 4) )
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_corr_check += 1
print('уровень покрытия', ml_intervals_corr_check/len(ml_intervals_corr))
184/76:
# частота  покрытия ml с корректировкой
ml_intervals_corr_check = 0
for interval in ml_intervals_corr:
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_corr_check += 1
print('уровень покрытия', ml_intervals_corr_check/len(ml_intervals_corr))
184/77:
# частота  покрытия mm
mm_intervals_check = 0
for interval in mm_intervals:
    if theta >= interval[0] and theta <=interval[1]:
        mm_intervals_check += 1
print('уровень покрытия', mm_intervals_check/len(mm_intervals_check)
184/78:
alpha = 0.05
z_crit = uniform_rv.ppf(1 - alpha/2)

mm_intervals = []

for sample in samples:
    doubled_mean = 2*sample.mean()
    n = sample.size
    margin = z_crit/(n*np.sqrt(3))
    left = doubled_mean / (1 + margin)
    right = doubled_mean / (1 - margin)
    mm_intervals.append((left, right))
184/79:
# частота  покрытия mm
mm_intervals_check = 0
for interval in mm_intervals:
    if theta >= interval[0] and theta <=interval[1]:
        mm_intervals_check += 1
print('уровень покрытия', mm_intervals_check/len(mm_intervals_check)
184/80:
# частота  покрытия ml с корректировкой
ml_intervals_corr_check = 0
for interval in ml_intervals_corr:
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_corr_check += 1
print('уровень покрытия', ml_intervals_corr_check/len(ml_intervals_corr))
184/81:
# частота  покрытия ml с корректировкой
ml_intervals_corr_check = 0
for interval in ml_intervals_corr:
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_corr_check += 1
print('уровень покрытия', ml_intervals_corr_check/len(ml_intervals_corr))
184/82:
# частота  покрытия ml с корректировкой
ml_intervals_corr_check = 0
for interval in ml_intervals_corr:
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        ml_intervals_corr_check += 1

print('уровень покрытия', ml_intervals_corr_check/len(ml_intervals_corr))
184/83:
# частота  покрытия mm
mm_intervals_check = 0
for interval in mm_intervals:
    if theta >= interval[0] and theta <=interval[1]:
        mm_intervals_check += 1
print('уровень покрытия', mm_intervals_check/len(mm_intervals_check)
184/84:
# частота  покрытия mm
mm_intervals_check = 0
for interval in mm_intervals:
    if theta >= interval[0] and theta <=interval[1]:
        mm_intervals_check += 1
print('уровень покрытия', mm_intervals_check/len(mm_intervals_check)
184/85:
# частота  покрытия mm
mm_intervals_check = 0
for interval in mm_intervals:
    if theta >= interval[0] and theta <=interval[1]:
        mm_intervals_check += 1

print('уровень покрытия', mm_intervals_check/len(mm_intervals_check)
184/86:
# частота  покрытия mm
mm_intervals_check = 0
for interval in mm_intervals:
    if theta >= interval[0] and theta <=interval[1]:
        mm_intervals_check += 1

print('уровень покрытия', mm_intervals_check/len(mm_intervals_check))
184/87:
# частота  покрытия mm
mm_intervals_check = 0
for interval in mm_intervals:
    if theta >= interval[0] and theta <=interval[1]:
        mm_intervals_check += 1

print('уровень покрытия', mm_intervals_check/len(mm_intervals))
184/88:
# частота  покрытия mm
mm_intervals_check = 0
for interval in mm_intervals:
    if round(theta,4) >= round(interval[0], 4) and round(theta,4) <= round(interval[1],4):
        mm_intervals_check += 1

print('уровень покрытия', mm_intervals_check/len(mm_intervals))
185/1:
plt.figure(figsize=(12,6))
plt.hist(theta_1, bins=100, alpha=0.5, label='Moment method')
plt.hist(theta_2, bins=50, alpha=0.5, label='ML method')
plt.legend();
185/2:
import numpy as np
import pandas as pd

from scipy import stats
import matplotlib.pyplot as plt
import seaborn as sns

plt.style.use('ggplot')  # стиль для графиков
%matplotlib inline
185/3:
norm_rv = stats.norm(loc=300, scale=100)

# вся генеральная совокупность 
x_mamont = norm_rv.rvs(size = 10**4)

np.mean(x_mamont) # настоящее среднее
185/4:
# Команда нам не подходит, так как она всю матрицу сделает без повторений
# np.random.choice(x_mamont, size=(n,m), replace=False)

n = 100
number_of_samples = 200

th_od = np.zeros(number_of_samples)
th_pe = np.zeros(number_of_samples)
th_ap = np.zeros(number_of_samples)

for i in range(number_of_samples):
    x_sample = np.random.choice(x_mamont, size=n, replace=False)
    x_mean = np.mean(x_sample)
    th_od[i] = x_mean
    th_pe[i] = x_mean - 4200/n
    th_ap[i] = x_mean - 5*(n+1)/n
185/5: th_od.shape
185/6:
# посмотрим на оценки E(\hat \theta)
np.mean(th_od), np.mean(th_pe), np.mean(th_ap)
185/7:
plt.figure(figsize=(12,6))

df = pd.DataFrame(zip(th_od, th_pe, th_ap), columns = ['Одэхингум', 'Пэпина', 'Апониви'])
sns.boxplot(data = df,);
185/8:
norm_rv = stats.norm(loc=300, scale=100)

# вся генеральная совокупность 
x_mamont = norm_rv.rvs(size = 10**6)

theta_real = np.mean(x_mamont) # настоящее среднее
theta_real
185/9:
theta_hat = np.zeros((100, 50))

for n in range(100, 10100, 100): # поднимаемся выше и видим больше мамонтов
    
    # 50 выборок с повторениями для простоты 
    x_sample = np.random.choice(x_mamont, size = (n, 50), replace=False)
    
    # 50 разных оценок 
    x_mean = np.mean(x_sample, axis=0) 
    
    theta_hat[n//100 - 1] = x_mean                # состоятельная, несмещенная
    #theta_hat[n//100 - 1] = (x_mean - 4200/n)     # состоятельная, несмещенная ассимптотические
    #theta_hat[n//100 - 1] = (x_mean - 5*(n+1)/n)   # несостоятельная
185/10: theta_hat.shape
185/11:
plt.figure(figsize=(14,8))
plt.plot(range(100, 10100, 100), theta_hat, c='grey', alpha = 0.3)

plt.xlabel('Количество наблюдений', size=24)
plt.ylabel('Оценка параметра', size=24)

plt.hlines(theta_real, 0, 100, color='blue', lw=4, label='реальное значение')
plt.legend(fontsize=20);
185/12: uniform_rv = stats.uniform(0, 5)
185/13:
n_obs = 100

# 1000 выборок размера n_obs
x = uniform_rv.rvs(size = (n_obs, 1000))
x.shape
185/14: np.mean(x, axis=0)
185/15:
# первая оценка 
theta_1 = 2*np.mean(x, axis=0)

# вторая оценка 
theta_2 = (n_obs + 1)/n_obs*np.max(x, axis=0)
185/16: theta_1.mean(), theta_2.mean()
185/17:
plt.figure(figsize=(12,6))
plt.hist(theta_1, bins=100, alpha=0.5, label='Moment method')
plt.hist(theta_2, bins=50, alpha=0.5, label='ML method')
plt.legend();
185/18: np.var(theta_1)
185/19: np.var(theta_2)
192/1:
df = pd.read_csv("./data/coals.csv", index_col=0)
df.head()
192/2:
import numpy as np
import pandas as pd

from scipy import stats

import seaborn as sns
import matplotlib.pyplot as plt

plt.style.use('ggplot')
192/3:
df = pd.read_csv("./data/coals.csv", index_col=0)
df.head()
192/4: df['count'].hist(bins=30);
192/5:
n_hat = df.shape[0]   # число наблюдений 
lam_hat = np.mean(df['count'])         # ваша оценка метода моментов
lam_se = np.sqrt(lam_hat/n_hat)         # ваша оценка

alpha = 0.05         # уровень значимость

norm_rv = stats.norm(loc=0, scale=1)
z = norm_rv.ppf(1-alpha/2)

left = lam_hat - z*lam_se          # левая граница дов. интервала
right = lam_hat + z*lam_se        # правая граница дов. интервала
delta = right - left         # ширина дов. интервала

print(left, right)
print('Ширина доверительного интервала', delta)
192/6: stats.norm.interval(0.95, loc=lam_hat, scale=lam_se)
192/7:
x = df[df.year <= 1900]['count']
y = df[df.year > 1900]['count']

alpha = ...

left = ...
right = ...
delta = ...

print(left, right)
192/8: x
192/9: y
192/10: df
192/11:
x = df[df.year <= 1900]['count']
y = df[df.year > 1900]['count']

alpha = 0.05

z = norm_rv.ppf(1-alpha/2)
diff = np.mean(x) - np.mean(y)
diff_se = np.sqrt(np.mean(x)/len(x) + np.mean(y)/len(y))

left = diff - z*diff_se
right = diff + z*diff_se
delta = right - left

print(left, right)
192/12:
x = df[df.year <= 1900]['count']
y = df[df.year > 1900]['count']

alpha = 0.05

z = norm_rv.ppf(1-alpha/2)
diff = np.mean(x) - np.mean(y)
diff_se = np.sqrt(np.mean(x)/len(x) + np.mean(y)/len(y))

left = diff - z*diff_se
right = diff + z*diff_se
delta = right - left

print(left, right)
# Помимо самого интервала нас интересует его ширина
print(f"Доверительный интервал [{left:.3}, {right:.3}]")
192/13:
def poiss_prob(k):
    return np.power([lam_hat], k) lam_hat^k* np.exp([-lam_hat])/k!


# проверка функции
assert np.abs(poiss_prob(1) - 0.3098761) < 1e-5
192/14:
def poiss_prob(k):
    return np.power([lam_hat], k) * np.exp([-lam_hat])/k!


# проверка функции
assert np.abs(poiss_prob(1) - 0.3098761) < 1e-5
192/15:
from scipy.special import factorial
def poiss_prob(k):
    return np.power([lam_hat], k) * np.exp([-lam_hat])/factorial([k])


# проверка функции
assert np.abs(poiss_prob(1) - 0.3098761) < 1e-5
192/16:
from scipy.special import factorial
def poiss_prob(k):
    return np.power([lam_hat], k) * np.exp([-lam_hat])/factorial([k])


# проверка функции
assert np.abs(poiss_prob(1) - 0.3098761) < 1e-5
192/17: poiss_prob(1)
192/18: poiss_prob(1)[0]
192/19:
from scipy.special import factorial
def poiss_prob(k):
    arr = np.power([lam_hat], k) * np.exp([-lam_hat])/factorial([k])
    return arr[0]

# проверка функции
assert np.abs(poiss_prob(1) - 0.3098761) < 1e-5
192/20: poiss_prob(1)[0]
192/21: poiss_prob(1)
192/22: np.abs(poiss_prob(1) - 0.3098761)
192/23: np.abs(poiss_prob(1) - 0.3098761) < 1e-5
192/24: assert np.abs(poiss_prob(1) - 0.3098761) < 1e-5
192/25:
from scipy.special import factorial
def poiss_prob(k):
    arr = np.power([lam_hat], k) * np.exp([-lam_hat])/factorial([k])
    return arr[0]

# проверка функции
assert np.abs(poiss_prob(1) - 0.3098761) > 1e-5
192/26:
from scipy.special import factorial
def poiss_prob(k):
    arr = np.power([lam_hat], k) * np.exp([-lam_hat])/factorial([k])
    return arr[0]

# проверка функции
assert np.abs(poiss_prob(1) - 0.3098761) < 1e-5
192/27: lam_se^2
192/28: np.power(lam_se, 2)
192/29: np.power(11, 2)
192/30:
from scipy.special import factorial
def poiss_prob(k):
    return np.power(lam_hat, k) * np.exp(-lam_hat)/factorial(k)

# проверка функции
assert np.abs(poiss_prob(1) - 0.3098761) < 1e-5
192/31:
alpha = 0.05

e = poiss_prob(1)
var = np.power(lam_se, 2) * np.power((- np.power(lam_hat, k) * np.exp(-lam_hat) + 
                             np.power(lam_hat, k) * np.exp(-lam_hat)*np.log(lam_hat)),2)

z = norm_rv.ppf(1-alpha/2)
left = poiss_prob(1) - z*diff_se
right = poiss_prob(1) + z*diff_se
delta = right - left


print(left, right)
192/32:
alpha = 0.05
k=1
e = poiss_prob(k)
var = np.power(lam_se, 2) * np.power((- np.power(lam_hat, k) * np.exp(-lam_hat) + 
                             np.power(lam_hat, k) * np.exp(-lam_hat)*np.log(lam_hat)),2)

z = norm_rv.ppf(1-alpha/2)
left = poiss_prob(1) - z*diff_se
right = poiss_prob(1) + z*diff_se
delta = right - left


print(left, right)
192/33:
alpha = 0.05

k=1
e = poiss_prob(k)
var = np.power(lam_se, 2) * np.power((- np.power(lam_hat, k) * np.exp(-lam_hat) + 
                             np.power(lam_hat, k) * np.exp(-lam_hat)*np.log(lam_hat)),2)

z = norm_rv.ppf(1-alpha/2)
left = poiss_prob(k) - z*var
right = poiss_prob(k) + z*var
delta = right - left


print(left, right)
192/34:
alpha = 0.05

k=1
e = poiss_prob(k)
var = np.power(lam_se, 2) * np.power((- np.power(lam_hat, k) * np.exp(-lam_hat) + 
                             np.power(lam_hat, k) * np.exp(-lam_hat)*np.log(lam_hat)),2)

z = norm_rv.ppf(1-alpha/2)
left = poiss_prob(k) - z*var
right = poiss_prob(k) + z*var
delta = right - left


print(left, right)
192/35:
alpha = 0.05

k=1
e = poiss_prob(k)
var = np.power(lam_se, 2) * np.power((- np.power(lam_hat, k) * np.exp(-lam_hat) + 
                             np.power(lam_hat, k) * np.exp(-lam_hat)*np.log(lam_hat)),2)

z = norm_rv.ppf(1-alpha/2)
left = poiss_prob(k) - z*var
right = poiss_prob(k) + z*var
delta = right - left


print(left, right)
192/36: stats.norm.interval(0.95, loc=lam_hat, scale=var)
192/37:
alpha = 0.05

k=1
e = poiss_prob(k)
var = np.power(lam_se, 2) * np.power((- np.power(lam_hat, k) * np.exp(-lam_hat) + 
                             np.power(lam_hat, k) * np.exp(-lam_hat)*np.log(lam_hat)),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(left, right)
192/38:
alpha = 0.05

k=1
e = poiss_prob(k)
var = np.power(lam_se, 2) * np.power((- np.power(lam_hat, k) * np.exp(-lam_hat) + 
                             np.power(lam_hat, k) * np.exp(-lam_hat)*np.log(lam_hat)),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(left, right)
192/39: stats.norm.interval(0.95, loc=lam_hat, scale=var)
192/40: stats.norm.interval(0.95, loc=lam_hat, scale=var)
192/41:
alpha = 0.05

k=1
e = poiss_prob(k)
var = np.power(lam_se, 2)/ k * np.power((- np.power(lam_hat, k) * np.exp(-lam_hat) + 
                             np.power(lam_hat, k) * np.exp(-lam_hat)*np.log(lam_hat)),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(left, right)
192/42: stats.norm.interval(0.95, loc=e, scale=var)
192/43:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)/ k * np.power((- np.power(lam_hat, k) * np.exp(-lam_hat) + 
                             np.power(lam_hat, k) * np.exp(-lam_hat)*np.log(lam_hat)),2)

    z = norm_rv.ppf(1-alpha/2)
    left = e - z*var
    right = e + z*var
    return left, right
192/44:
left, right = prob_ci(1)
delta = right - left

assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/45:
poiss_rv = sts.poisson(lam_hat)

x = np.arange(10)

p = poiss_rv.pmf(x)
left, right = prob_ci(x)

plt.figure(figsize=(10,5))
plt.plot(x, p, 'bo', ms=6, label='poisson pmf')
plt.fill_between(x, left, right, alpha=0.5)
plt.vlines(x, 0, p, lw=1)
plt.legend(loc='best', frameon=False)
plt.show()
192/46:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/47:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
assert np.abs(delta - 0.08147) < 1e-3


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/48:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
assert np.abs(delta - 0.08147) < 1e-2


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/49:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
assert np.abs(delta - 0.08147) < 1e-1


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/50:
left, right = prob_ci(1)
delta = right - left

# assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/51: factorial(0)
192/52:
alpha = 0.05

k=1
e = poiss_prob(k)
var = np.power(lam_se, 2)/ 1 * np.power((- np.power(lam_hat, k) * np.exp(-lam_hat) + 
                             np.power(lam_hat, k) * np.exp(-lam_hat)*np.log(lam_hat)),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(left, right)
192/53:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)/ k * np.power((- np.power(lam_hat, k) * np.exp(-lam_hat) + 
                             np.power(lam_hat, k) * np.exp(-lam_hat)*np.log(lam_hat)),2)

    z = norm_rv.ppf(1-alpha/2)
    left = e - z*var
    right = e + z*var
    return left, right
192/54:
left, right = prob_ci(1)
delta = right - left

# assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/55:
left, right = prob_ci(1)
delta = right - left

assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/56:
import numpy as np
import pandas as pd

from scipy import stats
import scipy.stats as sts

import seaborn as sns
import matplotlib.pyplot as plt

plt.style.use('ggplot')
192/57:
poiss_rv = sts.poisson(lam_hat)

x = np.arange(10)

p = poiss_rv.pmf(x)
left, right = prob_ci(x)

plt.figure(figsize=(10,5))
plt.plot(x, p, 'bo', ms=6, label='poisson pmf')
plt.fill_between(x, left, right, alpha=0.5)
plt.vlines(x, 0, p, lw=1)
plt.legend(loc='best', frameon=False)
plt.show()
192/58:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2)/ 1 * np.power((np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (
                                    lam_hat - k ),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(left, right)
192/59:
x = df[df.year <= 1900]['count']
y = df[df.year > 1900]['count']

alpha = 0.05

z = norm_rv.ppf(1-alpha/2)
diff = np.mean(x) - np.mean(y)
diff_se = np.sqrt(np.mean(x)/len(x) + np.mean(y)/len(y))

left = diff - z*diff_se
right = diff + z*diff_se
delta = right - left

print(left, right)
# Помимо самого интервала нас интересует его ширина
print(f"Доверительный интервал [{left:.3}, {right:.3}]")
192/60:
from scipy.special import factorial
def poiss_prob(k):
    return np.power(lam_hat, k) * np.exp(-lam_hat)/factorial(k)

# проверка функции
assert np.abs(poiss_prob(1) - 0.3098761) < 1e-5
192/61:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2)/ 1 * np.power((np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (
                                    lam_hat - k ),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(left, right)
192/62:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2)/ 1 * np.power((np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (lam_hat - k ),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(left, right)
192/63:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2) * np.power((np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (lam_hat - k ),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(left, right)
192/64:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2) * np.power((np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (lam_hat - k ),2) /1

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(left, right)
192/65:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2) * np.power((np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (lam_hat - k ),2)
print('var', var)
z_1 = norm_rv.ppf(1-alpha/2)
# left = e - z*var
# right = e + z*var
# delta = right - left


# print(left, right)
192/66:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2) * np.power((np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (lam_hat - k ),2)
print('var', var)
z_1 = norm_rv.ppf(1-alpha/2)
# left = e - z*var
# right = e + z*var
# delta = right - left


# print(left, right)
192/67:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2) / 1 * np.power(np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (lam_hat - k),2)
print('var', var)
z_1 = norm_rv.ppf(1-alpha/2)
# left = e - z*var
# right = e + z*var
# delta = right - left


# print(left, right)
192/68:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2) / 1 * np.power(np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (lam_hat - k),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(left, right)
192/69: stats.norm.interval(0.95, loc=e, scale=var)
192/70:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2) / 1 * np.power(np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (lam_hat - k),2)
    z = norm_rv.ppf(1-alpha/2)
    left = e - z*var
    right = e + z*var
    return left, right
192/71:
left, right = prob_ci(1)
delta = right - left

assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/72:
left, right = prob_ci(1)
delta = right - left
print(delta)
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/73:
poiss_rv = sts.poisson(lam_hat)

x = np.arange(10)

p = poiss_rv.pmf(x)
left, right = prob_ci(x)

plt.figure(figsize=(10,5))
plt.plot(x, p, 'bo', ms=6, label='poisson pmf')
plt.fill_between(x, left, right, alpha=0.5)
plt.vlines(x, 0, p, lw=1)
plt.legend(loc='best', frameon=False)
plt.show()
192/74:
left, right = prob_ci(1)
delta = right - left
print(delta)
assert np.abs(delta - 0.08147) < 1e-3


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/75:
left, right = prob_ci(1)
delta = right - left
print(delta)
assert np.abs(delta - 0.08147) < 1e-2


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/76:
left, right = prob_ci(1)
delta = right - left

assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/77: prob_ci(1)
192/78:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2) / 1 * np.power(np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (lam_hat - k),2)
    z = norm_rv.ppf(1-alpha/2)
    left = e - z*var
    right = e + z*var
    return right - left
192/79: prob_ci(1)
192/80: df['count'].mean(), df['count'].var()
192/81:
for k,(i,j) in enumerate(zip(left, right)):
    print(f"Вероятность P(X={k}) лежит между  {i:.5} и {j:.5}")
192/82:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2) * np.power(np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (lam_hat - k),2) /factorial(k) * 1

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(left, right)
192/83:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2) * np.power(np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (lam_hat - k),2) /factorial(k) * 1

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(left, right)
192/84:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2) * np.power(np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (lam_hat - k),2) /factorial(k) * 1

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(left, right)
192/85: stats.norm.interval(0.95, loc=e, scale=var)
192/86:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)* np.power(np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (lam_hat - k),2)
    z = norm_rv.ppf(1-alpha/2)
    left = e - z*var
    right = e + z*var
    return right - left
192/87: prob_ci(1)
192/88:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)* np.power(np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (lam_hat - k),2)
    z = norm_rv.ppf(1-alpha/2)
    left = e - z*var
    right = e + z*var
    return right - left
192/89: prob_ci(1)
192/90:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)* np.power(np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (lam_hat - k),2) /factorial(k)
    z = norm_rv.ppf(1-alpha/2)
    left = e - z*var
    right = e + z*var
    return right - left
192/91: prob_ci(1)
192/92: prob_ci(1)
192/93:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)* np.power(np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (lam_hat - k),2) /factorial(k)
    z = norm_rv.ppf(1-alpha/2)
    print('e', e)
    print(var)
    left = e - z*var
    right = e + z*var
    return right - left
192/94: prob_ci(1)
192/95:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)* np.power(np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (lam_hat - k),2)
    z = norm_rv.ppf(1-alpha/2)
    print('e', e)
    print(var)
    left = e - z*var
    right = e + z*var
    return right - left
192/96:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)* np.power(np.exp(-lam_hat) * np.power(lam_hat, k - 1) * (lam_hat - k),2)
    z = norm_rv.ppf(1-alpha/2)
    print('e', e)
    print(var)
    left = e - z*var
    right = e + z*var
    return right - left
192/97: prob_ci(1)
192/98: prob_ci(1)
192/99:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2) * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2) * 1

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(left, right)
192/100: stats.norm.interval(0.95, loc=e, scale=var)
192/101:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2) * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2) * 1
    z = norm_rv.ppf(1-alpha/2)
    print('e', e)
    print(var)
    left = e - z*var
    right = e + z*var
    return right - left
192/102: prob_ci(1)
192/103: prob_ci(1)
192/104: poiss_prob(1)
192/105:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2) * 1

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(left, right)
192/106: stats.norm.interval(0.95, loc=e, scale=var)
192/107:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(left, right)
192/108:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)/n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)
    z = norm_rv.ppf(1-alpha/2)
    print('e', e)
    print(var)
    left = e - z*var
    right = e + z*var
    return right - left
192/109: prob_ci(1)
192/110: prob_ci(1)
192/111: stats.norm.interval(0.95, loc=e, scale=var)
192/112: stats.norm.interval(0.95, loc=e, scale=var)
192/113: stats.norm.interval(0.95, loc=e, scale=var)
192/114:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)/n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)
    z = norm_rv.ppf(1-alpha/2)
    print('e', e)
    print(var)
    left = e - z*var
    right = e + z*var
    return right - left
192/115:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)/n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)
    z = norm_rv.ppf(1-alpha/2)
    print('e', e)
    print(var)
    left = e - z*var
    right = e + z*var
    return right - left
192/116:
def prob_ci(k, alpha = 0.05, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)/n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)
    z = norm_rv.ppf(1-alpha/2)
    print('e', e)
    print(var)
    left = e - z*var
    right = e + z*var
    return right - left
192/117: prob_ci(1)
192/118:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)/n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)
    z = norm_rv.ppf(1-alpha/2)
    print('e', e)
    print(var)
    left = e - z*var
    right = e + z*var
    return right - left
192/119:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(right - left )
192/120:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)/n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)
    z = norm_rv.ppf(1-alpha/2)
    print('e', e)
    print(var)
    left = e - z*var
    right = e + z*var
    return right - left
192/121: prob_ci(1)
192/122:
left, right = prob_ci(1)
delta = right - left

assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/123:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)/n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)
    z = norm_rv.ppf(1-alpha/2)
    print('e', e)
    print(var)
    left = e - z*var
    right = e + z*var
    return left, right
192/124:
left, right = prob_ci(1)
delta = right - left

assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/125:
left, right = prob_ci(1)
delta = right - left
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/126:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)/n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)
    z = norm_rv.ppf(1-alpha/2)
#     print('e', e)
#     print(var)
    left = e - z*var
    right = e + z*var
    return left, right
192/127:
left, right = prob_ci(1)
delta = right - left
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/128:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*np.sqrt(var)
right = e + z*np.sqrt(var)
delta = right - left


print(right - left )
192/129: stats.norm.interval(0.95, loc=e, scale=var)
192/130:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)/n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)
    z = norm_rv.ppf(1-alpha/2)
#     print('e', e)
#     print(var)
    left = e - z*np.sqrt(var)
    right = e + z*np.sqrt(var)
    return left, right
192/131:
left, right = prob_ci(1)
delta = right - left
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/132:
left, right = prob_ci(1)
delta = right - left
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/133:
left, right = prob_ci(1)
delta = right - left
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/134: prob_ci(1)
192/135:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/136:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/137:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = lam_se/n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)
    z = norm_rv.ppf(1-alpha/2)
#     print('e', e)
#     print(var)
    left = e - z*np.sqrt(var)
    right = e + z*np.sqrt(var)
    return left, right
192/138:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/139:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = lam_se/n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)
    z = norm_rv.ppf(1-alpha/2)
    print('e', e)
    print(var)
    left = e - z*var
    right = e + z*var
    return left, right
192/140: prob_ci(1)
192/141:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/142:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)/n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)
    z = norm_rv.ppf(1-alpha/2)
#     print('e', e)
#     print(var)
    left = e - z*np.sqrt(var)
    right = e + z*np.sqrt(var)
    return left, right
192/143:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/144:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/145:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/146:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/147:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)/n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)
    z = norm_rv.ppf(1-alpha/2)
#     print('e', e)
#     print(var)
    left = e - z*var
    right = e + z*var
    return left, right
192/148:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/149:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/150:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/151:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*np.sqrt(var)
right = e + z*np.sqrt(var)
delta = right - left


print(right - left )
192/152: stats.norm.interval(0.95, loc=e, scale=var)
192/153: stats.norm.interval(0.95, loc=e, scale=var)
192/154:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*np.sqrt(var)
right = e + z*np.sqrt(var)
delta = right - left


print(right, left )
192/155:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(right, left )
192/156: prob_ci(1)
192/157:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/158:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)
    z = norm_rv.ppf(1-alpha/2)
#     print('e', e)
#     print(var)
    left = e - z*var
    right = e + z*var
    return right-left
192/159: prob_ci(1)
192/160:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)
    z = norm_rv.ppf(1-alpha/2)
#     print('e', e)
#     print(var)
    left = e - z*var
    right = e + z*var
    return stats.norm.interval(0.95, loc=e, scale=var)
192/161: prob_ci(1)
192/162: prob_ci(1)[1] - prob_ci(1)[0]
192/163:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/164:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (lam_hat - k)) /factorial(k),2)
    z = norm_rv.ppf(1-alpha/2)
    print('stat', stats.norm.interval(0.95, loc=e, scale=var))
#     print(var)
    left = e - z*var
    right = e + z*var
    return left, right
192/165: prob_ci(1)[1] - prob_ci(1)[0]
192/166:
alpha = 0.05

k = 1
e = poiss_prob(k)
var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(right, left )
192/167: stats.norm.interval(0.95, loc=e, scale=var)
192/168:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)
    z = norm_rv.ppf(1-alpha/2)
    print('stat', stats.norm.interval(0.95, loc=e, scale=var))
#     print(var)
    left = e - z*var
    right = e + z*var
    return left, right
192/169: prob_ci(1)[1] - prob_ci(1)[0]
192/170:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    e = poiss_prob(k)
    var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)
    z = norm_rv.ppf(1-alpha/2)
    print('stat', stats.norm.interval(0.95, loc=e, scale=var))
#     print(var)
    left = e - z*var
    right = e + z*var
    return left, right
192/171: prob_ci(1)[1] - prob_ci(1)[0]
192/172: prob_ci(1)[1] - prob_ci(1)[0]
192/173: prob_ci(1)[1] - prob_ci(1)[0]
192/174:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/175:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/176:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/177:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/178:
alpha = 0.05

k = 1
e = lam_hat
var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(right, left )
192/179:
alpha = 0.05

k = 1
e = poiss_prob(1)
var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(right, left )
192/180:
alpha = 0.05

k = 1
e = poiss_prob(1)
g_mu = poiss_prob(lam_hat)
var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
                                      np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)

z = norm_rv.ppf(1-alpha/2)
left = e - z*var
right = e + z*var
delta = right - left


print(right, left )
192/181:
alpha = 0.05

k = 1
# e = poiss_prob(1)
g_mu = poiss_prob(lam_hat)

der = np.exp(-lam_hat)*lam_hat**(k-1)/factorial(k)*(k-lam_hat)
der2 = der**2
std = (lam_hat/n_hat * der2)**0.5 

# g_var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
#                                       np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*std
right = g_mu  + z*std
delta = right - left


print(right, left )
192/182: stats.norm.interval(0.95, loc=e, scale=var)
192/183:
alpha = 0.05

k = 1
# e = poiss_prob(1)
g_mu = poiss_prob(lam_hat)

der = np.exp(-lam_hat)*lam_hat**(k-1)/factorial(k)*(k-lam_hat)
der2 = der**2
std = (lam_hat/n_hat * der2)**0.5 

# g_var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
#                                       np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*std
right = g_mu  + z*std
delta = right - left


print(right - left )
192/184:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = np.exp(-lam_hat)*lam_hat**(k-1)/factorial(k)*(k-lam_hat)
der2 = der**2
std = (lam_hat/n_hat * der2)**0.5 

# g_var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
#                                       np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*std
right = g_mu  + z*std
delta = right - left


print(right - left )
192/185: stats.norm.interval(0.95, loc=g_mu, scale=g_var )
192/186:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = np.exp(-lam_hat)*lam_hat**(k-1)/factorial(k)*(k-lam_hat)
der2 = der**2
std = (lam_hat/n_hat * der2)**0.5 

# g_var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
#                                       np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)

# g_mu = std**2/n_hat*

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*np.sqr(std)
right = g_mu  + z*np.sqr(std)
delta = right - left


print(right - left )
192/187:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = np.exp(-lam_hat)*lam_hat**(k-1)/factorial(k)*(k-lam_hat)
der2 = der**2
std = (lam_hat/n_hat * der2)**0.5 

# g_var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
#                                       np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)

# g_mu = std**2/n_hat*

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*np.sqrt(std)
right = g_mu  + z*np.sqrt(std)
delta = right - left


print(right - left )
192/188:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = np.exp(-lam_hat)*lam_hat**(k-1)/factorial(k)*(k-lam_hat)
der2 = der**2
std = (lam_se/n_hat * der2)**0.5 

# g_var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
#                                       np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)

g_mu = std**2/n_hat*

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*std
right = g_mu  + z*std
delta = right - left


print(right - left )
192/189:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = np.exp(-lam_hat)*lam_hat**(k-1)/factorial(k)*(k-lam_hat)
der2 = der**2
std = (lam_se/n_hat * der2)**0.5 

# g_var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
#                                       np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)

# g_mu = std**2/n_hat*

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*std
right = g_mu  + z*std
delta = right - left


print(right - left )
192/190:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = np.exp(-lam_hat)*lam_hat**(k-1)/factorial(k)*(k-lam_hat)
der2 = der**2
std = (lam_hat/n_hat * der2)**0.5 

# g_var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
#                                       np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)

# g_mu = std**2/n_hat*

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*std
right = g_mu  + z*std
delta = right - left


print(right - left )
192/191:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = np.exp(-lam_hat)*lam_hat**(k-1)/factorial(k)*(k-lam_hat)
der2 = der**2
std = (lam_hat/n_hat * der2)**0.5 

# g_var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
#                                       np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)

g_mu = std**2/n_hat*der2

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*g_mu
right = g_mu  + z*g_mu
delta = right - left


print(right - left )
192/192:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = np.exp(-lam_hat)*lam_hat**(k-1)/factorial(k)*(k-lam_hat)
der2 = der**2
std = (lam_hat/n_hat * der2)**0.5 

# g_var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
#                                       np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)

g_mu = std**2/n_hat*der2

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*np.sqrt(g_mu)
right = g_mu  + z*np.sqrt(g_mu)
delta = right - left


print(right - left )
192/193:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = np.exp(-lam_hat)*lam_hat**(k-1)/factorial(k)*(k-lam_hat)
der2 = der**2
std = (lam_hat/n_hat * der2)**0.5 

# g_var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
#                                       np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)

g_mu = std**2/n_hat*der2

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*std)
right = g_mu  + z*std
delta = right - left


print(right - left )
192/194:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = np.exp(-lam_hat)*lam_hat**(k-1)/factorial(k)*(k-lam_hat)
der2 = der**2
std = (lam_hat/n_hat * der2)**0.5 

# g_var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
#                                       np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)

g_mu = std**2/n_hat*der2

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*std
right = g_mu  + z*std
delta = right - left


print(right - left )
192/195:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = np.exp(-lam_hat)*lam_hat**(k-1)/factorial(k)*(k-lam_hat)
der2 = der**2
std = (lam_hat/n_hat * der2)**0.5 

# g_var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
#                                       np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)

g_mu = std**2/n_hat*der2

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*std
right = g_mu  + z*std
delta = right - left


print(right - left )
192/196:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = np.exp(-lam_hat)*lam_hat**(k-1)/factorial(k)*(k-lam_hat)
der2 = der**2
std = (lam_hat**2/n_hat * der2)**0.5 

# g_var = np.power(lam_se, 2)/ n_hat * np.power((np.exp(-lam_hat) *
#                                       np.power(lam_hat, k - 1) * (-lam_hat + k)) /factorial(k),2)

g_mu = std**2/n_hat*der2

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*std
right = g_mu  + z*std
delta = right - left


print(right - left )
192/197:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = (np.exp(-lam_hat)*lam_hat**(k-1)/factorial(k)*(k-lam_hat))**2
g_std = (lam_hat**2/n_hat * der2)**0.5 

g_mu = std**2/n_hat*der2

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*g_std
right = g_mu  + z*g_std
delta = right - left


print(right - left )
192/198:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = (np.exp(-lam_hat)*lam_hat**(k-1)/factorial(k)*(k-lam_hat))**2
g_std = (lam_hat**2/n_hat * der2)**0.5 

# g_mu = std**2/n_hat*der2

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*g_std
right = g_mu  + z*g_std
delta = right - left


print(right - left )
192/199:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = (np.exp(-lam_hat)*lam_hat**(k-1)/factorial(k)*(k-lam_hat))**2
g_std = (lam_hat**2/n_hat * der2)**0.5 

# g_mu = std**2/n_hat*der2

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*g_std
right = g_mu  + z*g_std
delta = right - left


print(right - left )
192/200:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = (np.exp(-lam_hat)*lam_hat**(k-1)/factorial(k)*(k-lam_hat))**2
g_std = (lam_hat**2/n_hat * der2)**0.5 

# g_mu = std**2/n_hat*der2

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*g_std
right = g_mu  + z*g_std
delta = right - left


print(right - left )
192/201: stats.norm.interval(0.95, loc=g_mu, scale=g_std )
192/202:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = (np.exp(-lam_hat)*lam_hat**(k-1)*(-lam_hat + k)/factorial(k))**2
g_std = (lam_hat**2/n_hat * der2)**0.5 

# g_mu = std**2/n_hat*der2

z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*g_std
right = g_mu  + z*g_std
delta = right - left


print(right - left )
192/203: stats.norm.interval(0.95, loc=g_mu, scale=g_std )
192/204:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    g_mu = poiss_prob(lam_hat)

    der = (np.exp(-lam_hat)*lam_hat**(k-1)*(-lam_hat + k)/factorial(k))**2
    g_std = (lam_hat**2/n_hat * der2)**0.5

    z = norm_rv.ppf(1-alpha/2)
    left = g_mu - z*g_std
    right = g_mu  + z*g_std

    return left, right
192/205: prob_ci(1)[1] - prob_ci(1)[0]
192/206: prob_ci(1)
192/207:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/208:
alpha = 0.01

k = 1
g_mu = poiss_prob(lam_hat)

der = (np.exp(-lam_hat)*lam_hat**(k-1)*(-lam_hat + k)/factorial(k))**2
g_std = (lam_hat**2/n_hat * der2)**0.5 


z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*g_std
right = g_mu  + z*g_std
delta = right - left


print(right - left )
192/209:
alpha = 0.02

k = 1
g_mu = poiss_prob(lam_hat)

der = (np.exp(-lam_hat)*lam_hat**(k-1)*(-lam_hat + k)/factorial(k))**2
g_std = (lam_hat**2/n_hat * der2)**0.5 


z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*g_std
right = g_mu  + z*g_std
delta = right - left


print(right - left )
192/210:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = (np.exp(-lam_hat)*lam_hat**(k-1)*(-lam_hat + k)/factorial(k))**2
g_std = (lam_hat**2/n_hat * der2)**0.5 


z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*g_std
right = g_mu  + z*g_std
delta = right - left


print(right - left )
192/211:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = (np.exp(-lam_hat)*lam_hat**(k-1)*(-lam_hat + k)/factorial(k))**2
g_std = (lam_hat**2/n_hat * der)**0.5 


z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*g_std
right = g_mu  + z*g_std
delta = right - left


print(right - left )
192/212:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    g_mu = poiss_prob(lam_hat)

    der = (np.exp(-lam_hat)*lam_hat**(k-1)*(-lam_hat + k)/factorial(k))**2
    g_std = (lam_hat**2/n_hat * der)**0.5

    z = norm_rv.ppf(1-alpha/2)
    left = g_mu - z*g_std
    right = g_mu  + z*g_std

    return left, right
192/213:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/214: prob_ci(1)
192/215: prob_ci(1)
192/216: prob_ci(1)[1]-prob_ci(1)[0]
192/217:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
# assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/218:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
# assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/219:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
# assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/220:
poiss_rv = sts.poisson(lam_hat)

x = np.arange(10)

p = poiss_rv.pmf(x)
left, right = prob_ci(x)

plt.figure(figsize=(10,5))
plt.plot(x, p, 'bo', ms=6, label='poisson pmf')
plt.fill_between(x, left, right, alpha=0.5)
plt.vlines(x, 0, p, lw=1)
plt.legend(loc='best', frameon=False)
plt.show()
192/221:
for k,(i,j) in enumerate(zip(left, right)):
    print(f"Вероятность P(X={k}) лежит между  {i:.5} и {j:.5}")
192/222:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

der = (np.exp(-lam_hat)*lam_hat**(k-1)*(-lam_hat + k)/factorial(k))**2
g_std = (lam_hat/n_hat * der)**0.5 


z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*g_std
right = g_mu  + z*g_std
delta = right - left


print(right - left )
192/223: stats.norm.interval(0.95, loc=g_mu, scale=g_std )
192/224:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    g_mu = poiss_prob(lam_hat)

    der = (np.exp(-lam_hat)*lam_hat**(k-1)*(-lam_hat + k)/factorial(k))**2
    g_std = (lam_hat**2/n_hat * der)**0.5

    z = norm_rv.ppf(1-alpha/2)
    left = g_mu - z*g_std
    right = g_mu  + z*g_std

    return left, right
192/225: prob_ci(1)[1]-prob_ci(1)[0]
192/226:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    g_mu = poiss_prob(lam_hat)

    der = (np.exp(-lam_hat)*lam_hat**(k-1)*(-lam_hat + k)/factorial(k))**2
    g_std = (lam_hat/n_hat * der)**0.5

    z = norm_rv.ppf(1-alpha/2)
    left = g_mu - z*g_std
    right = g_mu  + z*g_std

    return left, right
192/227: prob_ci(1)[1]-prob_ci(1)[0]
192/228:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
# assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/229:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)
print(np.abs(delta - 0.08147))
assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/230:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)

assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/231:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

g_der = (np.exp(-lam_hat)*lam_hat**(k-1)*(-lam_hat + k)/factorial(k))**2
g_std = (lam_hat/n_hat * g_der)**0.5 


z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*g_std
right = g_mu  + z*g_std
delta = right - left


print(right - left )
192/232:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    g_mu = poiss_prob(lam_hat)

    g_der = (np.exp(-lam_hat)*lam_hat**(k-1)*(-lam_hat + k)/factorial(k))**2
    g_std = (lam_hat/n_hat * g_der)**0.5

    z = norm_rv.ppf(1-alpha/2)
    left = g_mu - z*g_std
    right = g_mu  + z*g_std

    return left, right
192/233:
left, right = prob_ci(1)
delta = right - left
print('delta', delta)

assert np.abs(delta - 0.08147) < 1e-5


left, right = prob_ci(0)
delta = right - left

assert np.abs(delta - 0.11551) < 1e-5
192/234:
poiss_rv = sts.poisson(lam_hat)

x = np.arange(10)

p = poiss_rv.pmf(x)
left, right = prob_ci(x)

plt.figure(figsize=(10,5))
plt.plot(x, p, 'bo', ms=6, label='poisson pmf')
plt.fill_between(x, left, right, alpha=0.5)
plt.vlines(x, 0, p, lw=1)
plt.legend(loc='best', frameon=False)
plt.show()
192/235:
for k,(i,j) in enumerate(zip(left, right)):
    print(f"Вероятность P(X={k}) лежит между  {i:.5} и {j:.5}")
192/236: df['count'].mean(), df['count'].var()
192/237:
df = pd.read_csv('../data/cr.csv')
print(df.shape)
df.head()
192/238:
df = pd.read_csv('./data/cr.csv')
print(df.shape)
df.head()
192/239:
df = pd.read_csv('./data/cr.csv')
print(df.shape)
df
192/240:
x = df[['k1', 'k1a', 'k1b', 'k1c','k1d', 'k1e','k1f']].copy()
x_mean = ...
x_std = ...
192/241:
x = df[['k1', 'k1a', 'k1b', 'k1c','k1d', 'k1e','k1f']].copy()
x_mean = ...
x_std = ...
192/242: x
192/243: x.isnull.sum
192/244: x.isnull.sum()
192/245: x.isnull().sum()
192/246:
x = df[['k1']].copy()
x_mean = ...
x_std = ...
192/247: x.isnull().sum()
192/248:
x = df[['k1']].copy()
x.dropna(inplace=True)
192/249:
x = df[['k1']].copy()
x.dropna(inplace=True)
x
192/250:
x = df[['k1']].copy()
x.dropna(inplace=True)
x.head()
192/251:
x_mean = x.mean()
x_std = x.std(ddof=1)
192/252: sns.histplot(data=df, x='k1', kde=True)
192/253:
norm_rv = stats.norm(loc=x_mean, scale=x_std) 

x = np.linspace(-12, 12, 100)
pdf = norm_rv.pdf(x)

# плотность 
plt.plot(x, pdf, lw=3)


sns.histplot(data=df, x='k1', kde=True)
192/254:
norm_rv = stats.norm(loc=x_mean, scale=x_std) 

x = np.linspace(-12, 12, 100)
pdf = norm_rv.pdf(x)
print(pdf)
# плотность 
plt.plot(x, pdf, lw=3)


sns.histplot(data=df, x='k1', kde=True)
192/255:
norm_rv = stats.norm(loc=x_mean, scale=x_std) 

x = np.linspace(-12, 12, 100)
sample = norm_rv.pdf(x)
sns.histplot(sample, bins=30, stat='density');
# плотность 
plt.plot(x, pdf, lw=3)


sns.histplot(data=df, x='k1', kde=True)
192/256:
norm_rv = stats.norm(loc=x_mean, scale=x_std) 

sample = norm_rv.pdf(100)
sns.histplot(sample, bins=30, stat='density');
# плотность 
plt.plot(x, pdf, lw=3)


sns.histplot(data=df, x='k1', kde=True)
192/257:
norm_rv = stats.norm(loc=x_mean, scale=x_std) 

sample = norm_rv.rvs(100)
sns.histplot(sample, bins=30, stat='density');
# плотность 
plt.plot(x, pdf, lw=3)


sns.histplot(data=df, x='k1', kde=True)
192/258:
norm_rv = stats.norm(loc=x_mean, scale=x_std) 

x = np.linspace(-3, 3, 100)
pdf = norm_rv.pdf(x)

# плотность 
plt.plot(x, pdf)


sns.histplot(data=df, x='k1', kde=True)
192/259:
norm_rv = stats.norm(loc=x_mean, scale=x_std) 

x = np.linspace(-3, 3, 100)
pdf = norm_rv.pdf(x)

# плотность 
plt.plot(x, pdf, lw=3)


sns.histplot(data=df, x='k1', kde=True)
192/260: x_mean
192/261: x_std
192/262: norm_rv
192/263:
norm_rv = stats.norm(loc=x_mean, scale=x_std) 

x = np.linspace(-3, 13, 100)
pdf = norm_rv.pdf(x)

# плотность 
plt.plot(x, pdf, lw=3)


sns.histplot(data=df, x='k1', kde=True)
192/264: pdf
192/265: x_std
192/266:
norm_rv = stats.norm(loc=5, scale=3)
x = np.linspace(-3, 13, 100)
pdf = norm_rv.pdf(x)
pdf
192/267:
norm_rv = stats.norm(loc=5, scale=3)
x = np.linspace(-3, 13, 100)
pdf = norm_rv.pdf(x)
pdf
192/268:
norm_rv = stats.norm(loc=5, scale=3)
x = np.linspace(-3, 13, 100)
pdf = norm_rv.pdf(x)
pdf
192/269:
norm_rv = stats.norm(loc=5, scale=3)
x = np.linspace(-3, 13, 100)
pdf = norm_rv.pdf(x)
pdf
192/270:
norm_rv = stats.norm(loc=5, scale=3)
x = np.linspace(-3, 13, 100)
pdf = norm_rv.pdf(x)
# плотность 
plt.plot(x, pdf, lw=3)
192/271:
norm_rv = stats.norm(loc=x_mean, scale=x_std) 

x = np.linspace(-3, 13, 100)
pdf = norm_rv.pdf(x)

# плотность 
plt.plot(x, pdf, lw=3)
plt.figure(figsize=(8, 6), dpi=80)

sns.histplot(data=df, x='k1', kde=True)
192/272: x.shape
192/273: x.size
192/274:
x = df[['k1']].copy()
x.dropna(inplace=True)
x.head()
192/275:
x_mean = x.mean()
x_std = x.std(ddof=1)
192/276:
norm_rv = stats.norm(loc=x_mean, scale=x_std) 

y = np.linspace(-3, 13, 100)
pdf = norm_rv.pdf(y)

# плотность 
plt.plot(y, pdf, lw=3)
plt.figure(figsize=(8, 6), dpi=80)

sns.histplot(data=df, x='k1', kde=True)
192/277: x.size
192/278:
alpha = 0.05

n = x.size
t_rv = stats.t(n - 1)
t_crit = t_rv.ppf(1 - alpha/2)

margin = ...    # отступ от среднего
left =  ...     # левая граница интервала
right = ...     # правая граница интервала
delta = ...     # ширина интервала

print(left, right)
t_crit
192/279:
alpha = 0.05

n = x.size
t_rv = stats.t(n - 1)
t_crit = t_rv.ppf(1 - alpha/2)

var_x = df.x.var(ddof=1)

margin = t_crit*np.sqrt(var_hat/n)

left = x_mean - margin
right = x_mean + margin



margin = x.mean()    # отступ от среднего
left =  x_mean - margin     # левая граница интервала
right = x_mean + margin     # правая граница интервала
delta = right - left     # ширина интервала

print(left, right)
t_crit
192/280:
alpha = 0.05

n = x.size
t_rv = stats.t(n - 1)
t_crit = t_rv.ppf(1 - alpha/2)


margin = x.mean()    # отступ от среднего
left =  x_mean - margin     # левая граница интервала
right = x_mean + margin     # правая граница интервала
delta = right - left     # ширина интервала

print(left, right)
t_crit
192/281:
alpha = 0.05

n = x.size
t_rv = stats.t(n - 1)
t_crit = t_rv.ppf(1 - alpha/2)


margin = x.mean()    # отступ от среднего
left =  x_mean - margin     # левая граница интервала
right = x_mean + margin     # правая граница интервала
delta = right - left     # ширина интервала

print(left, right)
192/282:
alpha = 0.05

n = x.size
t_rv = stats.t(n - 1)
t_crit = t_rv.ppf(1 - alpha/2)


margin = x.mean()    # отступ от среднего
left =  x_mean - margin     # левая граница интервала
right = x_mean + margin     # правая граница интервала
delta = right - left     # ширина интервала

print(left, right)
192/283:
alpha = 0.05

n = x.size
t_rv = stats.t(n - 1)
t_crit = t_rv.ppf(1 - alpha/2)


margin = x.mean()    # отступ от среднего
left =  x_mean - margin     # левая граница интервала
right = x_mean + margin     # правая граница интервала
delta = right - left     # ширина интервала

print(left, right)
192/284:
alpha = 0.05

n = x.size
t_rv = stats.t(n - 1)
t_crit = t_rv.ppf(1 - alpha/2)
var_x = x.var(ddof=1)

margin = t_crit*np.sqrt(var_x/n) # отступ от среднего
left =  x_mean - margin     # левая граница интервала
right = x_mean + margin     # правая граница интервала
delta = right - left     # ширина интервала

print(left, right)
192/285:
alpha = 0.05

n = x.size
t_rv = stats.t(n - 1)
t_crit = t_rv.ppf(1 - alpha/2)
var_x = x.var(ddof=1)

margin = t_crit*np.sqrt(var_x/n) # отступ от среднего
left =  x_mean - margin     # левая граница интервала
right = x_mean + margin     # правая граница интервала
delta = right - left     # ширина интервала

print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
192/286:
alpha = 0.05

n = x.size
t_rv = stats.t(n - 1)
t_crit = t_rv.ppf(1 - alpha/2)
var_x = x.var(ddof=1)

margin = t_crit*np.sqrt(var_x/n) # отступ от среднего
left =  x_mean - margin     # левая граница интервала
right = x_mean + margin     # правая граница интервала
delta = right - left     # ширина интервала

print(left, right)
192/287:
alpha = 0.05

n = x.size
t_rv = stats.t(n - 1)
t_crit = t_rv.ppf(1 - alpha/2)
var_x = x.var(ddof=1)

prinr('var_x', var_x)
margin = t_crit*np.sqrt(var_x/n) # отступ от среднего
left =  x_mean - margin     # левая граница интервала
right = x_mean + margin     # правая граница интервала
delta = right - left     # ширина интервала

print(left, right)
192/288:
alpha = 0.05

n = x.size
t_rv = stats.t(n - 1)
t_crit = t_rv.ppf(1 - alpha/2)
var_x = x.var(ddof=1)

print('var_x', var_x)
margin = t_crit*np.sqrt(var_x/n) # отступ от среднего
left =  x_mean - margin     # левая граница интервала
right = x_mean + margin     # правая граница интервала
delta = right - left     # ширина интервала

print(left, right)
192/289:
alpha = 0.05

n = x.size
t_rv = stats.t(n - 1)
t_crit = t_rv.ppf(1 - alpha/2)
var_x = x.k1.var(ddof=1)

print('var_x', var_x)
margin = t_crit*np.sqrt(var_x/n) # отступ от среднего
left =  x_mean - margin     # левая граница интервала
right = x_mean + margin     # правая граница интервала
delta = right - left     # ширина интервала

print(left, right)
192/290:
alpha = 0.05

n = x.size
t_rv = stats.t(n - 1)
t_crit = t_rv.ppf(1 - alpha/2)
var_x = x.k1.var(ddof=1)


margin = t_crit*np.sqrt(var_x/n) # отступ от среднего
print('margin', margin)
left =  x_mean - margin     # левая граница интервала
right = x_mean + margin     # правая граница интервала
delta = right - left     # ширина интервала

print(left, right)
192/291:
x_mean = x.k1.mean()
x_std = x.k1.std(ddof=1)
192/292: x_std
192/293:
norm_rv = stats.norm(loc=x_mean, scale=x_std) 

y = np.linspace(-3, 13, 100)
pdf = norm_rv.pdf(y)

# плотность 
plt.plot(y, pdf, lw=3)
plt.figure(figsize=(8, 6), dpi=80)

sns.histplot(data=df, x='k1', kde=True)
192/294:
alpha = 0.05

n = x.size
t_rv = stats.t(n - 1)
t_crit = t_rv.ppf(1 - alpha/2)
var_x = x.k1.var(ddof=1)


margin = t_crit*np.sqrt(var_x/n) # отступ от среднего
print('margin', margin)
left =  x_mean - margin     # левая граница интервала
right = x_mean + margin     # правая граница интервала
delta = right - left     # ширина интервала

print(left, right)
192/295:
alpha = 0.05

n = x.size
t_rv = stats.t(n - 1)
t_crit = t_rv.ppf(1 - alpha/2)
var_x = x.k1.var(ddof=1)


margin = t_crit*np.sqrt(var_x/n) # отступ от среднего
left =  x_mean - margin     # левая граница интервала
right = x_mean + margin     # правая граница интервала
delta = right - left     # ширина интервала

print(left, right)
192/296:
alpha = 0.05

n = x.size
t_rv = stats.t(n - 1)
t_crit = t_rv.ppf(1 - alpha/2)
var_x = x.k1.var(ddof=1)


margin = t_crit*np.sqrt(var_x/n) # отступ от среднего
left =  x_mean - margin     # левая граница интервала
right = x_mean + margin     # правая граница интервала
delta = right - left     # ширина интервала

print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, right - left))
192/297: good = df['fraud' == 0]['k1']
192/298: good = df['fraud' == 0][['k1']]
192/299: good = df[df.fraud == 0][['k1']]
192/300:
good = df[df.fraud == 0][['k1']]
good
192/301:
good = df[df.fraud > 0][['k1']]
good
192/302:
good = df[df.fraud > 0]['k1']
good
192/303:
good = df[df.fraud > 0]
good
192/304:
good = df['k1'][df.fraud > 0]
good
192/305:
good = df[['k1']][df.fraud > 0]
good
192/306:
good = df[['k1']][df.fraud == 0]
good
192/307:
good = df['k1'][df.fraud == 0]
good
192/308:
good = df[['k1']][df.fraud == 0]
good
192/309: df[['k1']][df.fraud > 0]
192/310: df[['k1']][df.fraud is NaN]
192/311: df[['k1']][df.fraud is Null]
192/312: df[['k1']][df.fraud is None]
192/313: df[['k1']][df.fraud == None]
192/314: df[['k1']][df.fraud < 0]
192/315: dr.fraud.isnull().sum()
192/316: df.fraud.isnull().sum()
192/317: x_mean
192/318: good
192/319:
fig, ax = plt.subplots()
for h in [good, bad]:
    sns.histplot(h, bins=30, ax=ax, kde=False)
192/320:
good = df[['k1']][df.fraud == 0]
bad = df[['k1']][df.fraud > 0]

good_mean = good.k1.mean()
bad_mean = bad.k1.mean()

diff = 

nu =  ...       # число степеней свободы в распределении Стьюдента
margin = ...    # отступ от среднего
left =  ...     # левая граница интервала
right = ...     # правая граница интервала
delta = ...     # ширина интервала

print(left, right)
192/321:
fig, ax = plt.subplots()
for h in [good, bad]:
    sns.histplot(h, bins=30, ax=ax, kde=False)
192/322:
fig, ax = plt.subplots()
for h in [good, bad]:
    sns.histplot(h, bins=30, ax=ax, kde=False)
192/323: bad
192/324:
good = df[['k1']][df.fraud == 0]
bad = df[['k1']][df.fraud > 0]

good_mean = good.k1.mean()
bad_mean = bad.k1.mean()

diff = good_mean - bad_mean

nu =  ...       # число степеней свободы в распределении Стьюдента
margin = ...    # отступ от среднего
left =  ...     # левая граница интервала
right = ...     # правая граница интервала
delta = ...     # ширина интервала

print(left, right)
192/325: bad
192/326:
fig, ax = plt.subplots()
for h in [good, bad]:
    sns.histplot(h, bins=30, ax=ax, kde=False)
192/327:
fig, ax = plt.subplots()
for h in [good, bad]:
    sns.histplot(h, bins=50, ax=ax, kde=False)
192/328:
fig, ax = plt.subplots()
for h in [good, bad]:
    sns.histplot(h, bins=100, ax=ax, kde=False)
192/329:
good = df[['k1']][df.fraud == 0]
bad = df[['k1']][df.fraud > 0]

good_mean = good.k1.mean()
bad_mean = bad.k1.mean()

diff = good_mean - bad_mean

good_n = good.size
bad_n = bad.size
diff_sd = np.sqrt(good.k1.var()/good_n + bad.k1.var()/ bad_n)

u = (good.k1.var() / good_n + bad.k1.var() / bad_n) ** 2
d = (good.k1.var()**2) / (good_n**2 * (good_n - 1)) + (bad.k1.var()**2)/ (bad_n**2* (bad_n - 1))
nu =  u/d 
print("Число степеней свободы:", nu)

left, right = stats.t.interval(0.95, df=nu, loc=diff, scale=diff_sd)
delta = right - left     # ширина интервала

print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, delta))
192/330: good.k1.std() - bad.k1.std()
192/331:
good = df[['k1']][df.fraud == 0]
bad = df[['k1']][df.fraud > 0]

good_mean = good.k1.mean()
bad_mean = bad.k1.mean()

diff = good_mean - bad_mean

good_n = good.size
bad_n = bad.size
diff_sd = np.sqrt(good.k1.var()/good_n + bad.k1.var()/ bad_n)

u = (good.k1.var() / good_n + bad.k1.var() / bad_n) ** 2
d = (good.k1.var()**2) / (good_n**2 * (good_n - 1)) + (bad.k1.var()**2)/ (bad_n**2* (bad_n - 1))
nu =  u/d 
print("Число степеней свободы:", nu)

left, right = stats.t.interval(0.95, df=nu, loc=diff, scale=diff_sd)
delta = right - left

print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, delta))
192/332: good.k1.std() - bad.k1.std()
192/333:
alpha = 0.05

n = good.k1.count()
var_hat = good.k1.var(ddof=1)

chi_l, chi_u = stats.chi2.ppf([1-alpha/2, alpha/2], df = n-1)

left = (n-1) * var_hat/chi_l
right = (n-1) * var_hat/chi_u

print("Доверительный интервал [{:.5}; {:.5}] ширины {:.5}".format(left, right, right - left))
192/334: good.k1.std()
192/335:
alpha = 0.05

n = good_n
var_hat = good.k1.var(ddof=1)

chi_l, chi_u = stats.chi2.ppf([1-alpha/2, alpha/2], df = n-1)

left = (n-1) * var_hat/chi_l
right = (n-1) * var_hat/chi_u

print("Доверительный интервал [{:.5}; {:.5}] ширины {:.5}".format(left, right, right - left))
192/336:
alpha = 0.05

n = good_n
var_hat = good.k1.var(ddof=1)

chi_l, chi_u = stats.chi2.ppf([1-alpha/2, alpha/2], df = n-1)

left = (n-1) * var_hat/chi_l
right = (n-1) * var_hat/chi_u

print("Доверительный интервал [{:.5}; {:.5}] ширины {:.5}".format(left, right, right - left))
192/337:
alpha = 0.05

n = bad_n
var_hat = bad.k1.var(ddof=1)

chi_l, chi_u = stats.chi2.ppf([1-alpha/2, alpha/2], df = n-1)

left = (n-1) * var_hat/chi_l
right = (n-1) * var_hat/chi_u

print("Доверительный интервал [{:.5}; {:.5}] ширины {:.5}".format(left, right, right - left))
192/338: bad.k1.std()
192/339: good.k1.var()
192/340: bad.k1.var()
192/341: Ноль вошел в доверительный интервал. Это означает, что у хороших и плохих студентов может быть одинаковый разброс оценок
192/342: bad.k1.var()
192/343:
alpha = 0.05
left =  ...     # левая граница интервала
right = ...     # правая граница интервала
delta = ...     # ширина интервала

print(left, right)
192/344:
alpha = 0.05
left =  ...     # левая граница интервала
right = ...     # правая граница интервала
delta = ...     # ширина интервала

print(left, right)
192/345:
alpha = 0.05

n, m = good_n - 1, bad_n - 1
sn, sm = good.k1.var(), bad.k1.var()

ratio = sm / sn

left = ratio * stats.f(n, m).ppf(alpha/2)
right = ratio * stats.f(n, m).ppf(1 - alpha/2)

print("Доверительный интервал [{:.5}; {:.5}] ширины {:.5}".format(left, right, right - left))
192/346:
good = df[['k3']][df.fraud == 0 && df.k3 != 0]
bad = df[['k3']][df.fraud > 0 && df.k3 != 0]


alpha = 0.05
left =  ...     # левая граница интервала
right = ...     # правая граница интервала
delta = ...     # ширина интервала

print(left, right)
192/347:
good = df[['k3']][df.fraud == 0 and df.k3 != 0]
bad = df[['k3']][df.fraud > 0 and df.k3 != 0]


alpha = 0.05
left =  ...     # левая граница интервала
right = ...     # правая граница интервала
delta = ...     # ширина интервала

print(left, right)
192/348:
good = df[['k3']][df.fraud == 0 & df.k3 != 0]
bad = df[['k3']][df.fraud > 0 & df.k3 != 0]


alpha = 0.05
left =  ...     # левая граница интервала
right = ...     # правая граница интервала
delta = ...     # ширина интервала

print(left, right)
192/349:
good = df[['k3']][df.fraud == 0 and df.k3 != 0]
bad = df[['k3']][df.fraud > 0 and df.k3 != 0]


alpha = 0.05
left =  ...     # левая граница интервала
right = ...     # правая граница интервала
delta = ...     # ширина интервала

print(left, right)
192/350: df[['k3']][df.fraud == 0 and df.k3 != 0]
192/351: df[['k3']][df.fraud == 0]
192/352: df[['k3']][df.fraud == 0].apply(lambda x: x!=0)
192/353: df[['k3']][df.fraud == 0].apply(lambda x: x if x!=0 None)
192/354: df[['k3']][df.fraud == 0].filter(lambda x: x!=0)
192/355: df[(df.fraud == 0) & (df.k3 != 0)][['k3']]
192/356:
good = df[(df.fraud == 0) & (df.k3 != 0)][['k3']]
bad = df[(df.fraud > 0) & (df.k3 != 0)][['k3']]


alpha = 0.05
left =  ...     # левая граница интервала
right = ...     # правая граница интервала
delta = ...     # ширина интервала

print(left, right)
192/357: kontr_2 = df[['k2']]
192/358:  df[['k2']]
192/359: kontr_2
192/360:
kontr_2 = df[['k2']]
kontr_3 = df[['k3']]

kontr_2_mean = kontr_2.k2.mean()
kontr_3_mean = kontr_3.k3.mean()

diff = kontr_2_mean - kontr_3_mean

kontr_2_n = kontr_2.size
kontr_3_n = kontr_3.size
diff_sd = np.sqrt(kontr_2.k2.var()/kontr_2_n + kontr_3.k3.var()/ kontr_3_n)

u = (kontr_2.k2.var()/ kontr_2_n + kontr_3.k3.var() / kontr_3_n) ** 2
d = (kontr_2.k2.var()**2) / (kontr_2_n**2 * (kontr_2_n - 1)) + (kontr_3.k3.var()**2)/ (kontr_3_n**2* (kontr_3_n - 1))
nu =  u/d 
print("Число степеней свободы:", nu)

left, right = stats.t.interval(0.95, df=nu, loc=diff, scale=diff_sd)
delta = right - left

print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, delta))
192/361:
kontr_2 = df[['k2']]
kontr_3 = df[['k3']]

kontr_2_mean = kontr_2.k2.mean()
kontr_3_mean = kontr_3.k3.mean()

diff = kontr_2_mean - kontr_3_mean

kontr_2_n = kontr_2.size
kontr_3_n = kontr_3.size
diff_sd = np.sqrt(kontr_2.k2.var()/kontr_2_n + kontr_3.k3.var()/ kontr_3_n)

u = (kontr_2.k2.var()/ kontr_2_n + kontr_3.k3.var() / kontr_3_n) ** 2
d = (kontr_2.k2.var()**2) / (kontr_2_n**2 * (kontr_2_n - 1)) + (kontr_3.k3.var()**2)/ (kontr_3_n**2* (kontr_3_n - 1))
nu =  u/d 

left, right = stats.t.interval(0.95, df=nu, loc=diff, scale=diff_sd)
delta = right - left

print("Доверительный интервал [{:.4}; {:.4}] ширины {:.4}".format(left, right, delta))
192/362: Нет, ноль не входит в доверительный интервал. Средние оценки за третью контр выше, чем за вторую
192/363:
good = df[(df.fraud == 0)]
bad = df[(df.fraud > 0)]
bad
192/364:
good = df[(df.fraud == 0)]
bad = df[(df.fraud > 0)]
bad.size
192/365:
good = df[(df.fraud == 0)]
bad = df[(df.fraud > 0)]
bad.shape()
192/366:
good = df[(df.fraud == 0)]
bad = df[(df.fraud > 0)]
bad.shape
192/367: bad_n
192/368: bad = df[['k1']][df.fraud > 0]
192/369:
bad = df[['k1']][df.fraud > 0]
bad
192/370:
bad = df[['k1']][df.fraud > 0]
bad.shape
192/371:
bad = df[['k1']][df.fraud > 0]
bad.size
192/372:
good = df[(df.fraud == 0)]
bad = df[(df.fraud > 0)]
bad.shape
192/373:
good = df[(df.fraud == 0)]
bad = df[(df.fraud > 0)]
good.shape
192/374:
good = df[(df.fraud == 0)]
bad = df[(df.fraud > 0)]
good_with_k3 = good[df.k3 != 0)]
print('good_with_k3', good_with_k3.shape)
192/375:
good = df[(df.fraud == 0)]
bad = df[(df.fraud > 0)]
good_with_k3 = good[good_with_k3.k3 != 0)]
print('good_with_k3', good_with_k3.shape)
192/376:
good = df[(df.fraud == 0)]
bad = df[(df.fraud > 0)]
good_with_k3 = good[good.k3 != 0)]
print('good_with_k3', good_with_k3.shape)
192/377:
good = df[(df.fraud == 0)]
bad = df[(df.fraud > 0)]
good_with_k3 = good[good.k3 != 0]
print('good_with_k3', good_with_k3.shape)
192/378:
good = df[(df.fraud == 0)]
bad = df[(df.fraud > 0)]
good_with_k3 = good[good.k3 != 0]
bad_with_k3 = bad[bad.k3 != 0]
print('good_with_k3', good_with_k3.shape)
192/379:
good = df[(df.fraud == 0)]
bad = df[(df.fraud > 0)]
good_with_k3 = good[good.k3 != 0]
bad_with_k3 = bad[bad.k3 != 0]
print('bad_with_k3', bad_with_k3.shape)
192/380:
good = df[(df.fraud == 0)]
bad = df[(df.fraud > 0)]
good_with_k3 = good[good.k3 != 0]
bad_with_k3 = bad[bad.k3 != 0]
good_n = good.shape
good_n
192/381:
good = df[(df.fraud == 0)]
bad = df[(df.fraud > 0)]
good_with_k3 = good[good.k3 != 0]
bad_with_k3 = bad[bad.k3 != 0]
good_n = good.shape[0]
good_n
192/382:
good = df[(df.fraud == 0)]
bad = df[(df.fraud > 0)]
good_with_k3 = good[good.k3 != 0]
bad_with_k3 = bad[bad.k3 != 0]

good_n = good.shape[0]
good_with_k3_n = good_with_k3.shape[0]
192/383:
part_good = good_with_k3_n/good_n
part_bad = df[(df.fraud > 0) & (df.k3 != 0)][['k3']]

good_part_k3

alpha = 0.05
left =  ...     # левая граница интервала
right = ...     # правая граница интервала
delta = ...     # ширина интервала

print(left, right)
192/384:
good = df[(df.fraud == 0)]
bad = df[(df.fraud > 0)]
good_with_k3 = good[good.k3 != 0]
bad_with_k3 = bad[bad.k3 != 0]

good_n = good.shape[0]
good_with_k3_n = good_with_k3.shape[0]
part_good
192/385:
part_good = good_with_k3_n/good_n
part_bad = bad_with_k3_n/bad_n

print(f'Доля хороших студентов, которые писали 3 кр {part_good}')


alpha = 0.05
left =  ...     # левая граница интервала
right = ...     # правая граница интервала
delta = ...     # ширина интервала

print(left, right)
192/386:
good = df[(df.fraud == 0)]
bad = df[(df.fraud > 0)]
good_with_k3 = good[good.k3 != 0]
bad_with_k3 = bad[bad.k3 != 0]

good_n = good.shape[0]
good_with_k3_n = good_with_k3.shape[0]

bad_n = bad.shape[0]
bad_with_k3_n = bad_with_k3.shape[0]
192/387:
part_good = good_with_k3_n/good_n
part_bad = bad_with_k3_n/bad_n

print(f'Доля хороших студентов, которые писали 3 кр {part_good}')


alpha = 0.05
left =  ...     # левая граница интервала
right = ...     # правая граница интервала
delta = ...     # ширина интервала

print(left, right)
192/388:
part_good = good_with_k3_n/good_n
part_bad = bad_with_k3_n/bad_n

print(f'Доля хороших студентов, которые писали 3 кр: {part_good}')
print(f'Доля плохих студентов, которые писали 3 кр: {part_good}')



alpha = 0.05
left =  ...     # левая граница интервала
right = ...     # правая граница интервала
delta = ...     # ширина интервала

print(left, right)
192/389:
part_good = good_with_k3_n/good_n
part_bad = bad_with_k3_n/bad_n

print(f'Доля хороших студентов, которые писали 3 кр: {part_good}')
print(f'Доля плохих студентов, которые писали 3 кр: {part_good}')

diff = part_good - part_bad
diff_std = (part_good* (1 - part_good)/good_n) + (part_bad* (1 - part_bad)/bad_n)

z = norm_rv.ppf(1-alpha/2)


alpha = 0.05
left, right =  stats.norm.interval((1-alpha), loc=diff, scale=diff_std )

delta = right - left     # ширина интервала

print("Доверительный интервал [{:.5}; {:.5}] ширины {:.5}".format(left, right, right - left))
192/390:
part_good = good_with_k3_n/good_n
part_bad = bad_with_k3_n/bad_n

print(f'Доля хороших студентов, которые писали 3 кр: {part_good}')
print(f'Доля плохих студентов, которые писали 3 кр: {part_bad}')

diff = part_good - part_bad
diff_std = (part_good* (1 - part_good)/good_n) + (part_bad* (1 - part_bad)/bad_n)

z = norm_rv.ppf(1-alpha/2)


alpha = 0.05
left, right =  stats.norm.interval((1-alpha), loc=diff, scale=diff_std )

delta = right - left     # ширина интервала

print("Доверительный интервал [{:.5}; {:.5}] ширины {:.5}".format(left, right, right - left))
192/391:
part_good = good_with_k3_n/good_n
part_bad = bad_with_k3_n/bad_n

print(f'Доля хороших студентов, которые писали 3 кр: {part_good}')
print(f'Доля плохих студентов, которые писали 3 кр: {part_bad}')

diff = part_good - part_bad
diff_std = (part_good* (1 - part_good)/good_n) + (part_bad* (1 - part_bad)/bad_n)

alpha = 0.05
left, right =  stats.norm.interval((1-alpha), loc=diff, scale=diff_std )

delta = right - left     # ширина интервала

print("Доверительный интервал [{:.5}; {:.5}] ширины {:.5}".format(left, right, right - left))
192/392:
part_good = good_with_k3_n/good_n
part_bad = bad_with_k3_n/bad_n

print(f'Доля хороших студентов, которые писали 3 кр: {part_good}')
print(f'Доля плохих студентов, которые писали 3 кр: {part_bad}')

diff = part_good - part_bad
diff_std = (part_good* (1 - part_good)/good_n) + (part_bad* (1 - part_bad)/bad_n)

alpha = 0.05
left, right =  stats.norm.interval((1-alpha), loc=diff, scale=diff_std )

delta = right - left     # ширина интервала

print("Доверительный интервал [{:.5}; {:.5}] ширины {:.5}".format(left, right, right - left))
192/393:
part_good = good_with_k3_n/good_n
part_bad = bad_with_k3_n/bad_n

print(f'Доля хороших студентов, которые писали 3 кр: {part_good}')
print(f'Доля плохих студентов, которые писали 3 кр: {part_bad}')

diff = part_good - part_bad
diff_std = (part_good* (1 - part_good)/good_n) + (part_bad* (1 - part_bad)/bad_n)

alpha = 0.05
left, right =  stats.norm.interval((1-alpha), loc=diff, scale=diff_std )

delta = right - left     # ширина интервала

print("Доверительный интервал [{:.5}; {:.5}] ширины {:.5}".format(left, right, right - left))
192/394:
part_good = good_with_k3_n/good_n
part_bad = bad_with_k3_n/bad_n

print(f'Доля хороших студентов, которые писали 3 кр: {part_good}')
print(f'Доля плохих студентов, которые писали 3 кр: {part_bad}')

diff = part_good - part_bad
diff_std = (part_good* (1 - part_good)/good_n) + (part_bad* (1 - part_bad)/bad_n)

alpha = 0.05
left, right =  stats.norm.interval((1-alpha), loc=diff, scale=diff_std )

delta = right - left     # ширина интервала

print("Доверительный интервал [{:.5}; {:.5}] ширины {:.5}".format(left, right, right - left))
192/395:
n_hat = df.shape[0]   # число наблюдений 
lam_hat = np.mean(df['count'])         # ваша оценка метода моментов
lam_se = np.sqrt(lam_hat/n_hat)         # ваша оценка

alpha = 0.1         # уровень значимость

norm_rv = stats.norm(loc=0, scale=1)
z = norm_rv.ppf(1-alpha/2)

left = lam_hat - z*lam_se          # левая граница дов. интервала
right = lam_hat + z*lam_se        # правая граница дов. интервала
delta = right - left         # ширина дов. интервала

print(left, right)
print('Ширина доверительного интервала', delta)
192/396:
df = pd.read_csv("./data/coals.csv", index_col=0)
df.head()
192/397:
n_hat = df.shape[0]   # число наблюдений 
lam_hat = np.mean(df['count'])         # ваша оценка метода моментов
lam_se = np.sqrt(lam_hat/n_hat)         # ваша оценка

alpha = 0.1         # уровень значимость

norm_rv = stats.norm(loc=0, scale=1)
z = norm_rv.ppf(1-alpha/2)

left = lam_hat - z*lam_se          # левая граница дов. интервала
right = lam_hat + z*lam_se        # правая граница дов. интервала
delta = right - left         # ширина дов. интервала

print(left, right)
print('Ширина доверительного интервала', delta)
192/398: stats.norm.interval(0.95, loc=lam_hat, scale=lam_se)
192/399:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

g_der = (np.exp(-lam_hat)*lam_hat**(k-1)*(-lam_hat + k)/factorial(k))**2
g_std = (lam_hat/n_hat * g_der)**0.5 


z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*g_std
right = g_mu  + z*g_std
delta = right - left


print(right - left )
192/400:
alpha = 0.05

k = 1
g_mu = poiss_prob(lam_hat)

g_der = (np.exp(-lam_hat)*lam_hat**(k-1)*(-lam_hat + k)/factorial(k))**2
g_std = (lam_hat/n_hat * g_der)**0.5 


z = norm_rv.ppf(1-alpha/2)
left = g_mu - z*g_std
right = g_mu  + z*g_std
delta = right - left


print(right - left )
192/401:
def prob_ci(k, alpha = 0.01, lam_hat=lam_hat):
    g_mu = poiss_prob(lam_hat)

    g_der = (np.exp(-lam_hat)*lam_hat**(k-1)*(-lam_hat + k)/factorial(k))**2
    g_std = (lam_hat/n_hat * g_der)**0.5

    z = norm_rv.ppf(1-alpha/2)
    left = g_mu - z*g_std
    right = g_mu  + z*g_std

    return left, right
192/402:
poiss_rv = sts.poisson(lam_hat)

x = np.arange(10)

p = poiss_rv.pmf(x)
left, right = prob_ci(x)

plt.figure(figsize=(10,5))
plt.plot(x, p, 'bo', ms=6, label='poisson pmf')
plt.fill_between(x, left, right, alpha=0.5)
plt.vlines(x, 0, p, lw=1)
plt.legend(loc='best', frameon=False)
plt.show()
195/1:
import matplotlib.pyplot as plt
import numpy as np
import pandas

%matplotlib inline
195/2: plt.rcParams['figure.figsize'] = (8, 5)
195/3:
np.random.seed(13)
X1 = np.random.randn(100,2)
X2 = np.random.randn(100,2) - np.array([10,1])
X3 = np.random.randn(100,2) - np.array([1,10])
X = np.vstack((X1,X2,X3))
195/4:
plt.scatter(X[:,0], X[:,1])
plt.title('Data')
plt.show()
195/5:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    # your code here
    return y

centers = (np.arange(6)*0.05).reshape(3, 2)
assert np.allclose(
    compute_clusters(X, centers), 
    np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
       2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
       0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
       2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
       2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
)
195/6:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
assert np.allclose(
    compute_clusters(X, centers), 
    np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
       2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
       0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
       2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
       2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
)
centers
195/7:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
centers
195/8:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
centers
X
195/9:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
centers
195/10: X
195/11: X.head()
195/12: X
195/13:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
centers
195/14:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
centers
195/15:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    for x value in np.ndenumerate(X):
        print x
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
centers
195/16:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    for index, x in np.ndenumerate(X):
        print x
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
# centers
195/17:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    for index, x in np.ndenumerate(X):
        print('index x', inde x)
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
# centers
195/18:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    for index, x in np.ndenumerate(X):
        print('index x', index, x)
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
# centers
195/19:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    for index, x in np.ndenumerate(X):
        print('index x', index, x)
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
compute_clusters(X, centers)
195/20:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    for point in X:
        print('point', point)
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
compute_clusters(X, centers)
195/21:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    for point in X:
        point_center_dist = pairwise_distances(point, centers)
        print('point', point)
        print('point_center_dist',  point_center_dist)
        print(/n)
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
compute_clusters(X, centers)
195/22:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    for point in X:
        point_center_dist = pairwise_distances(point, centers)
        print('point', point)
        print('point_center_dist',  point_center_dist)
        print(\n)
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
compute_clusters(X, centers)
195/23:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    for point in X:
        point_center_dist = pairwise_distances(point, centers)
        print('point', point)
        print('point_center_dist',  point_center_dist)
        print('/n')
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
compute_clusters(X, centers)
195/24:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    for point in X:
        point_center_dist = pairwise_distances(point, centers)
        print('point', point)
        print('point_center_dist',  point_center_dist)
        print('\n')
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
compute_clusters(X, centers)
195/25:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    for point in X:
        point_center_dist = pairwise_distances(point, centers)
        print('point', point)
        print('point_center_dist',  point_center_dist)
        print('___')
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
compute_clusters(X, centers)
195/26: from sklearn.metrics import pairwise_distances
195/27:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    for point in X:
        point_center_dist = pairwise_distances(point, centers)
        print('point', point)
        print('point_center_dist',  point_center_dist)
        print('___')
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
compute_clusters(X, centers)
195/28:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    for point in X:
        p = point.reshape(-1, 1)
        point_center_dist = pairwise_distances(p, centers)
        print('point', point)
        print('point_center_dist',  point_center_dist)
        print('___')
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
compute_clusters(X, centers)
195/29:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
#     for point in X:
#         p = point.reshape(-1, 1)
        point_center_dist = pairwise_distances(X, centers)
#         print('point', point)
        print('point_center_dist',  point_center_dist)
#         print('___')
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
compute_clusters(X, centers)
195/30:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
#     for point in X:
#         p = point.reshape(-1, 1)
    point_center_dist = pairwise_distances(X, centers)
#         print('point', point)
        print('point_center_dist',  point_center_dist)
#         print('___')
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
compute_clusters(X, centers)
195/31:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
#     for point in X:
#         p = point.reshape(-1, 1)
    point_center_dist = pairwise_distances(X, centers)
#         print('point', point)
    print('point_center_dist',  point_center_dist)
#         print('___')
    
    
#     return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
compute_clusters(X, centers)
195/32:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    point_center_distances = pairwise_distances(X, centers)
    y = np.argmin(point_center_distances, axis=1)
    print(y)
    return y

centers = (np.arange(6)*0.05).reshape(3, 2)
# assert np.allclose(
#     compute_clusters(X, centers), 
#     np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
#        2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
#        0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
#        2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
#        2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# )
compute_clusters(X, centers)
195/33:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    point_center_distances = pairwise_distances(X, centers)
    y = np.argmin(point_center_distances, axis=1)
    print(y)
    return y

centers = (np.arange(6)*0.05).reshape(3, 2)
assert np.allclose(
    compute_clusters(X, centers), 
    np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
       2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
       0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
       2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
       2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
)
195/34:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    point_center_distances = pairwise_distances(X, centers)
    y = np.argmin(point_center_distances, axis=1)
    print(y)
    return y

centers = (np.arange(6)*0.05).reshape(3, 2)
assert np.allclose(
    compute_clusters(X, centers), 
    np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
       2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
       0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
       2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
       2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
)
195/35:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    point_center_distances = pairwise_distances(X, centers)
    y = np.argmin(point_center_distances, axis=1)
    return y

centers = (np.arange(6)*0.05).reshape(3, 2)
assert np.allclose(
    compute_clusters(X, centers), 
    np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
       2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
       0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
       2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
       2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
)
195/36:
km = KMeans(3)
km.fit(X, visualize=True)
y = km.transform(X)
195/37: X.shape
195/38: X.shape[0]
195/39:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0] # your code here
        num_feat = X.shape[1] # your code here
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.full((1, num_obj), 0) # your code here
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = # your code here
        
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                self.centers[cl] = # your code here
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = # your code here
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
    def transform(self, X):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
        OUTPUT:
        y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
        """        
        # your code here
        return y_pred
195/40:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.full((1, num_obj), 0)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = # your code here
        
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                self.centers[cl] = # your code here
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = # your code here
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
    def transform(self, X):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
        OUTPUT:
        y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
        """        
        # your code here
        return y_pred
195/41: y = np.empty([1, 10])
195/42:
y = np.empty([1, 10])
y
195/43:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.empty([1, num_obj])
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((n_clusters, num_feat))
        
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                self.centers[cl] = # your code here
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = # your code here
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
    def transform(self, X):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
        OUTPUT:
        y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
        """        
        # your code here
        return y_pred
195/44: centers = np.zeros((3, 2))
195/45:
centers = np.zeros((3, 2))
centers
196/1:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.empty([1, num_obj])
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((n_clusters, num_feat))
        print('self.centers', self.centers)
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                self.centers[cl] = # your code here
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = # your code here
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
    def transform(self, X):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
        OUTPUT:
        y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
        """        
        # your code here
        return y_pred
196/2:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.empty([1, num_obj])
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((n_clusters, num_feat))
        print('self.centers', self.centers)
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
#                 self.centers[cl] = # your code here
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = # your code here
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
    def transform(self, X):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
        OUTPUT:
        y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
        """        
        # your code here
        return y_pred
196/3:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.empty([1, num_obj])
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((n_clusters, num_feat))
        print('self.centers', self.centers)
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
#                 self.centers[cl] = # your code here
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
#             y = # your code here
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
    def transform(self, X):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
        OUTPUT:
        y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
        """        
        # your code here
        return y_pred
196/4:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.empty([1, num_obj])
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((n_clusters, num_feat))
        print('self.centers', self.centers)
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
#                 self.centers[cl] = # your code here
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
#             y = # your code here
            
            # Поддержка флага visualize
#             if visualize:
#                 plt.figure(figsize=(5,5))
#                 plt.scatter(X[:, 0], X[:, 1], c=y)
#                 plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
#                 plt.title('Step {}'.format(n_iter + 1))
#                 plt.show()
    
    def transform(self, X):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
        OUTPUT:
        y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
        """        
        # your code here
        return y_pred
196/5:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.empty([1, num_obj])
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((n_clusters, num_feat))
        print('self.centers', self.centers)
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
#                 self.centers[cl] = # your code here
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
#             y = # your code here
            
            # Поддержка флага visualize
#             if visualize:
#                 plt.figure(figsize=(5,5))
#                 plt.scatter(X[:, 0], X[:, 1], c=y)
#                 plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
#                 plt.title('Step {}'.format(n_iter + 1))
#                 plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/6:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.empty([1, num_obj])
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((n_clusters, num_feat))
        print('self.centers', self.centers)
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
#                 self.centers[cl] = # your code here
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
#             y = # your code here
            
            # Поддержка флага visualize
#             if visualize:
#                 plt.figure(figsize=(5,5))
#                 plt.scatter(X[:, 0], X[:, 1], c=y)
#                 plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
#                 plt.title('Step {}'.format(n_iter + 1))
#                 plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
        return y_pred
196/7:
import matplotlib.pyplot as plt
import numpy as np
import pandas

%matplotlib inline
196/8: plt.rcParams['figure.figsize'] = (8, 5)
196/9:
np.random.seed(13)
X1 = np.random.randn(100,2)
X2 = np.random.randn(100,2) - np.array([10,1])
X3 = np.random.randn(100,2) - np.array([1,10])
X = np.vstack((X1,X2,X3))
196/10: from sklearn.metrics import pairwise_distances
196/11:
def compute_clusters(X, centers):
    """
    INPUT:
    X - np.array, (n_objects x n_features) - матрица объекты-признаки
    centers - np.array, (n_clusters x n_features) - матрица, содержащая координаты центров кластеров
    
    OUTPUT:
    y - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
    """
    point_center_distances = pairwise_distances(X, centers)
    y = np.argmin(point_center_distances, axis=1)
    return y

centers = (np.arange(6)*0.05).reshape(3, 2)
assert np.allclose(
    compute_clusters(X, centers), 
    np.array([0, 2, 2, 2, 2, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0,
       2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0,
       0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0,
       2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0,
       2, 1, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
)
196/12: centers
196/13:
cen = np.zeros((3, 2))
cen
196/14:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.empty([1, num_obj])
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((n_clusters, num_feat))
        
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                self.centers[cl] = np.sum(self.centers[cl], axis=0)/(self.centers[cl].size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/15:
km = KMeans(3)
km.fit(X, visualize=True)
y = km.transform(X)
196/16:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.empty([1, num_obj])
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
        
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                self.centers[cl] = np.sum(self.centers[cl], axis=0)/(self.centers[cl].size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/17:
km = KMeans(3)
km.fit(X, visualize=True)
y = km.transform(X)
196/18:
km = KMeans(3)
km.fit(X, visualize=True)
# y = km.transform(X)
196/19:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.empty([1, num_obj])
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
        print(self.centers)
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                self.centers[cl] = np.sum(self.centers[cl], axis=0)/(self.centers[cl].size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/20:
km = KMeans(3)
km.fit(X, visualize=True)
# y = km.transform(X)
196/21:
km = KMeans(3)
km.fit(X, visualize=False)
# y = km.transform(X)
196/22:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.empty([1, num_obj])
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
        print(y)
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                self.centers[cl] = np.sum(self.centers[cl], axis=0)/(self.centers[cl].size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/23:
km = KMeans(3)
km.fit(X, visualize=False)
# y = km.transform(X)
196/24:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(2, size=10)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
        print(y)
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                self.centers[cl] = np.sum(self.centers[cl], axis=0)/(self.centers[cl].size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/25:
km = KMeans(3)
km.fit(X, visualize=False)
# y = km.transform(X)
196/26:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
        print(y)
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                self.centers[cl] = np.sum(self.centers[cl], axis=0)/(self.centers[cl].size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/27:
km = KMeans(3)
km.fit(X, visualize=False)
# y = km.transform(X)
196/28:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
        print(y)
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                print('cl', cl)
                self.centers[cl] = np.sum(self.centers[cl], axis=0)/(self.centers[cl].size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/29:
km = KMeans(3)
km.fit(X, visualize=False)
# y = km.transform(X)
196/30:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
        print(y)
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                get_sum = X[y == cl]
                print(get_sum)
                self.centers[cl] = np.sum(self.centers[cl], axis=0)/(self.centers[cl].size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/31:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
        print(y)
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                get_sum = X[y == cl]
                print('get_sum', get_sum)
                self.centers[cl] = np.sum(self.centers[cl], axis=0)/(self.centers[cl].size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/32:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
        print(y)
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                get_sum = X[y == cl]
                print('get_sum', get_sum)
                self.centers[cl] = np.sum(self.centers[cl], axis=0)/(self.centers[cl].size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/33:
km = KMeans(3)
km.fit(X, visualize=False)
# y = km.transform(X)
196/34:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
        print(y)
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                get_sum = X[y == cl]
                print('[y == cl]', y[y == cl].size)
                print('get_sum', get_sum.size)
                self.centers[cl] = np.sum(self.centers[cl], axis=0)/(self.centers[cl].size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/35:
km = KMeans(3)
km.fit(X, visualize=False)
# y = km.transform(X)
196/36:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
        print(y)
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                get_sum = X[y == cl]
                print('[y == cl]', y[y == cl].size)
                print('get_sum', get_sum.size)
#                 self.centers[cl] = np.sum(self.centers[cl], axis=0)/(self.centers[cl].size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
#             y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/37:
km = KMeans(3)
km.fit(X, visualize=False)
# y = km.transform(X)
196/38:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
        print(y)
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                get_sum = X[y == cl]
                print('[y == cl]', y[y == cl].shape)
                print('get_sum', get_sum.shape)
#                 self.centers[cl] = np.sum(self.centers[cl], axis=0)/(self.centers[cl].size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
#             y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/39:
km = KMeans(3)
km.fit(X, visualize=False)
# y = km.transform(X)
196/40:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
        print(y)
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                get_sum = X[y == cl]
                get_size = get_sum.shape[0]
                self.centers[cl] = np.sum(get_sum, axis=1)/(get_size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/41:
km = KMeans(3)
km.fit(X, visualize=False)
# y = km.transform(X)
196/42:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
        print(y)
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                get_cluster_elements = X[y == cl]
                get_size = get_sum.shape[0]
                get_sum = np.sum(get_cluster_elements, axis=1)
                print('get_sum', get_sum)
                print('get_size', get_size)
                self.centers[cl] = get_sum/(get_size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/43:
km = KMeans(3)
km.fit(X, visualize=False)
# y = km.transform(X)
196/44:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
 
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                get_cluster_elements = X[y == cl]
                get_size = get_sum.shape[0]
                get_sum = np.sum(get_cluster_elements, axis=1)
                print('get_sum', get_sum)
                print('get_size', get_size)
                self.centers[cl] = get_sum/(get_size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/45:
km = KMeans(3)
km.fit(X, visualize=False)
# y = km.transform(X)
196/46:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
 
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                get_cluster_elements = X[y == cl]
                get_size = get_cluster_elements.shape[0]
                get_sum = np.sum(get_cluster_elements, axis=1)
                print('get_sum', get_sum)
                print('get_size', get_size)
                self.centers[cl] = get_sum/(get_size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/47:
km = KMeans(3)
km.fit(X, visualize=False)
# y = km.transform(X)
196/48:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
 
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                get_cluster_elements = X[y == cl]
                get_size = get_cluster_elements.shape[0]
                get_sum = np.sum(get_cluster_elements, axis=0)
                print('get_sum', get_sum)
                print('get_size', get_size)
                self.centers[cl] = get_sum/(get_size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/49:
km = KMeans(3)
km.fit(X, visualize=False)
# y = km.transform(X)
196/50:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
 
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                get_cluster_elements = X[y == cl]
                get_size = get_cluster_elements.shape[0]
                get_sum = np.sum(get_cluster_elements, axis=0)
                self.centers[cl] = get_sum/(get_size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
#     def transform(self, X):
#         """
#         INPUT:
#         X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
#         OUTPUT:
#         y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
#     на i-ом месте стоит метка кластера для i-ого объекта выборки X
#         """        
#         # your code here
#         return y_pred
196/51:
km = KMeans(3)
km.fit(X, visualize=True)
# y = km.transform(X)
196/52:
km = KMeans(3)
km.fit(X, visualize=True)
y = km.transform(X, self.n_clusters)
196/53:
plt.figure(figsize=(10,10))
plt.scatter(X[:,0], X[:,1], c=y)
plt.show()
196/54:
km = KMeans(3)
km.fit(X, visualize=True)
y = km.transform(X)
196/55:
km = KMeans(3)
km.fit(X, visualize=True)
y = km.transform(X)
196/56:
plt.figure(figsize=(10,10))
plt.scatter(X[:,0], X[:,1], c=y)
plt.show()
196/57:
plt.figure(figsize=(10,10))
plt.scatter(X[:,0], X[:,1], c=y)
plt.show()
196/58:
plt.figure(figsize=(10,10))
plt.scatter(X[:,0], X[:,1], c=y)
plt.show()
196/59:
plt.figure(figsize=(10,10))
plt.scatter(X[:,0], X[:,1], c=y)
plt.show()
196/60: y
196/61:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
 
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                get_cluster_elements = X[y == cl]
                get_size = get_cluster_elements.shape[0]
                get_sum = np.sum(get_cluster_elements, axis=0)
                self.centers[cl] = get_sum/(get_size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
    def transform(self, X):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
        OUTPUT:
        y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
        """        
        y_pred = compute_clusters(X, self.n_clusters)
        print('y_pred', y_pred)
        return y_pred
196/62:
km = KMeans(3)
km.fit(X, visualize=True)
y = km.transform(X)
196/63:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
 
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                get_cluster_elements = X[y == cl]
                get_size = get_cluster_elements.shape[0]
                get_sum = np.sum(get_cluster_elements, axis=0)
                self.centers[cl] = get_sum/(get_size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
    def transform(self, X):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
        OUTPUT:
        y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
        """        
        y_pred = compute_clusters(X, self.centers)
        print('y_pred', y_pred)
        return y_pred
196/64:
km = KMeans(3)
km.fit(X, visualize=True)
y = km.transform(X)
196/65: y
196/66:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
 
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                get_cluster_elements = X[y == cl]
                get_size = get_cluster_elements.shape[0]
                get_sum = np.sum(get_cluster_elements, axis=0)
                self.centers[cl] = get_sum/(get_size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
    def transform(self, X):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
        OUTPUT:
        y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
        """        
        y_pred = compute_clusters(X, self.centers)
        return y_pred
196/67:
km = KMeans(3)
km.fit(X, visualize=True)
y = km.transform(X)
196/68:
plt.figure(figsize=(10,10))
plt.scatter(X[:,0], X[:,1], c=y)
plt.show()
196/69: from sklearn.datasets import load_digits
196/70: digits = load_digits()
196/71: digits = digits["data"]
196/72: digits.shape
196/73:
# Каждый объект - изображение цифры размеров 8 x 8
plt.imshow(digits[0].reshape(8, 8), cmap="gray")
plt.show()
196/74:
from sklearn.cluster import KMeans
from sklearn.cluster import DBSCAN
from sklearn.metrics import silhouette_score
196/75:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
 
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                get_cluster_elements = X[y == cl]
                get_size = get_cluster_elements.shape[0]
                get_sum = np.sum(get_cluster_elements, axis=0)
                self.centers[cl] = get_sum/(get_size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
    def transform(self, X):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
        OUTPUT:
        y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
        """        
        y_pred = compute_clusters(X, self.centers)
        return y_pred
196/76:
km = KMeans(3)
km.fit(X, visualize=True)
y = km.transform(X)
196/77:
class KMeans:
    def __init__(self, n_clusters):
        # гиперпараметр - количество кластеров
        self.n_clusters = n_clusters
        
    def fit(self, X, max_iter=10, visualize=False):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        max_iter - int - максимальное число итераций
        visualize - bool - визуализировать ли объекты и центры кластеров на каждой итерации 
        """
        # Цель: обучить центры кластеров self.centers, форма: число кластеров x число признаков
        
        # Шаг 1: сколько объектов и признаков?
        num_obj = X.shape[0]
        num_feat = X.shape[1]
        
        # Шаг 2: инициализируйте y - вектор длины n_objects, 
        # хранящий, к какому кластеру относится каждый объект
        # каждый элемент - случайно выбранный номер кластера 
        y = np.random.randint(self.n_clusters, size=num_obj)
        
        # Шаг 3: создайте матрицу для хранения центров кластеров
        self.centers = np.zeros((self.n_clusters, num_feat))
 
        epsilon = 1e-6
        for n_iter in range(max_iter):
            # Шаг 4: обновите центры кластеров
            for cl in range(self.n_clusters):
                get_cluster_elements = X[y == cl]
                get_size = get_cluster_elements.shape[0]
                get_sum = np.sum(get_cluster_elements, axis=0)
                self.centers[cl] = get_sum/(get_size + epsilon)
            
            # Шаг 5: обновите y. Для этого вычислите расстояния между всеми объектами 
            # и центрами кластеров (используйте pairwise_distances), 
            # затем найдите ближайший к каждому объекту кластер
            
            y = compute_clusters(X, self.centers)
            
            # Поддержка флага visualize
            if visualize:
                plt.figure(figsize=(5,5))
                plt.scatter(X[:, 0], X[:, 1], c=y)
                plt.scatter(self.centers[:, 0], self.centers[:, 1], c='red', marker='x')
                plt.title('Step {}'.format(n_iter + 1))
                plt.show()
    
    def transform(self, X):
        """
        INPUT:
        X - np.array, (n_objects x n_features) - матрица объекты-признаки
        
        OUTPUT:
        y_pred - np.array, (n_objects,) - вектор, состоящий из меток кластеров (0, 1, ..., self.n_clusters-1), где
    на i-ом месте стоит метка кластера для i-ого объекта выборки X
        """        
        y_pred = compute_clusters(X, self.centers)
        return y_pred
196/78:
km = KMeans(3)
km.fit(X, visualize=True)
y = km.transform(X)
196/79:
km = KMeans(3)
km.fit(X, visualize=True)
y = km.transform(X)
196/80:
plt.figure(figsize=(10,10))
plt.scatter(X[:,0], X[:,1], c=y)
plt.show()
196/81:
k_means = KMeans(n_clusters=3)
k_means = k_means.fit(X)
clusters = k_means.predict(X)
print('Silhouette score:', silhouette_score(X, clusters))
196/82:
X = digits
X
196/83:
k_means = KMeans(n_clusters=3)
k_means = k_means.fit(X)
clusters = k_means.predict(X)
print('Silhouette score:', silhouette_score(X, clusters))
196/84:
k_means = KMeans(n_clusters=3)
k_means = k_means.fit(X)
# clusters = k_means.predict(X)
print('Silhouette score:', silhouette_score(X, clusters))
196/85:
k_means = KMeans(n_clusters=3)
k_means = k_means.fit(X)
# clusters = k_means.predict(X)
# print('Silhouette score:', silhouette_score(X, clusters))
196/86:
k_means = KMeans(n_clusters=3)
k_means = k_means.fit(X)
clusters = k_means.predict(X)
# print('Silhouette score:', silhouette_score(X, clusters))
196/87:
python -c "from sklearn import show_versions; show_versions()"
python -m threadpoolctl -i numpy
python -m threadpoolctl -i sklearn
196/88:

python -m threadpoolctl -i numpy
python -m threadpoolctl -i sklearn
196/89:
k_means = KMeans(n_clusters=3)
k_means = k_means.fit(X)
clusters = k_means.predict(X)
print('Silhouette score:', silhouette_score(X, clusters))
196/90:
X = digits
X
elbow = elbow_method(data_standardized,10)
196/91:
X = digits
X
196/92:
k_means = KMeans(n_clusters=3)
k_means = k_means.fit(X)
clusters = k_means.predict(X)
196/93:
dbscan = DBSCAN(eps=0.15, min_samples=10)
clusters = dbscan.fit_predict(X)
196/94:
dbscan = DBSCAN(eps=0.15, min_samples=10)
clusters = dbscan.fit_predict(X)
print('Silhouette score:', silhouette_score(X, clusters))
196/95:
dbscan = DBSCAN(eps=0.15, min_samples=10)
clusters = dbscan.fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()
196/96:
dbscan = DBSCAN(eps=0.15, min_samples=10)
clusters = dbscan.fit_predict(X)
print('Silhouette score:', silhouette_score(X, clusters))
196/97:
dbscan = DBSCAN(eps=0.15, min_samples=10)
clusters = dbscan.fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()
196/98:
dbscan = DBSCAN(eps=0.15, min_samples=100)
clusters = dbscan.fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()

# получился только 1 кластер, но значение силуэта показывает, 
# насколько объект похож на свой кластер по сравнению с другими кластерами. Будет ошибка при пример
196/99:
dbscan = DBSCAN(eps=0.15, min_samples=1)
clusters = dbscan.fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()

# получился только 1 кластер, но значение силуэта показывает, 
# насколько объект похож на свой кластер по сравнению с другими кластерами. Будет ошибка при пример
196/100:
dbscan = DBSCAN(eps=0.05, min_samples=1)
clusters = dbscan.fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()

# получился только 1 кластер, но значение силуэта показывает, 
# насколько объект похож на свой кластер по сравнению с другими кластерами. Будет ошибка при пример
196/101:
dbscan = DBSCAN(eps=0.05, min_samples=1)
clusters = dbscan.fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()
print('Silhouette score:', silhouette_score(X, clusters))
# получился только 1 кластер, но значение силуэта показывает, 
# насколько объект похож на свой кластер по сравнению с другими кластерами. Будет ошибка при пример
196/102:
dbscan = DBSCAN(eps=0.05, min_samples=2)
clusters = dbscan.fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()
print('Silhouette score:', silhouette_score(X, clusters))
# получился только 1 кластер, но значение силуэта показывает, 
# насколько объект похож на свой кластер по сравнению с другими кластерами. Будет ошибка при пример
196/103:
dbscan = DBSCAN(eps=0.05, min_samples=1)
clusters = dbscan.fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()
print('Silhouette score:', silhouette_score(X, clusters))
# получился только 1 кластер, но значение силуэта показывает, 
# насколько объект похож на свой кластер по сравнению с другими кластерами. Будет ошибка при пример
196/104:
dbscan = DBSCAN(eps=0.05, min_samples=5)
clusters = dbscan.fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()
print('Silhouette score:', silhouette_score(X, clusters))
# получился только 1 кластер, но значение силуэта показывает, 
# насколько объект похож на свой кластер по сравнению с другими кластерами. Будет ошибка при пример
196/105:
dbscan = DBSCAN(eps=1-10e6, min_samples=5)
clusters = dbscan.fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()
print('Silhouette score:', silhouette_score(X, clusters))
# получился только 1 кластер, но значение силуэта показывает, 
# насколько объект похож на свой кластер по сравнению с другими кластерами. Будет ошибка при примении метрики
196/106:
dbscan = DBSCAN(eps=0.0001, min_samples=5)
clusters = dbscan.fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()
print('Silhouette score:', silhouette_score(X, clusters))
# получился только 1 кластер, но значение силуэта показывает, 
# насколько объект похож на свой кластер по сравнению с другими кластерами. Будет ошибка при примении метрики
196/107:
dbscan = DBSCAN(eps=0.15, min_samples=5)
clusters = dbscan.fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()
print('Silhouette score:', silhouette_score(X, clusters))
# получился только 1 кластер, но значение силуэта показывает, 
# насколько объект похож на свой кластер по сравнению с другими кластерами. Будет ошибка при примении метрики
196/108:
k_means = KMeans(n_clusters=3)
k_means = k_means.fit(X)
clusters = k_means.predict(X)
# print('Silhouette score:', silhouette_score(X, clusters))
196/109:
k_means = KMeans(n_clusters=3)
# k_means = k_means.fit(X)
clusters = k_means.predict(X)
# print('Silhouette score:', silhouette_score(X, clusters))
196/110:
k_means = KMeans(n_clusters=3)
k_means = k_means.fit(X)
clusters = k_means.predict(X)
# print('Silhouette score:', silhouette_score(X, clusters))
196/111:
n_samples, n_features = data.shape
n_digits = len(np.unique(digits.target))
196/112:
n_samples, n_features = X.shape
n_digits = len(np.unique(digits.target))
196/113:
n_samples, n_features = X.shape
n_digits = len(np.unique(X.target))
196/114:
n_samples, n_features = X.shape
n_digits = len(np.unique(digits.target))
196/115:
n_samples, n_features = X.shape
n_digits = len(np.unique(digits))
196/116: n_digits
196/117: n_samples
196/118: n_digits
196/119:
k_means = KMeans(n_clusters=n_digits)
k_means = k_means.fit(X)
clusters = k_means.predict(X)
# print('Silhouette score:', silhouette_score(X, clusters))
196/120:
k_means = KMeans(n_clusters=n_digits)
k_means = k_means.fit(X)
# clusters = k_means.predict(X)
# print('Silhouette score:', silhouette_score(X, clusters))
196/121:
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.scatter(k_means.cluster_centers_[:, 0], k_means.cluster_centers_[:, 1], color='red', marker='x', s=200)
plt.title('K-means clustering')
plt.show()
196/122:
k_means = KMeans(n_clusters=n_digits)
k_means = k_means.fit(X)
# clusters = k_means.predict(X)
# print('Silhouette score:', silhouette_score(X, clusters))
196/123:
k_means = KMeans(n_clusters=n_digits)
k_means = k_means.fit(X)
clusters = k_means.predict(X)
# print('Silhouette score:', silhouette_score(X, clusters))
196/124:
k_means = KMeans(n_clusters=10)
k_means = k_means.fit(X)
clusters = k_means.predict(X)
# print('Silhouette score:', silhouette_score(X, clusters))
196/125:
k_means = KMeans(n_clusters=10)
# k_means = k_means.fit(X)
# clusters = k_means.predict(X)
pred_y = kmeans.fit_predict(X)
# print('Silhouette score:', silhouette_score(X, clusters))
196/126:
k_means = KMeans(n_clusters=10)
# k_means = k_means.fit(X)
# clusters = k_means.predict(X)
pred_y = kmeans.fit_predict(X)
# print('Silhouette score:', silhouette_score(X, clusters))
196/127:
k_means = KMeans(n_clusters=10)
# k_means = k_means.fit(X)
# clusters = k_means.predict(X)
pred_y = k_means.fit_predict(X)
# print('Silhouette score:', silhouette_score(X, clusters))
196/128:
k_means = KMeans(n_clusters=10)
k_means = k_means.fit(X)
clusters = k_means.predict(X)

# print('Silhouette score:', silhouette_score(X, clusters))
196/129:
dbscan = DBSCAN(eps=0.15, min_samples=11)
clusters = dbscan.fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()
print('Silhouette score:', silhouette_score(X, clusters))
# получился только 1 кластер, но значение силуэта показывает, 
# насколько объект похож на свой кластер по сравнению с другими кластерами. Будет ошибка при примении метрики
196/130:
random_idx = np.random.choice(len(X), size=5)
random_digits = X[random_idx, :].reshape(-1, 8, 8)
random_labels = y[random_idx]
fig, ax = plt.subplots(1, 5, figsize=(15, 6))
for i, d in enumerate(random_digits):
    ax[i].imshow(d, cmap='gray_r')
    ax[i].set_title(random_labels[i])
196/131: v
196/132: X
196/133: digits
196/134:
X = digits.to_numpy()
X
196/135:
k_means = KMeans(n_clusters=10)
k_means = k_means.fit(X)
clusters = k_means.predict(X)

# print('Silhouette score:', silhouette_score(X, clusters))
197/1:
%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
197/2: plt.rcParams['figure.figsize'] = [11, 8]
197/3:
from sklearn.cluster import KMeans

np.random.seed(123)
X1 = np.random.randn(100, 2)
X2 = np.random.randn(100, 2) - np.array([10 ,1])
X3 = np.random.randn(100, 2) - np.array([1, 10])
X = np.vstack((X1, X2, X3))
y = np.array([1] * 100 + [2] * 100 + [3] * 100)
197/4:
k_means = KMeans(n_clusters=3)
k_means = k_means.fit(X)
clusters = k_means.predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.scatter(k_means.cluster_centers_[:, 0], k_means.cluster_centers_[:, 1], color='red', marker='x', s=200)
plt.title('K-means clustering')
plt.show()
197/5:
plt.figure(figsize=(15, 8))
for n_c in range(2, 8):
    k_means = KMeans(n_clusters=n_c)
    k_means = k_means.fit(X)
    clusters = k_means.predict(X)
    plt.subplot(2,3, n_c - 1)
    plt.scatter(X[:,0], X[:,1], c=clusters)
    plt.scatter(k_means.cluster_centers_[:, 0], k_means.cluster_centers_[:, 1], color='red', marker='x', s=200)
    plt.title('n_clusters = {}'.format(n_c))

plt.show()
197/6: from sklearn.metrics import silhouette_score, homogeneity_score, v_measure_score
197/7:
n_c = 3
k_means = KMeans(n_clusters=n_c)
k_means = k_means.fit(X)
clusters = k_means.predict(X)
print('num clusters:', n_c)
print('Silhouette score:', silhouette_score(X, clusters))
print('Homogeneity score:', homogeneity_score(y, clusters))
197/8:
silhouette = []
homogeneity = []
v_measure = []
for n_c in range(2,8):
    k_means = KMeans(n_clusters = n_c)
    k_means = k_means.fit(X)
    clusters = k_means.predict(X)
    silhouette.append(silhouette_score(X, clusters))
    homogeneity.append(homogeneity_score(y, clusters))
    v_measure.append(v_measure_score(y, clusters))
197/9:
plt.figure(figsize=(11, 8))
plt.plot(range(2,8), silhouette, label='silhouette')
plt.plot(range(2,8), homogeneity, label='homogeneity')
plt.plot(range(2,8), v_measure, label='v_measure')
plt.xlabel('n_clusters')
plt.ylabel('metric')
plt.legend(loc='best')
plt.show()
197/10:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1
for samples in [2, 5, 40]:
    for e in [0.2, 1, 3, 5, 10]:
        dbscan = DBSCAN(eps=e, min_samples=samples)
        clusters = dbscan.fit_predict(X)
        plt.subplot(6, 3, i)
        plt.scatter(X[:,0], X[:,1], c=clusters)
        plt.title('eps = {}, min_samples = {}'.format(e, samples))
        i += 1
    i += 1

plt.show()
197/11: from sklearn.datasets import make_moons, make_circles
197/12: X, y = make_moons(n_samples=500, noise=0.1)
197/13:
plt.scatter(X[:,0], X[:,1])
plt.show()
197/14:
k_means = KMeans(n_clusters=2)
k_means = k_means.fit(X)
clusters = k_means.predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()
197/15:
dbscan = DBSCAN(eps=0.15, min_samples=10)
clusters = dbscan.fit_predict(X)

plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()
197/16: X, y = make_circles(n_samples=500, noise=0.05, factor=0.5)
197/17:
plt.scatter(X[:,0], X[:,1])
plt.show()
197/18:
k_means = KMeans(n_clusters = 2)
k_means = k_means.fit(X)
clusters = k_means.predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()
197/19:
dbscan = DBSCAN(eps=0.2, min_samples=10)
clusters = dbscan.fit_predict(X)

plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()
197/20:
from sklearn.datasets import make_blobs

n_samples = 200
random_state = 170
X, y = make_blobs(n_samples=n_samples, random_state=random_state)

plt.scatter(X[:,0], X[:,1])
plt.title('Blobs')
plt.show()
197/21:
import numpy as np

from matplotlib import pyplot as plt
from scipy.cluster.hierarchy import dendrogram
from sklearn.datasets import load_iris
from sklearn.cluster import AgglomerativeClustering


def plot_dendrogram(model, **kwargs):
    # Create linkage matrix and then plot the dendrogram

    # create the counts of samples under each node
    counts = np.zeros(model.children_.shape[0])
    n_samples = len(model.labels_)
    for i, merge in enumerate(model.children_):
        current_count = 0
        for child_idx in merge:
            if child_idx < n_samples:
                current_count += 1  # leaf node
            else:
                current_count += counts[child_idx - n_samples]
        counts[i] = current_count

    linkage_matrix = np.column_stack(
        [model.children_, model.distances_, counts]
    ).astype(float)

    # Plot the corresponding dendrogram
    dendrogram(linkage_matrix, **kwargs)


random_state = 170
X, _ = make_blobs(n_samples=n_samples, random_state=random_state)

# setting distance_threshold=0 ensures we compute the full tree.
model = AgglomerativeClustering(distance_threshold=0, n_clusters=None)

model = model.fit(X)
plt.title("Hierarchical Clustering Dendrogram")
# plot the top three levels of the dendrogram
plot_dendrogram(model, truncate_mode="level", p=5)
plt.xlabel("Number of points in node (or index of point if no parenthesis).")
plt.show()
197/22:
import time
import matplotlib.pyplot as plt
import numpy as np

from sklearn.cluster import AgglomerativeClustering
from sklearn.neighbors import kneighbors_graph

# Generate sample data
n_samples = 1500
np.random.seed(0)
t = 1.5 * np.pi * (1 + 3 * np.random.rand(1, n_samples))
x = t * np.cos(t)
y = t * np.sin(t)


X = np.concatenate((x, y))
X += .7 * np.random.randn(2, n_samples)
X = X.T

# Create a graph capturing local connectivity. Larger number of neighbors
# will give more homogeneous clusters to the cost of computation
# time. A very large number of neighbors gives more evenly distributed
# cluster sizes, but may not impose the local manifold structure of
# the data
knn_graph = kneighbors_graph(X, 30, include_self=False)

n_clusters = 3
for connectivity in (None, knn_graph):
    plt.figure(figsize=(10, 4))
    for index, linkage in enumerate(('average',
                                     'complete',
                                     'ward')):
        plt.subplot(1, 3, index + 1)
        model = AgglomerativeClustering(linkage=linkage,
                                        connectivity=connectivity,
                                        n_clusters=n_clusters)
        model.fit(X)
        plt.scatter(X[:, 0], X[:, 1], c=model.labels_,
                    cmap=plt.cm.nipy_spectral)
        plt.title('linkage=%s' % linkage,
                  fontdict=dict(verticalalignment='top'))
        plt.axis('equal')
        plt.axis('off')

        plt.subplots_adjust(bottom=0, top=.89, wspace=0,
                            left=0, right=1)
        plt.suptitle('n_cluster=%i, connectivity=%r' %
                     (n_clusters, connectivity is not None), size=17)

plt.tight_layout()
plt.show()
197/23:
print(__doc__)

import time
import warnings

import numpy as np
import matplotlib.pyplot as plt

from sklearn import cluster, datasets, mixture
from sklearn.neighbors import kneighbors_graph
from sklearn.preprocessing import StandardScaler
from itertools import cycle, islice

np.random.seed(0)

# ============
# Generate datasets. We choose the size big enough to see the scalability
# of the algorithms, but not too big to avoid too long running times
# ============
n_samples = 1500
noisy_circles = datasets.make_circles(n_samples=n_samples, factor=.5,
                                      noise=.05)
noisy_moons = datasets.make_moons(n_samples=n_samples, noise=.05)
blobs = datasets.make_blobs(n_samples=n_samples, random_state=8)
no_structure = np.random.rand(n_samples, 2), None

# Anisotropicly distributed data
random_state = 170
X, y = datasets.make_blobs(n_samples=n_samples, random_state=random_state)
transformation = [[0.6, -0.6], [-0.4, 0.8]]
X_aniso = np.dot(X, transformation)
aniso = (X_aniso, y)

# blobs with varied variances
varied = datasets.make_blobs(n_samples=n_samples,
                             cluster_std=[1.0, 2.5, 0.5],
                             random_state=random_state)

# ============
# Set up cluster parameters
# ============
plt.figure(figsize=(3 * 2 + 3, 10.5))
plt.subplots_adjust(left=.02, right=.98, bottom=.001, top=.96, wspace=.05,
                    hspace=.01)

plot_num = 1

default_base = {'quantile': .3,
                'eps': .3,
                'damping': .9,
                'preference': -200,
                'n_neighbors': 10,
                'n_clusters': 3,
                'min_samples': 20,
                'xi': 0.05,
                'min_cluster_size': 0.1}

datasets = [
    (noisy_circles, {'damping': .77, 'preference': -240,
                     'quantile': .2, 'n_clusters': 2,
                     'min_samples': 20, 'xi': 0.25}),
    (noisy_moons, {'damping': .75, 'preference': -220, 'n_clusters': 2}),
    (varied, {'eps': .18, 'n_neighbors': 2,
              'min_samples': 5, 'xi': 0.035, 'min_cluster_size': .2}),
    (aniso, {'eps': .15, 'n_neighbors': 2,
             'min_samples': 20, 'xi': 0.1, 'min_cluster_size': .2}),
    (blobs, {}),
    (no_structure, {})]

for i_dataset, (dataset, algo_params) in enumerate(datasets):
    # update parameters with dataset-specific values
    params = default_base.copy()
    params.update(algo_params)

    X, y = dataset

    # normalize dataset for easier parameter selection
    X = StandardScaler().fit_transform(X)
    connectivity = kneighbors_graph(
        X,
        n_neighbors=params['n_neighbors'],
        include_self=False
    )
    
    # make connectivity symmetric
    connectivity = 0.5 * (connectivity + connectivity.T)

    # ============
    # Create cluster objects
    # ============
    
    k_means = cluster.KMeans(n_clusters=params['n_clusters'])

    dbscan = cluster.DBSCAN(eps=params['eps'])
    
    average_linkage =  cluster.AgglomerativeClustering(
        linkage="average", affinity="cityblock",
        n_clusters=params['n_clusters'],
        connectivity=connectivity
    )
    

    clustering_algorithms = (
        ('KMeans', k_means),
        ('AgglomerativeClustering', average_linkage),
        ('DBSCAN', dbscan),
    )

    for name, algorithm in clustering_algorithms:

        algorithm.fit(X)

        if hasattr(algorithm, 'labels_'):
            y_pred = algorithm.labels_.astype(np.int)
        else:
            y_pred = algorithm.predict(X)

        plt.subplot(len(datasets), len(clustering_algorithms), plot_num)
        if i_dataset == 0:
            plt.title(name, size=18)

        colors = np.array(list(islice(cycle(['#377eb8', '#ff7f00', '#4daf4a',
                                             '#f781bf', '#a65628', '#984ea3',
                                             '#999999', '#e41a1c', '#dede00']),
                                      int(max(y_pred) + 1))))
        # add black color for outliers (if any)
        colors = np.append(colors, ["#000000"])
        plt.scatter(X[:, 0], X[:, 1], s=10, color=colors[y_pred])

        plt.xlim(-2.5, 2.5)
        plt.ylim(-2.5, 2.5)
        plt.xticks(())
        plt.yticks(())
        plot_num += 1

plt.show()
196/136: digits = load_digits()
196/137: from sklearn.datasets import load_digits
196/138: digits.shape
196/139: digits = load_digits()
196/140: digits = digits["data"]
196/141: digits.shape
196/142:
# Каждый объект - изображение цифры размеров 8 x 8
plt.imshow(digits[0].reshape(8, 8), cmap="gray")
plt.show()
196/143:
from sklearn.cluster import KMeans
from sklearn.cluster import DBSCAN
from sklearn.metrics import silhouette_score
196/144:
k_means = KMeans(n_clusters=10)
k_means = k_means.fit(digits)
clusters = k_means.predict(digits)

print('Silhouette score:', silhouette_score(digits, clusters))
196/145:
dbscan = DBSCAN(eps=0.15, min_samples=10)
clusters = dbscan.fit_predict(digits)
print('Silhouette score:', silhouette_score(X, clusters))
196/146: from sklearn.datasets import load_digits
196/147: digits = load_digits()
196/148: digits = digits["data"]
196/149: digits.shape
196/150:
k_means = KMeans(n_clusters=10)
k_means = k_means.fit(digits)
clusters = k_means.predict(digits)

print('Silhouette score:', silhouette_score(digits, clusters))
196/151: from sklearn.datasets import load_digits
196/152: digits = load_digits()
196/153: digits = digits["data"]
196/154: digits.shape
196/155:
dbscan = DBSCAN(eps=0.15, min_samples=10)
clusters = dbscan.fit_predict(digits)
print('Silhouette score:', silhouette_score(X, clusters))
196/156: clusters
196/157:
centroids = kmeans.cluster_centers_
pl.scatter(centroids[:, 0], centroids[:, 1],
           marker='x', s=169, linewidths=3,
           color='w', zorder=10)
pl.title('K-means clustering on the digits dataset (PCA-reduced data)\n'
         'Centroids are marked with white cross')
pl.xlim(x_min, x_max)
pl.ylim(y_min, y_max)
pl.xticks(())
pl.yticks(())
pl.show()
196/158:
dbscan = DBSCAN(eps=0.15, min_samples=1)
clusters = dbscan.fit_predict(digits)
print('Silhouette score:', silhouette_score(X, clusters))
196/159:
dbscan = DBSCAN(eps=0.15, min_samples=64)
clusters = dbscan.fit_predict(digits)
print('Silhouette score:', silhouette_score(X, clusters))
196/160:
centroids = k_means.cluster_centers_
pl.scatter(centroids[:, 0], centroids[:, 1],
           marker='x', s=169, linewidths=3,
           color='w', zorder=10)
pl.title('K-means clustering on the digits dataset (PCA-reduced data)\n'
         'Centroids are marked with white cross')
pl.xlim(x_min, x_max)
pl.ylim(y_min, y_max)
pl.xticks(())
pl.yticks(())
pl.show()
196/161:
import pylab as pl
centroids = k_means.cluster_centers_
pl.scatter(centroids[:, 0], centroids[:, 1],
           marker='x', s=169, linewidths=3,
           color='w', zorder=10)
pl.title('K-means clustering on the digits dataset (PCA-reduced data)\n'
         'Centroids are marked with white cross')
pl.xlim(x_min, x_max)
pl.ylim(y_min, y_max)
pl.xticks(())
pl.yticks(())
pl.show()
196/162:
import pylab as pl
centroids = k_means.cluster_centers_
pl.scatter(centroids[:, 0], centroids[:, 1],
           marker='x', s=169, linewidths=3,
           color='w', zorder=10)
pl.title('K-means clustering on the digits dataset (PCA-reduced data)\n'
         'Centroids are marked with white cross')
pl.xticks(())
pl.yticks(())
pl.show()
196/163:
import pylab as pl
centroids = k_means.cluster_centers_
pl.scatter(centroids[:, 0], centroids[:, 1],
           marker='x', s=169, linewidths=3,
           color='w', zorder=10)
pl.title('K-means clustering on the digits dataset\n'
         'Centroids are marked with white cross')
pl.xticks(())
pl.yticks(())
pl.show()
196/164: digits.shape
196/165:
plt.scatter(digits[:, 0], digits[:, 1], c=k_means, s=50, cmap='viridis')

centers = k_means.cluster_centers_
plt.scatter(centers[:, 0], centers[:, 1], c='black', s=200, alpha=0.5)
196/166:

centers = k_means.cluster_centers_
plt.scatter(centers[:, 0], centers[:, 1], c='black', s=200, alpha=0.5)
196/167:
import matplotlib.pyplot as plt
import numpy as np
import pandas

%matplotlib inline
196/168:
import pylab as pl
centroids = k_means.cluster_centers_
pl.scatter(centroids[:, 0], centroids[:, 1],
           marker='x', s=169, linewidths=3,
           color='w', zorder=10)
pl.title('K-means clustering on the digits dataset\n'
         'Centroids are marked with white cross')
pl.xticks(())
pl.yticks(())
pl.show()
196/169:
import pylab as pl
centroids = k_means.cluster_centers_
pl.scatter(centroids[:, 0], centroids[:, 1],
           marker='x', s=169, linewidths=3,
           color='w', zorder=10)
pl.title('K-means clustering on the digits dataset\n'
         'Centroids are marked with white cross')
pl.xticks(())
pl.yticks(())
pl.show()
196/170:
import pylab as pl
centroids = k_means.cluster_centers_
pl.scatter(centroids[:, 0], centroids[:, 1],
           marker='x', s=169, linewidths=3,
           color='w', zorder=10)
pl.title('K-means clustering on the digits dataset\n'
         'Centroids are marked with white cross')
pl.xticks(())
pl.yticks(())
pl.show()
196/171:
import pylab as pl
centroids = k_means.cluster_centers_
pl.scatter(centroids[:, 0], centroids[:, 1],
           marker='x', s=169, linewidths=3,
           color='w', zorder=10)

pl.show()
196/172:
import pylab as pl
centroids = k_means.cluster_centers_
pl.scatter(centroids[:, 0], centroids[:, 1],
           marker='x', s=169, linewidths=3,
           color='w', zorder=10)
pl.title('K-means clustering on the digits dataset')
pl.xticks(())
pl.yticks(())
pl.show()
196/173:
import pylab as pl
centroids = k_means.cluster_centers_
pl.scatter(centroids[:, 0], centroids[:, 1],
           marker='x', s=169, linewidths=3,
           color='w', zorder=10)
pl.title('K-means clustering on the digits dataset')
pl.xticks(())
pl.yticks(())
# pl.show()
centroids
196/174:
import pylab as pl
centers = k_means.cluster_centers_
fig, ax = plt.subplots(1, 5, figsize=(15, 6))
for i, d in enumerate(centers):
    ax[i].imshow(d, cmap='gray_r')
    ax[i].set_title(random_labels[i])
    
centroids
196/175:
import pylab as pl
centers = k_means.cluster_centers_
fig, ax = plt.subplots(1, 10, figsize=(15, 6))
for i, d in enumerate(centers):
    ax[i].imshow(d, cmap='gray_r')
    ax[i].set_title(random_labels[i])
    
centroids
196/176:
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.scatter(k_means.cluster_centers_[:, 0], k_means.cluster_centers_[:, 1], color='red', marker='x', s=200)
plt.title('K-means clustering')
plt.show()
196/177:
# plt.scatter(X[:,0], X[:,1], c=clusters)
plt.scatter(k_means.cluster_centers_[:, 0], k_means.cluster_centers_[:, 1], color='red', marker='x', s=200)
plt.title('K-means clustering')
plt.show()
196/178:
centers = k_means.cluster_centers_
fig, ax = plt.subplots(1, 10, figsize=(15, 6))
for i, cnt in enumerate(centers):
    plt.imshow(cnt.reshape(8, 8), cmap="gray")
#     plt.show()
    ax[i].imshow(d, cmap='gray_r')
    ax[i].set_title(random_labels[i])
196/179:
centers = k_means.cluster_centers_
fig, ax = plt.subplots(1, 10, figsize=(15, 6))
for i, cnt in enumerate(centers):
    plt.imshow(cnt.reshape(8, 8), cmap="gray")
#     plt.show()
#     ax[i].imshow(d, cmap='gray_r')
#     ax[i].set_title(random_labels[i])
196/180:
centers = k_means.cluster_centers_
fig, ax = plt.subplots(1, 10, figsize=(15, 6))
for i, cnt in enumerate(centers):
    plt.imshow(cnt.reshape(8, 8), cmap="gray")
    plt.show()
#     ax[i].imshow(d, cmap='gray_r')
#     ax[i].set_title(random_labels[i])
196/181:
centers = k_means.cluster_centers_
fig, ax = plt.subplots(1, 10, figsize=(15, 6))
for i, cnt in enumerate(centers):
#     plt.imshow(cnt.reshape(8, 8), cmap="gray")
#     plt.show()
    ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
    ax[i].set_title(f'Cluster {i}')
196/182:
centers = k_means.cluster_centers_
fig, ax = plt.subplots(1, 5, figsize=(15, 6))
for i, cnt in enumerate(centers):
#     plt.imshow(cnt.reshape(8, 8), cmap="gray")
#     plt.show()
    ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
    ax[i].set_title(f'Cluster {i}')
196/183:
centers = k_means.cluster_centers_
fig, ax = plt.subplots(1, 10, figsize=(15, 6))
for i, cnt in enumerate(centers):
#     plt.imshow(cnt.reshape(8, 8), cmap="gray")
#     plt.show()
    ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
    ax[i].set_title(f'Cluster {i}')
196/184:
centers = k_means.cluster_centers_
fig, ax = plt.subplots(1, 10, figsize=(15, 6))
for i, cnt in enumerate(centers):
    plt.imshow(cnt.reshape(8, 8), cmap="gray")
    plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
196/185:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))
rows, cols = 2, 4
for i, cnt in enumerate(centers):
    plt.imshow(cnt.reshape(8, 8), cmap="gray")
    plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
196/186:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))
rows, cols = 2, 5
for i, cnt in enumerate(centers):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(cnt.reshape(8, 8), cmap="gray")
    plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
196/187:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))
 plt.figure(figsize=(16, 8))
rows, cols = 2, 5
for i, cnt in enumerate(centers):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(cnt.reshape(8, 8), cmap="gray")
    plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
196/188:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))
plt.figure(figsize=(16, 8))
rows, cols = 2, 5
for i, cnt in enumerate(centers):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(cnt.reshape(8, 8), cmap="gray")
    plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
196/189:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))
plt.figure(figsize=(16, 8))
rows, cols = 2, 5
for i, cnt in enumerate(centers):
    plt.imshow(cnt.reshape(8, 8), cmap="gray")
    plt.show()
196/190:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))

rows, cols = 2, 5
n_samples = rows * cols
for i in range(n_samples - 1):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(centers[i, :].reshape(8, 8), cmap="gray")
    plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
196/191:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))

rows, cols = 2, 5
n_samples = rows * cols
for i in range(n_samples - 1):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(centers[i, :].reshape(64, 64), cmap="gray")
    plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
196/192:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))

rows, cols = 2, 5
n_samples = rows * cols
for i in range(n_samples - 1):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(centers[i, :].reshape(8, 8), cmap="gray")
    plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
196/193:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))

rows, cols = 2, 5
n_samples = rows * cols
for i in range(n_samples - 1):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(centers[i, :], cmap="gray")
    plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
196/194:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))

rows, cols = 2, 5
n_samples = rows * cols
for i in range(n_samples - 1):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(centers[i, :].reshape(8, 8), cmap="gray")
    plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
196/195:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))

rows, cols = 2, 5
n_samples = rows * cols
for i in range(n_samples - 1):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(centers[i, :].reshape(8, 8), cmap="gray")
#     plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
    
plt.subplot(rows, cols, n_samples)
196/196:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))

rows, cols = 2, 5
n_samples = rows * cols
for i in range(n_samples - 1):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(centers[i, :].reshape(8, 8), cmap="gray")
#     plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
    
plt.subplot(rows, cols, n_samples-1)
196/197:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))

rows, cols = 2, 5
n_samples = rows * cols
for i in range(n_samples - 1):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(centers[i, :].reshape(8, 8), cmap="gray")
#     plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
    
    plt.subplot(rows, cols, n_samples-1)
196/198:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))

rows, cols = 2, 5
n_samples = rows * cols
for i in range(n_samples - 1):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(centers[i, :].reshape(8, 8), cmap="gray")
#     plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
    
plt.subplot(rows, cols, n_samples)
196/199:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))
plt.figure(figsize=(16, 8)
rows, cols = 2, 5
n_samples = rows * cols
for i in range(n_samples - 1):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(centers[i, :].reshape(8, 8), cmap="gray")
#     plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
    
plt.subplot(rows, cols, n_samples)
196/200:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))
plt.figure(figsize=(16, 8))
rows, cols = 2, 5
n_samples = rows * cols
for i in range(n_samples - 1):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(centers[i, :].reshape(8, 8), cmap="gray")
#     plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
    
plt.subplot(rows, cols, n_samples)
196/201:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))
plt.figure(figsize=(16, 8))
rows, cols = 2, 5
n_samples = rows * cols
for i in range(n_samples):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(centers[i, :].reshape(8, 8), cmap="gray")
#     plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
    
plt.subplot(rows, cols, n_samples)
196/202:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))
plt.figure(figsize=(16, 8))
rows, cols = 2, 5
n_samples = rows * cols
for i in range(n_samples):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(centers[i, :].reshape(8, 8), cmap="gray")
#     plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
    
plt.subplot(rows, cols, n_samples+1)
196/203:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))
plt.figure(figsize=(16, 8))
rows, cols = 2, 5
n_samples = rows * cols
for i in range(n_samples):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(centers[i, :].reshape(8, 8), cmap="gray")
#     plt.show()
#     ax[i].imshow(cnt.reshape(8, 8), cmap='gray_r')
#     ax[i].set_title(f'Cluster {i}')
    
plt.subplot(rows, cols, n_samples)
196/204:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))
plt.figure(figsize=(16, 8))
rows, cols = 2, 5
n_samples = rows * cols
for i in range(n_samples):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(centers[i, :].reshape(8, 8), cmap="gray")
    plt.set_title(f'Cluster {i}')

plt.subplot(rows, cols, n_samples)
196/205:
centers = k_means.cluster_centers_
# fig, ax = plt.subplots(1, 10, figsize=(15, 6))
plt.figure(figsize=(16, 8))
rows, cols = 2, 5
n_samples = rows * cols
for i in range(n_samples):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(centers[i, :].reshape(8, 8), cmap="gray")
    plt.title(f'Cluster {i}')

plt.subplot(rows, cols, n_samples)
196/206:
dbscan = DBSCAN(eps=7.5, min_samples=64)
clusters = dbscan.fit_predict(digits)
print('Silhouette score:', silhouette_score(X, clusters))
196/207:
dbscan = DBSCAN(eps=1, min_samples=5)
clusters = dbscan.fit_predict(digits)
print('Silhouette score:', silhouette_score(X, clusters))
196/208:
dbscan = DBSCAN(eps=1, min_samples=5)
clusters = dbscan.fit_predict(digits)
# print('Silhouette score:', silhouette_score(X, clusters))
196/209: from sklearn.datasets import load_digits
196/210: digits = load_digits()
196/211: digits = digits["data"]
196/212:
from sklearn.cluster import KMeans
from sklearn.cluster import DBSCAN
from sklearn.metrics import silhouette_score
196/213:
plt.figure(figsize=(15,23))
i = 1
for samples in [2, 5, 40]:
    for e in [0.2, 1, 3, 5, 10]:
        dbscan = DBSCAN(eps=e, min_samples=samples)
        clusters = dbscan.fit_predict(digits)
        plt.subplot(6, 3, i)
        plt.scatter(digits[:,0], digits[:,1], c=clusters)
        plt.title('eps = {}, min_samples = {}'.format(e, samples))
        i += 1
    i += 1

plt.show()
196/214:
dbscan = DBSCAN(eps=1, min_samples=5)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
# print('Silhouette score:', silhouette_score(X, clusters))
196/215:
dbscan = DBSCAN(eps=0.01, min_samples=5)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
# print('Silhouette score:', silhouette_score(X, clusters))
196/216:
dbscan = DBSCAN(eps=0.01, min_samples=5)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('Silhouette score:', clusters)
196/217:
dbscan = DBSCAN(eps=0.01, min_samples=5)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/218:
dbscan = DBSCAN(eps=0.01, min_samples=5)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters.shape)
196/219:
dbscan = DBSCAN(eps=0.01, min_samples=5)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters.size)
196/220:
dbscan = DBSCAN(eps=0.01, min_samples=5)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters.shape)
196/221:
dbscan = DBSCAN(eps=0.01, min_samples=1)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters.shape)
196/222:
dbscan = DBSCAN(eps=0.01, min_samples=1)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/223:
dbscan = DBSCAN(eps=0.01, min_samples=10)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/224:
dbscan = DBSCAN(eps=0.0001, min_samples=10)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/225:
dbscan = DBSCAN(eps=0.0001, min_samples=2)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/226:
dbscan = DBSCAN(eps=60, min_samples=2)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/227:
dbscan = DBSCAN(eps=60, min_samples=64)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/228:
dbscan = DBSCAN(eps=60, min_samples=1)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/229:
dbscan = DBSCAN(eps=10, min_samples=1)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/230:
dbscan = DBSCAN(eps=10, min_samples=5)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/231:
dbscan = DBSCAN(eps=9.7, min_samples=2, algorithm='ball_tree', metric='minkowski', leaf_size=90, p=2
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/232:
dbscan = DBSCAN(eps=9.7, min_samples=2, algorithm='ball_tree', metric='minkowski', leaf_size=90, p=2)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/233:
dbscan = DBSCAN(eps=9.7, min_samples=2, algorithm='ball_tree', metric='minkowski', leaf_size=90)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/234:
dbscan = DBSCAN(eps=9.7, min_samples=2, algorithm='ball_tree', metric='minkowski', leaf_size=10)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/235:
dbscan = DBSCAN(eps=9.7, min_samples=2, algorithm='ball_tree', metric='minkowski', leaf_size=10, p=2)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/236:
dbscan = DBSCAN(eps=9.7, min_samples=2, algorithm='ball_tree', leaf_size=10, p=2)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/237:
dbscan = DBSCAN(eps=9.7, min_samples=1, algorithm='ball_tree', leaf_size=10, p=2)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/238:
dbscan = DBSCAN(eps=9.7, min_samples=100, algorithm='ball_tree', leaf_size=10, p=2)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/239:
dbscan = DBSCAN(eps=0.15, min_samples=10)
clusters = dbscan.fit_predict(digits)

plt.scatter(digits[:,0], digits[:,1], c=clusters)
print('clusters', clusters)
196/240:
dbscan = DBSCAN(eps=0.15, min_samples=10)
clusters = dbscan.fit_predict(digits)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
196/241:
dbscan = DBSCAN(eps=0.15, min_samples=1)
clusters = dbscan.fit_predict(digits)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
196/242:
dbscan = DBSCAN(eps=0.5, min_samples=5, metric='euclidean', metric_params=None, algorithm='auto', leaf_size=30, p=None, n_jobs=None)
clusters = dbscan.fit_predict(digits)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
196/243:
dbscan = DBSCAN(eps=0, min_samples=5, metric='euclidean', metric_params=None, algorithm='auto', leaf_size=30, p=None, n_jobs=None)
clusters = dbscan.fit_predict(digits)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
196/244:
dbscan = DBSCAN(eps=0.000000001, min_samples=5, metric='euclidean', metric_params=None, algorithm='auto', leaf_size=30, p=None, n_jobs=None)
clusters = dbscan.fit_predict(digits)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
196/245:
dbscan = DBSCAN(eps=0.000000001, min_samples=5, metric='euclidean', metric_params=None, algorithm='auto', leaf_size=30, p=None, n_jobs=None)
clusters = dbscan.fit(digits)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
196/246:
dbscan = DBSCAN(eps=0.000000001, min_samples=5, metric='euclidean', metric_params=None, algorithm='kd_tree', leaf_size=30, p=None, n_jobs=None)
clusters = dbscan.fit(digits)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
196/247:
dbscan = DBSCAN(eps=0.000000001, min_samples=5, metric='euclidean', metric_params=None, algorithm='kd_tree', leaf_size=30, p=None, n_jobs=None)
clusters = dbscan.fit_predict(digits)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
196/248:
dbscan = DBSCAN(eps=0.000000001, min_samples=1, metric='euclidean', metric_params=None, algorithm='kd_tree', leaf_size=30, p=None, n_jobs=None)
clusters = dbscan.fit_predict(digits)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
196/249:
dbscan = DBSCAN(eps=0.000000001, min_samples=2, metric='euclidean', metric_params=None, algorithm='kd_tree', leaf_size=30, p=None, n_jobs=None)
clusters = dbscan.fit_predict(digits)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
196/250:
dbscan = DBSCAN(eps=0.000000001, min_samples=10, metric='euclidean', metric_params=None, algorithm='kd_tree', leaf_size=30, p=None, n_jobs=None)
clusters = dbscan.fit_predict(digits)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
196/251: digits
196/252: plt.scatter(digits[:,0], digits[:,1])
196/253:
dbscan = DBSCAN(eps=0.000000001, min_samples=10, metric='euclidean', metric_params=None, algorithm='kd_tree', leaf_size=30, p=None, n_jobs=None)
clusters = dbscan.fit(digits, n_features_in_int=64)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
196/254:
dbscan = DBSCAN(eps=0.000000001, min_samples=10, metric='euclidean', metric_params=None, algorithm='kd_tree', leaf_size=30, p=None, n_jobs=None)
clusters = dbscan.fit(digits, n_features_in_=64)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
196/255:
dbscan = DBSCAN(eps=0.000000001, min_samples=10, metric='euclidean', metric_params=None, algorithm='kd_tree', leaf_size=30, p=None, n_jobs=None)
clusters = dbscan.fit(digits, n_features_in=64)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
196/256:
dbscan = DBSCAN(eps=0.000000001, min_samples=10, metric='euclidean', metric_params=None, algorithm='kd_tree', leaf_size=30, p=None, n_jobs=None)
clusters = dbscan.fit(digits, n_features_in=64)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
196/257:
dbscan = DBSCAN(eps=0.000000001, min_samples=10, metric='euclidean', metric_params=None, algorithm='kd_tree', leaf_size=1, p=None, n_jobs=None)
clusters = dbscan.fit(digits, n_features_in=64)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
196/258:
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X_scaled = scaler.fit_transform(digits)
196/259:
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X_scaled = scaler.fit_transform(digits)
X_scaled
196/260:
dbscan = DBSCAN(eps=0.015, min_samples=10, metric='euclidean', metric_params=None, algorithm='kd_tree', leaf_size=1, p=None, n_jobs=None)
clusters = dbscan.fit_predict(X_scaled)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
196/261:
dbscan = DBSCAN(eps=0.015, min_samples=2, metric='euclidean', metric_params=None, algorithm='kd_tree', leaf_size=1, p=None, n_jobs=None)
clusters = dbscan.fit_predict(X_scaled)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
196/262:
dbscan = DBSCAN(eps=0.015, min_samples=2)
clusters = dbscan.fit_predict(X_scaled)
labels = dbscan.labels_

# plt.scatter(digits[:,0], digits[:,1], c=clusters)
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print("Estimated number of clusters: %d" % n_clusters_)

print('clusters', clusters)
197/24:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1
for samples in [2, 5, 40]:
    for e in [0.2, 1, 3, 5, 10]:
        dbscan = DBSCAN(eps=e, min_samples=samples)
        clusters = dbscan.fit_predict(X)
        plt.subplot(6, 3, i)
        plt.scatter(X[:,0], X[:,1], c=clusters)
        plt.title('eps = {}, min_samples = {}'.format(e, samples))
        i += 1
    i += 1

plt.show()
197/25:
%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
197/26: plt.rcParams['figure.figsize'] = [11, 8]
197/27:
from sklearn.cluster import KMeans

np.random.seed(123)
X1 = np.random.randn(100, 2)
X2 = np.random.randn(100, 2) - np.array([10 ,1])
X3 = np.random.randn(100, 2) - np.array([1, 10])
X = np.vstack((X1, X2, X3))
y = np.array([1] * 100 + [2] * 100 + [3] * 100)
197/28:
k_means = KMeans(n_clusters=3)
k_means = k_means.fit(X)
clusters = k_means.predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.scatter(k_means.cluster_centers_[:, 0], k_means.cluster_centers_[:, 1], color='red', marker='x', s=200)
plt.title('K-means clustering')
plt.show()
197/29:
plt.figure(figsize=(15, 8))
for n_c in range(2, 8):
    k_means = KMeans(n_clusters=n_c)
    k_means = k_means.fit(X)
    clusters = k_means.predict(X)
    plt.subplot(2,3, n_c - 1)
    plt.scatter(X[:,0], X[:,1], c=clusters)
    plt.scatter(k_means.cluster_centers_[:, 0], k_means.cluster_centers_[:, 1], color='red', marker='x', s=200)
    plt.title('n_clusters = {}'.format(n_c))

plt.show()
197/30: from sklearn.metrics import silhouette_score, homogeneity_score, v_measure_score
197/31:
n_c = 3
k_means = KMeans(n_clusters=n_c)
k_means = k_means.fit(X)
clusters = k_means.predict(X)
print('num clusters:', n_c)
print('Silhouette score:', silhouette_score(X, clusters))
print('Homogeneity score:', homogeneity_score(y, clusters))
197/32:
silhouette = []
homogeneity = []
v_measure = []
for n_c in range(2,8):
    k_means = KMeans(n_clusters = n_c)
    k_means = k_means.fit(X)
    clusters = k_means.predict(X)
    silhouette.append(silhouette_score(X, clusters))
    homogeneity.append(homogeneity_score(y, clusters))
    v_measure.append(v_measure_score(y, clusters))
197/33:
plt.figure(figsize=(11, 8))
plt.plot(range(2,8), silhouette, label='silhouette')
plt.plot(range(2,8), homogeneity, label='homogeneity')
plt.plot(range(2,8), v_measure, label='v_measure')
plt.xlabel('n_clusters')
plt.ylabel('metric')
plt.legend(loc='best')
plt.show()
197/34:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1
for samples in [2, 5, 40]:
    for e in [0.2, 1, 3, 5, 10]:
        dbscan = DBSCAN(eps=e, min_samples=samples)
        clusters = dbscan.fit_predict(X)
        plt.subplot(6, 3, i)
        plt.scatter(X[:,0], X[:,1], c=clusters)
        plt.title('eps = {}, min_samples = {}'.format(e, samples))
        i += 1
    i += 1

plt.show()
197/35: from sklearn.datasets import make_moons, make_circles
197/36: X, y = make_moons(n_samples=500, noise=0.1)
197/37:
plt.scatter(X[:,0], X[:,1])
plt.show()
197/38:
k_means = KMeans(n_clusters=2)
k_means = k_means.fit(X)
clusters = k_means.predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()
197/39:
dbscan = DBSCAN(eps=0.15, min_samples=10)
clusters = dbscan.fit_predict(X)

plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()
197/40: X, y = make_circles(n_samples=500, noise=0.05, factor=0.5)
197/41:
plt.scatter(X[:,0], X[:,1])
plt.show()
197/42:
k_means = KMeans(n_clusters = 2)
k_means = k_means.fit(X)
clusters = k_means.predict(X)
plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()
197/43:
dbscan = DBSCAN(eps=0.2, min_samples=10)
clusters = dbscan.fit_predict(X)

plt.scatter(X[:,0], X[:,1], c=clusters)
plt.show()
197/44:
from sklearn.datasets import make_blobs

n_samples = 200
random_state = 170
X, y = make_blobs(n_samples=n_samples, random_state=random_state)

plt.scatter(X[:,0], X[:,1])
plt.title('Blobs')
plt.show()
197/45:
import numpy as np

from matplotlib import pyplot as plt
from scipy.cluster.hierarchy import dendrogram
from sklearn.datasets import load_iris
from sklearn.cluster import AgglomerativeClustering


def plot_dendrogram(model, **kwargs):
    # Create linkage matrix and then plot the dendrogram

    # create the counts of samples under each node
    counts = np.zeros(model.children_.shape[0])
    n_samples = len(model.labels_)
    for i, merge in enumerate(model.children_):
        current_count = 0
        for child_idx in merge:
            if child_idx < n_samples:
                current_count += 1  # leaf node
            else:
                current_count += counts[child_idx - n_samples]
        counts[i] = current_count

    linkage_matrix = np.column_stack(
        [model.children_, model.distances_, counts]
    ).astype(float)

    # Plot the corresponding dendrogram
    dendrogram(linkage_matrix, **kwargs)


random_state = 170
X, _ = make_blobs(n_samples=n_samples, random_state=random_state)

# setting distance_threshold=0 ensures we compute the full tree.
model = AgglomerativeClustering(distance_threshold=0, n_clusters=None)

model = model.fit(X)
plt.title("Hierarchical Clustering Dendrogram")
# plot the top three levels of the dendrogram
plot_dendrogram(model, truncate_mode="level", p=5)
plt.xlabel("Number of points in node (or index of point if no parenthesis).")
plt.show()
197/46:
import time
import matplotlib.pyplot as plt
import numpy as np

from sklearn.cluster import AgglomerativeClustering
from sklearn.neighbors import kneighbors_graph

# Generate sample data
n_samples = 1500
np.random.seed(0)
t = 1.5 * np.pi * (1 + 3 * np.random.rand(1, n_samples))
x = t * np.cos(t)
y = t * np.sin(t)


X = np.concatenate((x, y))
X += .7 * np.random.randn(2, n_samples)
X = X.T

# Create a graph capturing local connectivity. Larger number of neighbors
# will give more homogeneous clusters to the cost of computation
# time. A very large number of neighbors gives more evenly distributed
# cluster sizes, but may not impose the local manifold structure of
# the data
knn_graph = kneighbors_graph(X, 30, include_self=False)

n_clusters = 3
for connectivity in (None, knn_graph):
    plt.figure(figsize=(10, 4))
    for index, linkage in enumerate(('average',
                                     'complete',
                                     'ward')):
        plt.subplot(1, 3, index + 1)
        model = AgglomerativeClustering(linkage=linkage,
                                        connectivity=connectivity,
                                        n_clusters=n_clusters)
        model.fit(X)
        plt.scatter(X[:, 0], X[:, 1], c=model.labels_,
                    cmap=plt.cm.nipy_spectral)
        plt.title('linkage=%s' % linkage,
                  fontdict=dict(verticalalignment='top'))
        plt.axis('equal')
        plt.axis('off')

        plt.subplots_adjust(bottom=0, top=.89, wspace=0,
                            left=0, right=1)
        plt.suptitle('n_cluster=%i, connectivity=%r' %
                     (n_clusters, connectivity is not None), size=17)

plt.tight_layout()
plt.show()
197/47:
print(__doc__)

import time
import warnings

import numpy as np
import matplotlib.pyplot as plt

from sklearn import cluster, datasets, mixture
from sklearn.neighbors import kneighbors_graph
from sklearn.preprocessing import StandardScaler
from itertools import cycle, islice

np.random.seed(0)

# ============
# Generate datasets. We choose the size big enough to see the scalability
# of the algorithms, but not too big to avoid too long running times
# ============
n_samples = 1500
noisy_circles = datasets.make_circles(n_samples=n_samples, factor=.5,
                                      noise=.05)
noisy_moons = datasets.make_moons(n_samples=n_samples, noise=.05)
blobs = datasets.make_blobs(n_samples=n_samples, random_state=8)
no_structure = np.random.rand(n_samples, 2), None

# Anisotropicly distributed data
random_state = 170
X, y = datasets.make_blobs(n_samples=n_samples, random_state=random_state)
transformation = [[0.6, -0.6], [-0.4, 0.8]]
X_aniso = np.dot(X, transformation)
aniso = (X_aniso, y)

# blobs with varied variances
varied = datasets.make_blobs(n_samples=n_samples,
                             cluster_std=[1.0, 2.5, 0.5],
                             random_state=random_state)

# ============
# Set up cluster parameters
# ============
plt.figure(figsize=(3 * 2 + 3, 10.5))
plt.subplots_adjust(left=.02, right=.98, bottom=.001, top=.96, wspace=.05,
                    hspace=.01)

plot_num = 1

default_base = {'quantile': .3,
                'eps': .3,
                'damping': .9,
                'preference': -200,
                'n_neighbors': 10,
                'n_clusters': 3,
                'min_samples': 20,
                'xi': 0.05,
                'min_cluster_size': 0.1}

datasets = [
    (noisy_circles, {'damping': .77, 'preference': -240,
                     'quantile': .2, 'n_clusters': 2,
                     'min_samples': 20, 'xi': 0.25}),
    (noisy_moons, {'damping': .75, 'preference': -220, 'n_clusters': 2}),
    (varied, {'eps': .18, 'n_neighbors': 2,
              'min_samples': 5, 'xi': 0.035, 'min_cluster_size': .2}),
    (aniso, {'eps': .15, 'n_neighbors': 2,
             'min_samples': 20, 'xi': 0.1, 'min_cluster_size': .2}),
    (blobs, {}),
    (no_structure, {})]

for i_dataset, (dataset, algo_params) in enumerate(datasets):
    # update parameters with dataset-specific values
    params = default_base.copy()
    params.update(algo_params)

    X, y = dataset

    # normalize dataset for easier parameter selection
    X = StandardScaler().fit_transform(X)
    connectivity = kneighbors_graph(
        X,
        n_neighbors=params['n_neighbors'],
        include_self=False
    )
    
    # make connectivity symmetric
    connectivity = 0.5 * (connectivity + connectivity.T)

    # ============
    # Create cluster objects
    # ============
    
    k_means = cluster.KMeans(n_clusters=params['n_clusters'])

    dbscan = cluster.DBSCAN(eps=params['eps'])
    
    average_linkage =  cluster.AgglomerativeClustering(
        linkage="average", affinity="cityblock",
        n_clusters=params['n_clusters'],
        connectivity=connectivity
    )
    

    clustering_algorithms = (
        ('KMeans', k_means),
        ('AgglomerativeClustering', average_linkage),
        ('DBSCAN', dbscan),
    )

    for name, algorithm in clustering_algorithms:

        algorithm.fit(X)

        if hasattr(algorithm, 'labels_'):
            y_pred = algorithm.labels_.astype(np.int)
        else:
            y_pred = algorithm.predict(X)

        plt.subplot(len(datasets), len(clustering_algorithms), plot_num)
        if i_dataset == 0:
            plt.title(name, size=18)

        colors = np.array(list(islice(cycle(['#377eb8', '#ff7f00', '#4daf4a',
                                             '#f781bf', '#a65628', '#984ea3',
                                             '#999999', '#e41a1c', '#dede00']),
                                      int(max(y_pred) + 1))))
        # add black color for outliers (if any)
        colors = np.append(colors, ["#000000"])
        plt.scatter(X[:, 0], X[:, 1], s=10, color=colors[y_pred])

        plt.xlim(-2.5, 2.5)
        plt.ylim(-2.5, 2.5)
        plt.xticks(())
        plt.yticks(())
        plot_num += 1

plt.show()
196/263:
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X = scaler.fit_transform(digits)
X
196/264:
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X = scaler.fit_transform(digits)
X
196/265:
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X = scaler.fit_transform(digits)
X
196/266:
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X = scaler.fit_transform(digits)
X
196/267:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1
for samples in [2, 5, 40]:
    for e in [0.2, 1, 3, 5, 10]:
        dbscan = DBSCAN(eps=e, min_samples=samples)
        clusters = dbscan.fit_predict(X)
        plt.subplot(6, 3, i)
        plt.scatter(X[:,0], X[:,1], c=clusters)
        plt.title('eps = {}, min_samples = {}'.format(e, samples))
        i += 1
    i += 1

plt.show()
196/268:
dbscan = DBSCAN(eps=5, min_samples=40)
clusters = dbscan.fit_predict(X)
clusters
196/269:
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
196/270:
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
196/271:
dbscan = DBSCAN(eps=5, min_samples=41)
clusters = dbscan.fit_predict(X)
196/272:
dbscan = DBSCAN(eps=5, min_samples=41)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
196/273:
dbscan = DBSCAN(eps=5, min_samples=450)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
196/274:
dbscan = DBSCAN(eps=5, min_samples=50)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
196/275:
dbscan = DBSCAN(eps=5, min_samples=60)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
196/276:
dbscan = DBSCAN(eps=5, min_samples=55)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
196/277:
dbscan = DBSCAN(eps=5, min_samples=50)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
196/278:
dbscan = DBSCAN(eps=5, min_samples=51)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
196/279:
dbscan = DBSCAN(eps=5, min_samples=49)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
196/280:
dbscan = DBSCAN(eps=5, min_samples=50)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
196/281:
dbscan = DBSCAN(eps=15, min_samples=50)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
196/282:
dbscan = DBSCAN(eps=115, min_samples=50)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
196/283:
dbscan = DBSCAN(eps=1, min_samples=50)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
196/284:
dbscan = DBSCAN(eps=5, min_samples=50)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
196/285:
dbscan = DBSCAN(eps=5, min_samples=100)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
196/286:
dbscan = DBSCAN(eps=0.1, min_samples=100)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
196/287:
dbscan = DBSCAN(eps=5, min_samples=50)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
196/288:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1
for samples in [40, 50, 500]:
    for e in [0.2, 1, 3, 5, 10]:
        dbscan = DBSCAN(eps=e, min_samples=samples)
        clusters = dbscan.fit_predict(X)
        plt.subplot(6, 3, i)
        plt.scatter(X[:,0], X[:,1], c=clusters)
        plt.title('eps = {}, min_samples = {}'.format(e, samples))
        i += 1
    i += 1

plt.show()
198/1:
import matplotlib.pyplot as plt
import numpy as np
import pandas

%matplotlib inline
198/2: from sklearn.datasets import load_digits
198/3: digits = load_digits()
198/4: digits = digits["data"]
198/5: digits.shape
198/6:
# Каждый объект - изображение цифры размеров 8 x 8
plt.imshow(digits[0].reshape(8, 8), cmap="gray")
plt.show()
198/7:
from sklearn.cluster import KMeans
from sklearn.cluster import DBSCAN
from sklearn.metrics import silhouette_score
198/8:
dbscan = DBSCAN(eps=5, min_samples=50)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
198/9:
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X = scaler.fit_transform(digits)
X
198/10:
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X = scaler.fit_transform(digits)
198/11:
dbscan = DBSCAN(eps=5, min_samples=50)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
198/12:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for leaf_size in [0.2, 1, 3, 5, 10]:
    dbscan = DBSCAN(eps=5, min_samples=50, leaf_size=leaf_size)
    clusters = dbscan.fit_predict(X)
    plt.subplot(6, 3, i)
    plt.scatter(X[:,0], X[:,1], c=clusters)
    plt.title('eps = {}, min_samples = {}'.format(e, samples))
    i += 1


plt.show()
198/13:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for leaf_size in [0.2, 1, 3, 5, 10]:
    dbscan = DBSCAN(eps=5, min_samples=50, leaf_size=leaf_size)
    clusters = dbscan.fit_predict(X)
    plt.subplot(6, 3, i)
    plt.scatter(X[:,0], X[:,1], c=clusters)
    plt.title('eps = {}, min_samples = {}'.format(leaf_size))
    i += 1


plt.show()
198/14:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for leaf_size in [10, 30, 100, 500]:
    dbscan = DBSCAN(eps=5, min_samples=50, leaf_size=leaf_size)
    clusters = dbscan.fit_predict(X)
    plt.subplot(6, 3, i)
    plt.scatter(X[:,0], X[:,1], c=clusters)
    plt.title('eps = {}, min_samples = {}'.format(leaf_size))
    i += 1


plt.show()
198/15:
from sklearn.cluster import DBSCAN
from sklearn.model_selection import GridSearchCV
198/16:
from sklearn.cluster import DBSCAN
from sklearn.model_selection import GridSearchCV
params = {
    'metric': ['euclidean', 'manhattan', 'minkowski'],
    'leaf_size': np.arange(start=1, stop=100, step=25),
    'eps': 5,
    'min_samples': 50
}
db = GridSearchCV(estimator=DBSCAN(),           
                    param_grid=params, 
                    cv=1)
db.fit(X)

print('best score:', db.best_score_)
print('best params:', db.best_params_)
198/17:
from sklearn.cluster import DBSCAN
from sklearn.model_selection import GridSearchCV
params = {
    'metric': ['euclidean', 'manhattan', 'minkowski'],
    'leaf_size': np.arange(start=1, stop=100, step=25),
    'eps': [5],
    'min_samples': [50]
}
db = GridSearchCV(estimator=DBSCAN(),           
                    param_grid=params, 
                    cv=1)
db.fit(X)

print('best score:', db.best_score_)
print('best params:', db.best_params_)
198/18:
from sklearn.cluster import DBSCAN
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import make_scorer

params = {
    'metric': ['euclidean', 'manhattan', 'minkowski'],
    'leaf_size': np.arange(start=1, stop=100, step=25),
    'eps': [5],
    'min_samples': [50]
}
scorers = {
        'accuracy_score': make_scorer(silhouette_score)
        }
db = GridSearchCV(estimator=DBSCAN(),           
                    param_grid=params,
                    scoring=scorers
                    cv=1)
db.fit(X)

print('best score:', db.best_score_)
print('best params:', db.best_params_)
198/19:
from sklearn.cluster import DBSCAN
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import make_scorer

params = {
    'metric': ['euclidean', 'manhattan', 'minkowski'],
    'leaf_size': np.arange(start=1, stop=100, step=25),
    'eps': [5],
    'min_samples': [50]
}
scorers = {
        'accuracy_score': make_scorer(silhouette_score)
        }
db = GridSearchCV(estimator=DBSCAN(),           
                    param_grid=params,
                    scoring=scorers,
                    cv=1)
db.fit(X)

print('best score:', db.best_score_)
print('best params:', db.best_params_)
198/20:
from sklearn.cluster import DBSCAN
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import make_scorer

params = {
    'metric': ['euclidean', 'manhattan', 'minkowski'],
    'leaf_size': np.arange(start=1, stop=100, step=25),
    'eps': [5],
    'min_samples': [50]
}
scorers = {
        'accuracy_score': make_scorer(silhouette_score)
        }
db = GridSearchCV(estimator=DBSCAN(),           
                    param_grid=params,
                    scoring=scorers,
                  refit=False,
                    cv=1)
db.fit(X)

print('best score:', db.best_score_)
print('best params:', db.best_params_)
198/21:
from sklearn.cluster import DBSCAN
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import make_scorer

params = {
    'metric': ['euclidean', 'manhattan', 'minkowski'],
    'leaf_size': np.arange(start=1, stop=100, step=25),
    'eps': [5],
    'min_samples': [50]
}
scorers = {
        'accuracy_score': make_scorer(silhouette_score)
        }
db = GridSearchCV(estimator=DBSCAN(),           
                    param_grid=params,
                    scoring=scorers,
                    refit=False,
                    cv=2)
db.fit(X)

print('best score:', db.best_score_)
print('best params:', db.best_params_)
198/22:
from sklearn.cluster import DBSCAN
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import make_scorer

params = {
    'metric': ['euclidean', 'manhattan', 'minkowski'],
    'leaf_size': np.arange(start=1, stop=100, step=25),
    'eps': [5],
    'min_samples': [50]
}
scorers = {
        'accuracy_score': make_scorer(silhouette_score)
        }
db = GridSearchCV(estimator=DBSCAN(),           
                    param_grid=params,
                    scoring=scorers,
                    refit=False,
                    cv=2)
db.fit(X)

# print('best score:', db.best_score_)
print('best params:', db.best_params_)
198/23:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for leaf_size in [10, 30, 100, 500]:
    dbscan = DBSCAN(eps=5, min_samples=50, leaf_size=leaf_size)
    clusters = dbscan.fit_predict(X)
    plt.subplot(6, 3, i)
    plt.scatter(X[:,0], X[:,1], c=clusters)
    plt.title('eps = {}, min_samples = {}'.format(leaf_size))
    i += 1


plt.show()
198/24:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for leaf_size in [10, 30, 100, 500]:
    dbscan = DBSCAN(eps=5, min_samples=50, leaf_size=leaf_size)
    clusters = dbscan.fit_predict(X)
#     plt.subplot(6, 3, i)
    plt.scatter(X[:,0], X[:,1], c=clusters)
    plt.title('eps = {}, min_samples = {}'.format(leaf_size))
    i += 1


plt.show()
198/25:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for leaf_size in [10, 30, 100, 500]:
    dbscan = DBSCAN(eps=5, min_samples=50, leaf_size=leaf_size)
    clusters = dbscan.fit_predict(X)
    print('clusters', clusters)
#     plt.subplot(6, 3, i)
#     plt.scatter(X[:,0], X[:,1], c=clusters)
#     plt.title('eps = {}, min_samples = {}'.format(leaf_size))
#     i += 1


# plt.show()
198/26:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for leaf_size in [10, 30, 100, 500]:
    dbscan = DBSCAN(eps=5, min_samples=50, leaf_size=leaf_size)
    clusters = dbscan.fit_predict(X)
    labels = dbscan.labels_
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    print('n_clusters_', n_clusters_)
#     plt.subplot(6, 3, i)
#     plt.scatter(X[:,0], X[:,1], c=clusters)
#     plt.title('eps = {}, min_samples = {}'.format(leaf_size))
#     i += 1


# plt.show()
198/27:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for leaf_size in [10, 30, 100, 500]:
    dbscan = DBSCAN(eps=10, min_samples=50, leaf_size=leaf_size)
    clusters = dbscan.fit_predict(X)
    labels = dbscan.labels_
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    print('n_clusters_', n_clusters_)
#     plt.subplot(6, 3, i)
#     plt.scatter(X[:,0], X[:,1], c=clusters)
#     plt.title('eps = {}, min_samples = {}'.format(leaf_size))
#     i += 1


# plt.show()
198/28:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for leaf_size in [10, 30, 100, 500]:
    dbscan = DBSCAN(eps=1, min_samples=50, leaf_size=leaf_size)
    clusters = dbscan.fit_predict(X)
    labels = dbscan.labels_
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    print('n_clusters_', n_clusters_)
#     plt.subplot(6, 3, i)
#     plt.scatter(X[:,0], X[:,1], c=clusters)
#     plt.title('eps = {}, min_samples = {}'.format(leaf_size))
#     i += 1


# plt.show()
198/29:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for leaf_size in [10, 30, 100, 500]:
    dbscan = DBSCAN(eps=2, min_samples=50, leaf_size=leaf_size)
    clusters = dbscan.fit_predict(X)
    labels = dbscan.labels_
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    print('n_clusters_', n_clusters_)
#     plt.subplot(6, 3, i)
#     plt.scatter(X[:,0], X[:,1], c=clusters)
#     plt.title('eps = {}, min_samples = {}'.format(leaf_size))
#     i += 1


# plt.show()
198/30:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for leaf_size in [10, 30, 100, 500]:
    dbscan = DBSCAN(eps=6, min_samples=50, leaf_size=leaf_size)
    clusters = dbscan.fit_predict(X)
    labels = dbscan.labels_
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    print('n_clusters_', n_clusters_)
#     plt.subplot(6, 3, i)
#     plt.scatter(X[:,0], X[:,1], c=clusters)
#     plt.title('eps = {}, min_samples = {}'.format(leaf_size))
#     i += 1


# plt.show()
198/31:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for leaf_size in [10, 30, 100, 500]:
    dbscan = DBSCAN(eps=4, min_samples=50, leaf_size=leaf_size)
    clusters = dbscan.fit_predict(X)
    labels = dbscan.labels_
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    print('n_clusters_', n_clusters_)
#     plt.subplot(6, 3, i)
#     plt.scatter(X[:,0], X[:,1], c=clusters)
#     plt.title('eps = {}, min_samples = {}'.format(leaf_size))
#     i += 1


# plt.show()
198/32:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for leaf_size in [10, 30, 100, 500]:
    dbscan = DBSCAN(eps=5, min_samples=50, leaf_size=leaf_size)
    clusters = dbscan.fit_predict(X)
    labels = dbscan.labels_
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    print('n_clusters_', n_clusters_)
#     plt.subplot(6, 3, i)
#     plt.scatter(X[:,0], X[:,1], c=clusters)
#     plt.title('eps = {}, min_samples = {}'.format(leaf_size))
#     i += 1


# plt.show()
198/33:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for leaf_size in [10, 30, 100, 500]:
    dbscan = DBSCAN(eps=5, min_samples=500, leaf_size=leaf_size)
    clusters = dbscan.fit_predict(X)
    labels = dbscan.labels_
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    print('n_clusters_', n_clusters_)
#     plt.subplot(6, 3, i)
#     plt.scatter(X[:,0], X[:,1], c=clusters)
#     plt.title('eps = {}, min_samples = {}'.format(leaf_size))
#     i += 1


# plt.show()
198/34:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for leaf_size in [10, 30, 100, 500]:
    dbscan = DBSCAN(eps=5, min_samples=60, leaf_size=leaf_size)
    clusters = dbscan.fit_predict(X)
    labels = dbscan.labels_
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    print('n_clusters_', n_clusters_)
#     plt.subplot(6, 3, i)
#     plt.scatter(X[:,0], X[:,1], c=clusters)
#     plt.title('eps = {}, min_samples = {}'.format(leaf_size))
#     i += 1


# plt.show()
198/35:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for leaf_size in [10, 30, 100, 500]:
    dbscan = DBSCAN(eps=5, min_samples=100, leaf_size=leaf_size)
    clusters = dbscan.fit_predict(X)
    labels = dbscan.labels_
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    print('n_clusters_', n_clusters_)
#     plt.subplot(6, 3, i)
#     plt.scatter(X[:,0], X[:,1], c=clusters)
#     plt.title('eps = {}, min_samples = {}'.format(leaf_size))
#     i += 1


# plt.show()
198/36:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for leaf_size in [10, 30, 100, 500]:
    dbscan = DBSCAN(eps=5, min_samples=55, leaf_size=leaf_size)
    clusters = dbscan.fit_predict(X)
    labels = dbscan.labels_
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    print('n_clusters_', n_clusters_)
#     plt.subplot(6, 3, i)
#     plt.scatter(X[:,0], X[:,1], c=clusters)
#     plt.title('eps = {}, min_samples = {}'.format(leaf_size))
#     i += 1


# plt.show()
198/37:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for leaf_size in [10, 30, 100, 500]:
    dbscan = DBSCAN(eps=5, min_samples=49, leaf_size=leaf_size)
    clusters = dbscan.fit_predict(X)
    labels = dbscan.labels_
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    print('n_clusters_', n_clusters_)
#     plt.subplot(6, 3, i)
#     plt.scatter(X[:,0], X[:,1], c=clusters)
#     plt.title('eps = {}, min_samples = {}'.format(leaf_size))
#     i += 1


# plt.show()
198/38:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for algorithm in [‘auto’, ‘ball_tree’, ‘kd_tree’, ‘brute’]:
    dbscan = DBSCAN(eps=5, min_samples=50, algorithm=algorithm)
    clusters = dbscan.fit_predict(X)
    labels = dbscan.labels_
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    print('n_clusters_', n_clusters_)
#     plt.subplot(6, 3, i)
#     plt.scatter(X[:,0], X[:,1], c=clusters)
#     plt.title('eps = {}, min_samples = {}'.format(leaf_size))
#     i += 1


# plt.show()
198/39:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for algorithm in ['auto', 'ball_tree', 'kd_tree', 'brute']:
    dbscan = DBSCAN(eps=5, min_samples=50, algorithm=algorithm)
    clusters = dbscan.fit_predict(X)
    labels = dbscan.labels_
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    print('n_clusters_', n_clusters_)
#     plt.subplot(6, 3, i)
#     plt.scatter(X[:,0], X[:,1], c=clusters)
#     plt.title('eps = {}, min_samples = {}'.format(leaf_size))
#     i += 1


# plt.show()
198/40:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for algorithm in ['auto', 'ball_tree', 'kd_tree', 'brute']:
    dbscan = DBSCAN(eps=15, min_samples=50, algorithm=algorithm)
    clusters = dbscan.fit_predict(X)
    labels = dbscan.labels_
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    print('n_clusters_', n_clusters_)
#     plt.subplot(6, 3, i)
#     plt.scatter(X[:,0], X[:,1], c=clusters)
#     plt.title('eps = {}, min_samples = {}'.format(leaf_size))
#     i += 1


# plt.show()
198/41:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1

for algorithm in ['auto', 'ball_tree', 'kd_tree', 'brute']:
    dbscan = DBSCAN(eps=5, min_samples=50, algorithm=algorithm)
    clusters = dbscan.fit_predict(X)
    labels = dbscan.labels_
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    print('n_clusters_', n_clusters_)
#     plt.subplot(6, 3, i)
#     plt.scatter(X[:,0], X[:,1], c=clusters)
#     plt.title('eps = {}, min_samples = {}'.format(leaf_size))
#     i += 1


# plt.show()
198/42:
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.cluster import DBSCAN
fig = plt.figure(figsize=(20, 10))
fig.subplots_adjust(hspace=.5, wspace=.2)
i = 1
for x in range(10, 0, -1):
    eps = 1/(11-x)
    db = DBSCAN(eps=eps, min_samples=10).fit(X)
    core_samples_mask = np.zeros_like(db.labels_, dtype=bool)
    core_samples_mask[db.core_sample_indices_] = True
    labels = db.labels_
    
    print(eps)
    ax = fig.add_subplot(2, 5, i)
    ax.text(1, 4, "eps = {}".format(round(eps, 1)), fontsize=25, ha="center")
    sns.scatterplot(X[:,0], X[:,1], hue=["cluster-{}".format(x) for x in labels])
    
    i += 1
198/43:
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.cluster import DBSCAN
fig = plt.figure(figsize=(20, 10))
fig.subplots_adjust(hspace=.5, wspace=.2)
i = 1
for x in range(10, 0, -1):
    eps = 1/(11-x)
    db = DBSCAN(eps=eps, min_samples=10).fit(X)
    core_samples_mask = np.zeros_like(db.labels_, dtype=bool)
    core_samples_mask[db.core_sample_indices_] = True
    labels = db.labels_
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    print('n_clusters_', n_clusters_)
    print(eps)
    ax = fig.add_subplot(2, 5, i)
    ax.text(1, 4, "eps = {}".format(round(eps, 1)), fontsize=25, ha="center")
    sns.scatterplot(X[:,0], X[:,1], hue=["cluster-{}".format(x) for x in labels])
    
    i += 1
198/44:
from plantstat import Clusterer
from plantstat.data_generators import ClusterData
198/45: from plantstat import Clusterer
198/46:
pip3 install -U scipy


from plantstat import Clusterer
198/47: pip install git+https://github.com/Nordant/plantstat.git#egg=plantstat
198/48: from plantstat import Clusterer
199/1:
import matplotlib.pyplot as plt
import numpy as np
import pandas

%matplotlib inline
199/2: from sklearn.datasets import load_digits
199/3: digits = load_digits()
199/4: digits = digits["data"]
199/5: digits.shape
199/6:
from sklearn.cluster import KMeans
from sklearn.cluster import DBSCAN
from sklearn.metrics import silhouette_score
199/7:
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X = scaler.fit_transform(digits)
199/8: from plantstat import Clusterer
199/9:
from plantstdbscan = DBSCAN(eps=0.0018288, min_samples=2)
#0.0018288 a radial distance of 6 feet in kilometers
clustering = dbscan.fit_predict(X)
y_pred = dbscan.fit_predict(X)at import Clusterer
199/10:
dbscan = DBSCAN(eps=0.0018288, min_samples=2)
#0.0018288 a radial distance of 6 feet in kilometers
clustering = dbscan.fit_predict(X)
y_pred = dbscan.fit_predict(X)
199/11:
dbscan = DBSCAN(eps=0.0018288, min_samples=2)
#0.0018288 a radial distance of 6 feet in kilometers
clustering = dbscan.fit_predict(X)
y_pred = dbscan.fit_predict(X)
np.unique(dbscan.labels_)
199/12:
from sklearn.cluster import DBSCAN
import numpy as np

db = DBSCAN(eps=0.122, min_samples=10).fit(scaled_p)
labels = db.labels_
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print "number of clusters in pca-DBSCAN: ", n_clusters_
199/13:
from sklearn.cluster import DBSCAN
import numpy as np

db = DBSCAN(eps=0.122, min_samples=10).fit(scaled_p)
labels = db.labels_
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print( "number of clusters in pca-DBSCAN: ", n_clusters_)
199/14:
from sklearn.cluster import DBSCAN
import numpy as np

db = DBSCAN(eps=0.122, min_samples=10).fit(X)
labels = db.labels_
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
print( "number of clusters in pca-DBSCAN: ", n_clusters_)
199/15:
db_cluster = DBSCAN(eps=9.7, min_samples=2, algorithm='ball_tree', metric='minkowski', leaf_size=90, p=2)
arr = db_cluster.fit_predict(X)
print "Clusters assigned are:", set(db_cluster.labels_)
199/16:
db_cluster = DBSCAN(eps=9.7, min_samples=2, algorithm='ball_tree', metric='minkowski', leaf_size=90, p=2)
arr = db_cluster.fit_predict(X)
print("Clusters assigned are:", set(db_cluster.labels_))
199/17:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1
for samples in [2, 40, 50, 500]:
    for e in [0.2, 1, 3, 5, 10]:
        dbscan = DBSCAN(eps=e, min_samples=samples, algorithm='ball_tree', metric='minkowski', leaf_size=90, p=2)
        clusters = dbscan.fit_predict(X)
        plt.subplot(6, 4, i)
        plt.scatter(X[:,0], X[:,1], c=clusters)
        plt.title('eps = {}, min_samples = {}'.format(e, samples))
        i += 1
    i += 1

plt.show()
199/18:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1
for samples in [2, 40, 50, 500]:
    for e in [0.2, 1, 3, 5, 10]:
        dbscan = DBSCAN(eps=e, min_samples=samples, algorithm='ball_tree', metric='minkowski', leaf_size=90, p=2)
        clusters = dbscan.fit_predict(X)
        plt.subplot(6, 4, i)
        plt.scatter(X[:,0], X[:,1], c=clusters)
         labels = dbscan.labels_
        n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
        plt.title('eps = {}, n_clusters_ = {}'.format(e, n_clusters_))
        i += 1
    i += 1

plt.show()
199/19:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1
for samples in [2, 40, 50, 500]:
    for e in [0.2, 1, 3, 5, 10]:
        dbscan = DBSCAN(eps=e, min_samples=samples, algorithm='ball_tree', metric='minkowski', leaf_size=90, p=2)
        clusters = dbscan.fit_predict(X)
        plt.subplot(6, 4, i)
        plt.scatter(X[:,0], X[:,1], c=clusters)
        labels = dbscan.labels_
        n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
        plt.title('eps = {}, n_clusters_ = {}'.format(e, n_clusters_))
        i += 1
    i += 1

plt.show()
199/20:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1
for samples in [2, 40, 50, 500]:
    for e in [3, 5, 6, 9, 10]:
        dbscan = DBSCAN(eps=e, min_samples=samples, algorithm='ball_tree', metric='minkowski', leaf_size=90, p=2)
        clusters = dbscan.fit_predict(X)
        plt.subplot(6, 4, i)
        plt.scatter(X[:,0], X[:,1], c=clusters)
        labels = dbscan.labels_
        n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
        plt.title('eps = {}, min_samples={}, n_clusters_ = {}'.format(e, min_samples, n_clusters_))
        i += 1
    i += 1

plt.show()
199/21:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1
for samples in [2, 40, 50, 500]:
    for e in [3, 5, 6, 9, 10]:
        dbscan = DBSCAN(eps=e, min_samples=samples, algorithm='ball_tree', metric='minkowski', leaf_size=90, p=2)
        clusters = dbscan.fit_predict(X)
        plt.subplot(6, 4, i)
        plt.scatter(X[:,0], X[:,1], c=clusters)
        labels = dbscan.labels_
        n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
        plt.title('eps = {}, min_samples={}, n_clusters_ = {}'.format(e, samples, n_clusters_))
        i += 1
    i += 1

plt.show()
199/22:
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1
for samples in [2, 40, 50, 500]:
    for e in [3, 5, 6, 9, 10]:
        dbscan = DBSCAN(eps=e, min_samples=samples, algorithm='ball_tree', metric='minkowski', leaf_size=90, p=2)
        clusters = dbscan.fit_predict(X)
        plt.subplot(6, 4, i)
        plt.scatter(X[:,0], X[:,1], c=clusters)
        labels = dbscan.labels_
        n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
        plt.title('eps = {},\n min_samples={}, n_clusters_ = {}'.format(e, samples, n_clusters_))
        i += 1
    i += 1

plt.show()
199/23:
dbscan = DBSCAN(eps=6, min_samples=10, algorithm='ball_tree', metric='minkowski', leaf_size=90, p=2)
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
199/24:
dbscan = DBSCAN(eps=6, min_samples=10, algorithm='ball_tree', metric='minkowski', leaf_size=90, p=2)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_


# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_clusters_
199/25:
# подберем оптимальные параметры для DBSCAN
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1
for samples in [2, 40, 50, 500]:
    for e in [3, 5, 6, 9, 10]:
        dbscan = DBSCAN(eps=e, min_samples=samples, algorithm='ball_tree', metric='minkowski', leaf_size=90, p=2)
        clusters = dbscan.fit_predict(X)
        plt.subplot(6, 4, i)
        plt.scatter(X[:,0], X[:,1], c=clusters)
        labels = dbscan.labels_
        n_clusters_ = np.unique(dbscan.labels_)
        plt.title('eps = {},\n min_samples={}, n_clusters_ = {}'.format(e, samples, n_clusters_))
        i += 1
    i += 1

plt.show()
199/26:
# подберем оптимальные параметры для DBSCAN
from sklearn.cluster import DBSCAN
plt.figure(figsize=(15,23))
i = 1
for samples in [2, 40, 50, 500]:
    for e in [3, 5, 6, 9, 10]:
        dbscan = DBSCAN(eps=e, min_samples=samples, algorithm='ball_tree', metric='minkowski', leaf_size=90, p=2)
        clusters = dbscan.fit_predict(X)
        plt.subplot(6, 4, i)
        plt.scatter(X[:,0], X[:,1], c=clusters)
        labels = dbscan.labels_
        n_clusters_ = np.unique(dbscan.labels_).size
        plt.title('eps = {},\n min_samples={}, n_clusters_ = {}'.format(e, samples, n_clusters_))
        i += 1
    i += 1

plt.show()
199/27:
dbscan = DBSCAN(eps=6, min_samples=2, algorithm='ball_tree', metric='minkowski', leaf_size=90, p=2)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_
labels
199/28:
dbscan = DBSCAN(eps=6, min_samples=2, algorithm='ball_tree', metric='minkowski', leaf_size=90, p=2)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_
 np.unique(dbscan.labels_)
199/29:
dbscan = DBSCAN(eps=6, min_samples=2, algorithm='ball_tree', metric='minkowski', leaf_size=90, p=2)
clusters = dbscan.fit_predict(X)
labels = dbscan.labels_
np.unique(dbscan.labels_)
199/30:
n_samples, n_features = X.shape
n_digits = len(np.unique(digits))
199/31:
k_means = KMeans(n_clusters=10)
k_means = k_means.fit(digits)
clusters = k_means.predict(digits)

print('Silhouette score:', silhouette_score(digits, clusters))
199/32:
plt.imshow(digits[100].reshape(8, 8), cmap="gray")
plt.show()
199/33: clusters
199/34: clusters.shape
199/35: clusters
199/36: print('Silhouette score:', silhouette_score(X, clusters))
199/37:
un_cl = np.unique(dbscan.clusters)
un_cl

# plt.imshow(digits[100].reshape(8, 8), cmap="gray")
# plt.show()
199/38:
un_cl = np.unique(clusters)
un_cl

# plt.imshow(digits[100].reshape(8, 8), cmap="gray")
# plt.show()
199/39:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}
counter
for cl in clusters:
    

# plt.imshow(digits[100].reshape(8, 8), cmap="gray")
# plt.show()
199/40:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}
counter
for cl in clusters:
    pass

# plt.imshow(digits[100].reshape(8, 8), cmap="gray")
# plt.show()
199/41:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}
counter
# for cl in clusters:
#     pass

# plt.imshow(digits[100].reshape(8, 8), cmap="gray")
# plt.show()
199/42:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

for cl in clusters:
    if counter.get(cl) != 3:
       counter[cl] += 1
        

# plt.imshow(digits[100].reshape(8, 8), cmap="gray")
# plt.show()
199/43:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

for idx, cl in enumerate(clusters):
    if counter.get(cl) != 3:
       counter[cl] += 1
        print(digits[idx])
        

# plt.imshow(digits[100].reshape(8, 8), cmap="gray")
# plt.show()
199/44:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

for idx, cl in enumerate(clusters):
    if counter.get(cl) != 3:
       counter[cl] += 1
       print(digits[idx])
        

# plt.imshow(digits[100].reshape(8, 8), cmap="gray")
# plt.show()
199/45:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

for idx, cl in enumerate(clusters):
    if counter.get(cl) != 3:
        counter[cl] += 1
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.show()
199/46:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl, 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) != 3:
        counter[cl] += 1
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.subplot(rows, cols, i + 1)
        plt.title(f'Cluster {idx}')

plt.subplot(rows, cols, n_samples)
199/47:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl, 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) != 3:
        counter[cl] += 1
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.subplot(rows, cols, i + 1)
        plt.title(f'Cluster {idx}')

plt.subplot(rows, cols)
199/48:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl, 3
n_samples = rows * cols
print('n_samples', n_samples)
for idx, cl in enumerate(clusters):
    if counter.get(cl) != 3:
        counter[cl] += 1
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.subplot(rows, cols, i + 1)
        plt.title(f'Cluster {idx}')

plt.subplot(rows, cols, n_samples)
199/49:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols
print('n_samples', n_samples)
for idx, cl in enumerate(clusters):
    if counter.get(cl) != 3:
        counter[cl] += 1
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.subplot(rows, cols, i + 1)
        plt.title(f'Cluster {idx}')

plt.subplot(rows, cols, n_samples)
199/50:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) != 3:
        counter[cl] += 1
        plt.subplot(rows, cols, i + 1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {idx}')

plt.subplot(rows, cols, n_samples)
199/51:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) != 3:
        counter[cl] += 1
        plt.subplot(rows, cols, idx + 1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {idx}')

plt.subplot(rows, cols, n_samples)
199/52:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        counter[cl] += 1
        plt.subplot(rows, cols, idx + 1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')

plt.subplot(rows, cols, n_samples)
199/53:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        counter[cl] += 1
        plt.subplot(rows, cols, idx + 1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')
    else:
        return

plt.subplot(rows, cols, n_samples)
199/54:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        counter[cl] += 1
        plt.subplot(rows, cols, idx + 1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')
    else:
        return

plt.subplot(rows, cols, n_samples)
199/55:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        counter[cl] += 1
        plt.subplot(rows, cols, idx + 1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')
    else:
        pass

plt.subplot(rows, cols, n_samples)
199/56:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        counter[cl] += 1
        print('counter[cl]', counter[cl])
        plt.subplot(rows, cols, idx + 1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')

# plt.subplot(rows, cols, n_samples)
199/57:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        counter[cl] += 1
        print('counter', counter)
        plt.subplot(rows, cols, idx + 1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')

# plt.subplot(rows, cols, n_samples)
199/58:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = (un_cl.size +1), 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        counter[cl] += 1
        plt.subplot(rows, cols, idx + 1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')

plt.subplot(rows, cols, n_samples)
199/59:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = (un_cl.size +1), 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        counter[cl] += 1
        print('counter', counter)
        plt.subplot(rows, cols, idx + 1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')

# plt.subplot(rows, cols, n_samples)
print('n_samples', n_samples)
199/60:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = (un_cl.size +1), 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        counter[cl] += 1
#         print('counter', counter)
#         plt.subplot(rows, cols, idx + 1)
#         plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
#         plt.title(f'Cluster {cl}, image {idx}')

# plt.subplot(rows, cols, n_samples)
print('n_samples', n_samples)
199/61:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        counter[cl] += 1
#         plt.subplot(rows, cols, idx + 1)
#         plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
#         plt.title(f'Cluster {cl}, image {idx}')

# plt.subplot(rows, cols, n_samples)
print('n_samples', n_samples)
199/62:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        print(idx)
        counter[cl] += 1
#         plt.subplot(rows, cols, idx + 1)
#         plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
#         plt.title(f'Cluster {cl}, image {idx}')

# plt.subplot(rows, cols, n_samples)
print('n_samples', n_samples)
199/63:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        print(idx)
        counter[cl] += 1
        plt.subplot(rows, cols, idx)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')

# plt.subplot(rows, cols, n_samples)
print('n_samples', n_samples)
199/64:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        print(idx)
        counter[cl] += 1
        plt.subplot(rows, cols, idx)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')

plt.subplot(rows, cols, n_samples)
print('n_samples', n_samples)
199/65:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        print(idx)
        counter[cl] += 1
        plt.subplot(rows, cols, idx)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')

plt.subplot(rows, cols, n_samples)
print('n_samples', n_samples)
199/66:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        print(idx)
        counter[cl] += 1
        plt.subplot(rows, cols, idx+1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')

plt.subplot(rows, cols, n_samples)
print('n_samples', n_samples)
199/67:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        i +=1
        counter[cl] += 1
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')

plt.subplot(rows, cols, n_samples)
print('n_samples', n_samples)
199/68:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        i +=1
        counter[cl] += 1
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')

plt.subplot(rows, cols, n_samples)
199/69:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        i +=1
        counter[cl] += 1
        plt.subplot(rows, cols, i+1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')

plt.subplot(rows, cols, n_samples)
199/70:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        counter[cl] += 1
        plt.subplot(rows, cols, i+1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')

plt.subplot(rows, cols, n_samples)
199/71:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        counter[cl] += 1
        plt.subplot(rows, cols, i+1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')
        i+=1

plt.subplot(rows, cols, n_samples)
199/72:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 8))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        counter[cl] += 1
        plt.subplot(rows, cols, i+1)
        plt.imshow(digits[idx].reshape(64, 64), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')
        i+=1

plt.subplot(rows, cols, n_samples)
199/73:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(8, 16))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        counter[cl] += 1
        plt.subplot(rows, cols, i+1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')
        i+=1

plt.subplot(rows, cols, n_samples)
199/74:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(16, 32))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        counter[cl] += 1
        plt.subplot(rows, cols, i+1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')
        i+=1

plt.subplot(rows, cols, n_samples)
199/75:
un_cl = np.unique(clusters)
counter = {el:0 for el in un_cl}

plt.figure(figsize=(10, 20))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        counter[cl] += 1
        plt.subplot(rows, cols, i+1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')
        i+=1

plt.subplot(rows, cols, n_samples)
199/76:
un_cl = np.unique(clusters)
counter = {el:[] for el in un_cl}

plt.figure(figsize=(10, 20))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        counter[cl].append(idx)
        
print(counter)      
        
#         plt.subplot(rows, cols, i+1)
#         plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
#         plt.title(f'Cluster {cl}, image {idx}')
#         i+=1

# plt.subplot(rows, cols, n_samples)
199/77:
un_cl = np.unique(clusters)
counter = {el:[] for el in un_cl}
        
print(counter)      
        
plt.figure(figsize=(10, 20))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if counter.get(cl) < 3:
        counter[cl].append(idx)
        
print(counter)      
        
#         plt.subplot(rows, cols, i+1)
#         plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
#         plt.title(f'Cluster {cl}, image {idx}')
#         i+=1

# plt.subplot(rows, cols, n_samples)
199/78:
un_cl = np.unique(clusters)
counter = {el:[] for el in un_cl}
        
print(counter)      
        
plt.figure(figsize=(10, 20))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if counter.get(cl).len < 3:
        counter[cl].append(idx)
        
print(counter)      
        
#         plt.subplot(rows, cols, i+1)
#         plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
#         plt.title(f'Cluster {cl}, image {idx}')
#         i+=1

# plt.subplot(rows, cols, n_samples)
199/79:
un_cl = np.unique(clusters)
counter = {el:[] for el in un_cl}
        
print(counter)      
        
plt.figure(figsize=(10, 20))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if len(counter.get(cl)) < 3:
        counter[cl].append(idx)
        
print(counter)      
        
#         plt.subplot(rows, cols, i+1)
#         plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
#         plt.title(f'Cluster {cl}, image {idx}')
#         i+=1

# plt.subplot(rows, cols, n_samples)
199/80:
un_cl = np.unique(clusters)
counter = {el:[] for el in un_cl}     
        
plt.figure(figsize=(10, 20))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if len(counter.get(cl)) < 3:
        counter[cl].append(idx)
        
print(counter)      
        
#         plt.subplot(rows, cols, i+1)
#         plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
#         plt.title(f'Cluster {cl}, image {idx}')
#         i+=1

# plt.subplot(rows, cols, n_samples)
199/81:
un_cl = np.unique(clusters)
counter = {el:[] for el in un_cl}     
        
plt.figure(figsize=(10, 20))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if len(counter.get(cl)) < 3:
        counter[cl].append(idx)
        
for v in counter.values():
    print(v)        
#         plt.subplot(rows, cols, i+1)
#         plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
#         plt.title(f'Cluster {cl}, image {idx}')
#         i+=1

# plt.subplot(rows, cols, n_samples)
199/82:
un_cl = np.unique(clusters)
counter = {el:[] for el in un_cl}     
        
plt.figure(figsize=(10, 20))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if len(counter.get(cl)) < 3:
        counter[cl].append(idx)
        
for v in counter.values():
    for n in v:
        print(n)
#         plt.subplot(rows, cols, i+1)
#         plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
#         plt.title(f'Cluster {cl}, image {idx}')
#         i+=1

# plt.subplot(rows, cols, n_samples)
199/83:
un_cl = np.unique(clusters)
counter = {el:[] for el in un_cl}     
        
plt.figure(figsize=(10, 20))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if len(counter.get(cl)) < 3:
        counter[cl].append(idx)
        
for v in counter.values():
    for idx in v:
        plt.subplot(rows, cols, i+1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {cl}, image {idx}')
        i+=1

plt.subplot(rows, cols, n_samples)
199/84:
un_cl = np.unique(clusters)
counter = {el:[] for el in un_cl}     
        
plt.figure(figsize=(10, 20))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if len(counter.get(cl)) < 3:
        counter[cl].append(idx)
        
for v in counter.values():
    for idx in v:
        plt.subplot(rows, cols, i+1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {v}, image {i}')
        i+=1

plt.subplot(rows, cols, n_samples)
199/85:
un_cl = np.unique(clusters)
counter = {el:[] for el in un_cl}     
        
plt.figure(figsize=(10, 20))
rows, cols = un_cl.size, 3
n_samples = rows * cols
i = 0

for idx, cl in enumerate(clusters):
    if len(counter.get(cl)) < 3:
        counter[cl].append(idx)
        
for k, v in counter.items():
    for idx in v:
        plt.subplot(rows, cols, i+1)
        plt.imshow(digits[idx].reshape(8, 8), cmap="gray")
        plt.title(f'Cluster {k}, image {i}')
        i+=1

plt.subplot(rows, cols, n_samples)
201/1:
import numpy as np
import pandas as pd

from scipy import stats as sts

import seaborn as sns
import matplotlib.pyplot as plt

plt.style.use('ggplot')
201/2:
df = pd.read_csv('./data/df_vk_wise.csv')[50:]
df.head()
201/3:
df = pd.read_csv('../data/df_vk_wise.csv')[50:]
df.head()
201/4:
df = pd.read_csv('../data/df_vk_wise.csv')[50:]
df.head()
201/5:
import numpy as np
import pandas as pd

from scipy import stats as sts

import seaborn as sns
import matplotlib.pyplot as plt

plt.style.use('ggplot')
201/6:
df = pd.read_csv('./data/df_vk_wise.csv')[50:]
df.head()
201/7:
df = pd.read_csv('.data/df_vk_wise.csv')[50:]
df.head()
201/8:
df = pd.read_csv('./data/df_vk_wise.csv')[50:]
df.head()
201/9:
df = pd.read_csv('./data/df_vk_wise.csv')[50:]
df.head()
201/10:
df = pd.read_csv('./data/youtube_data.csv')[50:]
df.head()
201/11:
df = pd.read_csv('./data/youtube_data.csv')[50:]
df.head()
202/1:
import numpy as np
import pandas as pd

from scipy import stats as sts

import seaborn as sns
import matplotlib.pyplot as plt

plt.style.use('ggplot')
202/2:
df = pd.read_csv('./data/df_vk_wise.csv')[50:]
df.head()
202/3:
has_pronouns = df[df[I] is True]
has_pronouns.head()
# plt.figure(figsize=(12,6))

# plt.hist(theta1, alpha=0.5, label='has pronouns')
# plt.legend();
202/4:
has_pronouns = df[df[I] is True]
has_pronouns.head()
# plt.figure(figsize=(12,6))

# plt.hist(theta1, alpha=0.5, label='has pronouns')
# plt.legend();
202/5:
has_pronouns = df[df.I is True]
has_pronouns.head()
# plt.figure(figsize=(12,6))

# plt.hist(theta1, alpha=0.5, label='has pronouns')
# plt.legend();
202/6:
has_pronouns = df[df.I == True]
has_pronouns.head()
# plt.figure(figsize=(12,6))

# plt.hist(theta1, alpha=0.5, label='has pronouns')
# plt.legend();
202/7:
has_pronouns = df[df.I == True]['likes']
has_pronouns.head()
# plt.figure(figsize=(12,6))

# plt.hist(theta1, alpha=0.5, label='has pronouns')
# plt.legend();
202/8:
has_pronouns = df[df.I == True]['likes']
plt.figure(figsize=(12,6))

plt.hist(has_pronouns, label='has pronouns')
plt.legend();
202/9:
has_not_pronouns = df[df.I == False]['likes']
plt.figure(figsize=(12,6))

plt.hist(has_not_pronouns, label='doesn"t have pronouns')
plt.legend();
202/10:
has_pronouns = df[df.I == True]['likes']
# plt.figure(figsize=(12,6))

# plt.hist(has_pronouns, label='has pronouns')
# plt.legend();
sns.histplot(has_pronouns, bins=10, stat='density', kde=True)
202/11:
has_pronouns = df[df.I == True]['likes']
# plt.figure(figsize=(12,6))

# plt.hist(has_pronouns, label='has pronouns')
# plt.legend();
sns.histplot(has_pronouns, bins=10, stat='dsd', kde=True)
202/12:
has_pronouns = df[df.I == True]['likes']
# plt.figure(figsize=(12,6))

# plt.hist(has_pronouns, label='has pronouns')
# plt.legend();
sns.histplot(has_pronouns, bins=10, stat='density', kde=True)
202/13:
has_not_pronouns = df[df.I == False]['likes']


sns.histplot(has_not_pronouns, bins=10, stat='density', kde=True)
202/14:
has_pronouns_mean = has_pronouns.mean()
has_not_pronouns_mean = has_not_pronouns.mean()

has_pronouns_median = has_pronouns.median()
has_not_pronouns_median = has_not_pronouns.median()
202/15:
has_pronouns_mean = has_pronouns.mean()
has_not_pronouns_mean = has_not_pronouns.mean()

has_pronouns_median = has_pronouns.median()
has_not_pronouns_median = has_not_pronouns.median()

print(f'среднее {has_pronouns_mean} и медиана {has_pronouns_median} для постов, содержащих местоимения')
print(f'среднее {has_not_pronouns_mean} и медиана {has_not_pronouns_median} для постов, НЕ содержащих местоимения')
202/16:
likes_mean = df['likes'].mean()
likes_median = df['likes'].median()
print(f'среднее {likes_mean} и медиана {likes_median} для всех постов')
202/17:
mu_with_pr = has_pronouns.mean()
mu_without_pr = has_not_pronouns.mean()

has_pronouns_median = has_pronouns.median()
has_not_pronouns_median = has_not_pronouns.median()

print(f'среднее {mu_with_pr} и медиана {has_pronouns_median} для постов, содержащих местоимения')
print(f'среднее {mu_without_pr} и медиана {has_not_pronouns_median} для постов, НЕ содержащих местоимения')
202/18:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H0 те, кто пишут и не пишут местоимения, ставят в среднем одинаковое кол-во лайков
# mu_with_pr > mu_without_pr

alpha = 0.05                                                  
n_with_pr, n_without_pr = has_pronouns.size, has_not_pronouns.size

diff = mu_with_pr - mu_without_pr                                # разность средних
diff_std = np.sqrt(has_pronouns.var(ddof=1)/n_with_pr + has_not_pronouns.var(ddof=1)/n_without_pr)   # стандартное отклонение

z_obs = diff/diff_std 

print(f'Наблюдаемое значение {z_obs:.5}')
202/19:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
z_crit = stats.norm.ppf(1 - alpha)               # критическое значение статистики

pval =  2 * (1 - stats.norm().cdf(np.abs(z_obs)))


print(f'{z_obs:.3} не попадает в ({-z_crit:.3} , {z_crit:.3}) => Нулевая гипотеза отвергается')
print('pval', pval)
202/20:
import numpy as np
import pandas as pd

from scipy import stats as sts
from scipy import stats
import statsmodels as sts

import seaborn as sns
import matplotlib.pyplot as plt

plt.style.use('ggplot')
202/21:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
z_crit = stats.norm.ppf(1 - alpha)               # критическое значение статистики

pval =  2 * (1 - stats.norm().cdf(np.abs(z_obs)))


print(f'{z_obs:.3} не попадает в ({-z_crit:.3} , {z_crit:.3}) => Нулевая гипотеза отвергается')
print('pval', pval)
202/22:
# проверка того, что задание решено верно
assert np.abs(z_obs - 2.6644610922505323) < 1e-5
202/23:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_with_pr= mu_without_pr те, кто пишут и не пишут местоимения, ставят в среднем одинаковое кол-во лайков
# H_1: mu_with_pr > mu_without_pr

alpha = 0.05                                                  
n_with_pr, n_without_pr = has_pronouns.size, has_not_pronouns.size

diff = mu_with_pr - mu_without_pr                                # разность средних
diff_std = np.sqrt(has_pronouns.var(ddof=1)/n_with_pr + has_not_pronouns.var(ddof=1)/n_without_pr)   # стандартное отклонение

z_obs = diff/diff_std # наблюдаемое значение статистики 

print(f'Наблюдаемое значение {z_obs}')
202/24:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_with_pr= mu_without_pr те, кто пишут и не пишут местоимения, ставят в среднем одинаковое кол-во лайков
# H_1: mu_with_pr > mu_without_pr

alpha = 0.05                                                  
n_with_pr, n_without_pr = has_pronouns.size, has_not_pronouns.size

diff = mu_with_pr - mu_without_pr                                # разность средних
diff_std = np.sqrt(has_pronouns.var(ddof=1)/n_with_pr + has_not_pronouns.var(ddof=1)/n_without_pr)   # стандартное отклонение

z_obs = diff/diff_std # наблюдаемое значение статистики 

print(f'Наблюдаемое значение {z_obs.6}')
202/25:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_with_pr= mu_without_pr те, кто пишут и не пишут местоимения, ставят в среднем одинаковое кол-во лайков
# H_1: mu_with_pr > mu_without_pr

alpha = 0.05                                                  
n_with_pr, n_without_pr = has_pronouns.size, has_not_pronouns.size

diff = mu_with_pr - mu_without_pr                                # разность средних
diff_std = np.sqrt(has_pronouns.var(ddof=1)/n_with_pr + has_not_pronouns.var(ddof=1)/n_without_pr)   # стандартное отклонение

z_obs = diff/diff_std # наблюдаемое значение статистики 

print(f'Наблюдаемое значение {z_obs:.6}')
202/26:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая
# H_1: var > 25 партия плохая

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_obs
202/27:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая
# H_1: var > 25 партия плохая

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.cdf(0.99, n-1)  # критическое значение

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5} => нулевая гипотеза не отвергается')
202/28:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая
# H_1: var > 25 партия плохая

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.cdf(0.95, 9)  # критическое значение

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5} => нулевая гипотеза не отвергается')
202/29:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая
# H_1: var > 25 партия плохая

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.cdf(0.95, df=9)  # критическое значение

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5} => нулевая гипотеза не отвергается')
202/30:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая
# H_1: var > 25 партия плохая

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(0.95, df=9)  # критическое значение

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5} => нулевая гипотеза не отвергается')
202/31:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая
# H_1: var > 25 партия плохая

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5} => нулевая гипотеза не отвергается')
202/32:
# проверка того, что задание решено верно
assert np.abs(chi_obs - 9.72) < 1e-1
assert np.abs(F_obs - 1.44) < 1e-1
202/33:
# проверка того, что задание решено верно
assert np.abs(chi_obs - 9.72) < 1e-1
# assert np.abs(F_obs - 1.44) < 1e-1
202/34:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5} =>гипотеза H_0 не отвергается')
202/35:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var_new = var_old = технологии обладают одинаковой дисперсией
# H_1: var_old > var_new  новая технология обладает меньшей дисперсией

alpha = 0.01

std_old = 6
std_new = 5

F_obs = 6**2/5**2

pval2 = ...
print('F_obs', v)
202/36:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var_new = var_old = технологии обладают одинаковой дисперсией
# H_1: var_old > var_new  новая технология обладает меньшей дисперсией

alpha = 0.01

std_old = 6
std_new = 5

F_obs = 6**2/5**2

pval2 = ...
print('F_obs', F_obs)
202/37:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var_new = var_old = технологии обладают одинаковой дисперсией
# H_1: var_old > var_new  новая технология обладает меньшей дисперсией

alpha = 0.01
n, m = 100, 100
std_old = 6
std_new = 5

F_obs = 6**2/5**2

left = F_obs * stats.f(n-1, m-1).ppf(alpha/2)
right = F_obs * stats.f(n-1, m-1).ppf(1 - alpha/2)
                                  
pval2 = ...
print('F_obs', F_obs)
print(f'Наблюдаемое значение {F_obs:.5}')

print("Доверительный интервал [{:.5}; {:.5}] ширины {:.5}".format(left, right, right - left))
203/1:
df = pd.read_csv('./data/presidents.csv')
df.head()
203/2:
import numpy as np
import pandas as pd

from scipy import stats as sts
from scipy import stats
import statsmodels as sts

import seaborn as sns
import matplotlib.pyplot as plt

plt.style.use('ggplot')
203/3:
df = pd.read_csv('./data/presidents.csv')
df.head()
203/4:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
x = df.query('1969<=time<=1972.2')['value'].dropna().values
y = df.query('1972.3<=time<=1974.2')['value'].dropna().values
 ч
203/5:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
x = df.query('1969<=time<=1972.2')['value'].dropna().values
y = df.query('1972.3<=time<=1974.2')['value'].dropna().values
x
203/6:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

df = pd.melt(df, id_vars=['year'], value_vars=['Qtr1', 'Qtr2', "Qtr3", "Qtr4"])
df['time'] = df['year'] + df['variable'].str[-1].astype(int)/10

x = df.query('1969<=time<=1972.2')['value'].dropna().values
y = df.query('1972.3<=time<=1974.2')['value'].dropna().values
x
203/7:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

df = pd.melt(df, id_vars=['year'], value_vars=['Qtr1', 'Qtr2', "Qtr3", "Qtr4"])
df['time'] = df['year'] + df['variable'].str[-1].astype(int)/10

x = df.query('1969<=time<=1972.2')['value'].dropna().values
y = df.query('1972.3<=time<=1974.2')['value'].dropna().values
y
203/8:
df = pd.read_csv('./data/presidents.csv')
df.head()
203/9:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

df = pd.melt(df, id_vars=['year'], value_vars=['Qtr1', 'Qtr2', "Qtr3", "Qtr4"])
df['time'] = df['year'] + df['variable'].str[-1].astype(int)/10

x = df.query('1969<=time<=1972.2')['value'].dropna().values
y = df.query('1972.3<=time<=1974.2')['value'].dropna().values
y
203/10: x.mean(), y.mean()
203/11:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг распределён нормально
# H_1: mu_x > mu_y

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних
genral_var = x.var(ddof=1)# дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(genral_var/xx + genral_var/ny)   # стандартное отклонение

obs = diff/diff_std # наблюдаемое значение статистики
pval = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))

print(f'Наблюдаемое значение {obs:.6}')
203/12:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг распределён нормально
# H_1: mu_x > mu_y

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних
genral_var = x.var(ddof=1)# дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(genral_var/nx + genral_var/ny)   # стандартное отклонение

obs = diff/diff_std # наблюдаемое значение статистики
pval = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))

print(f'Наблюдаемое значение {obs:.6}')
203/13:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг распределён нормально
# H_1: mu_x > mu_y

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних
genral_var = x.var(ddof=1)# дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(genral_var/nx + genral_var/ny)   # стандартное отклонение

obs = diff/diff_std # наблюдаемое значение статистики
pval = 2 * (1 - stats.norm().cdf(np.abs(obs)))

print(f'Наблюдаемое значение {obs:.6}')
203/14:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг распределён нормально
# H_1: mu_x > mu_y

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних
genral_var = x.var(ddof=1)# дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(genral_var/nx + y.var(ddof=1)/ny)   # стандартное отклонение

obs = diff/diff_std # наблюдаемое значение статистики
pval = 2 * (1 - stats.norm().cdf(np.abs(obs)))

print(f'Наблюдаемое значение {obs:.6}')
203/15:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг распределён нормально
# H_1: mu_x > mu_y

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних
genral_var = x.var(ddof=1)# дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(genral_var/nx + genral_var/ny)   # стандартное отклонение

obs = diff/diff_std # наблюдаемое значение статистики
pval = 2 * (1 - stats.norm().cdf(np.abs(obs)))

print(f'Наблюдаемое значение {obs:.6}')
203/16:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг распределён нормально
# H_1: mu_x > mu_y

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних
genral_var = x.var(ddof=1)# дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(genral_var/nx + genral_var/ny)   # стандартное отклонение

obs = diff/diff_std # наблюдаемое значение статистики
pval = 2 * (1 - stats.norm().cdf(np.abs(obs)))

print(f'Наблюдаемое значение {obs:.6}')
203/17:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг распределён нормально
# H_1: mu_x > mu_y

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних

diff_var = ((nx - 1)*x.var(ddof=1) + (ny - 1)*y.var(ddof=1))/(nx + ny - 2)) # дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(diff_var/nx + diff_var/ny)                   # стандартное отклонение

t_obs = diff/diff_std                                           # наблюдаемое значение
t_crit = stats.t(df = nx + ny - 2).ppf(1 - alpha)               # критическое значени

print(f'Наблюдаемое значение {obs:.6}')
203/18:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг распределён нормально
# H_1: mu_x > mu_y

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних

diff_var = ((nx - 1)*x.var(ddof=1) + (ny - 1)*y.var(ddof=1))/(nx + ny - 2) # дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(diff_var/nx + diff_var/ny)                   # стандартное отклонение

t_obs = diff/diff_std                                           # наблюдаемое значение
t_crit = stats.t(df = nx + ny - 2).ppf(1 - alpha)               # критическое значени

print(f'Наблюдаемое значение {obs:.6}')
203/19:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг распределён нормально
# H_1: mu_x > mu_y

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних

diff_var = ((nx - 1)*x.var(ddof=1) + (ny - 1)*y.var(ddof=1))/(nx + ny - 2) # дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(diff_var/nx + diff_var/ny)                   # стандартное отклонение

t_obs = diff/diff_std                                           # наблюдаемое значение
t_crit = stats.t(df = nx + ny - 2).ppf(1 - alpha)               # критическое значени

print(f'Наблюдаемое значение {obs:.6}')
203/20:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг распределён нормально
# H_1: mu_x > mu_y

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних

diff_var = ((nx - 1)*x.var(ddof=1) + (ny - 1)*y.var(ddof=1))/(nx + ny - 2) # дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(diff_var/nx + diff_var/ny)                   # стандартное отклонение

t_obs = diff/diff_std                                           # наблюдаемое значение
t_crit = stats.t(df = nx + ny - 2).ppf(1 - alpha)               # критическое значени

print(f'Наблюдаемое значение {obs:.6}')
203/21:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг распределён нормально
# H_1: mu_x > mu_y

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних

diff_var = ((nx - 1)*x.var(ddof=1) + (ny - 1)*y.var(ddof=1))/(nx + ny - 2) # дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(diff_var/nx + diff_var/ny)                   # стандартное отклонение

t_obs = diff/diff_std                                           # наблюдаемое значение
t_crit = stats.t(df = nx + ny - 2).ppf(1 - alpha)               # критическое значени

print(f'Наблюдаемое значение {obs:.6}')
203/22:
import numpy as np
import pandas as pd

from scipy import stats as sts
from scipy import stats
import statsmodels as sts

import seaborn as sns
import matplotlib.pyplot as plt
from statsmodels.stats.weightstats import ttest_ind

plt.style.use('ggplot')
203/23:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг распределён нормально
# H_1: mu_x > mu_y

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних

diff_var = ((nx - 1)*x.var(ddof=1) + (ny - 1)*y.var(ddof=1))/(nx + ny - 2) # дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(diff_var/nx + diff_var/ny)                   # стандартное отклонение

obs = diff/diff_std                                           # наблюдаемое значение
crit = stats.t(df = nx + ny - 2).ppf(1 - alpha)               # критическое значени


obs, pval, _ = ttest_ind(x, y, value=0, alternative='larger')

print(f'Наблюдаемое значение {obs:.6}, p-value {pval:.6}')
203/24:
# проверка того, что задание решено верно
assert np.abs(obs - 3.5640741313229793) < 1e-5
203/25:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг распределён нормально
# H_1: mu_x > mu_y

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних

diff_var = ((nx - 1)*x.var(ddof=1) + (ny - 1)*y.var(ddof=1))/(nx + ny - 2) # дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(diff_var/nx + diff_var/ny)                   # стандартное отклонение

obs = diff/diff_std                                           # наблюдаемое значение
crit = stats.t(df = nx + ny - 2).ppf(1 - alpha)               # критическое значени


obs, pval, _ = ttest_ind(x, y, value=0, alternative='larger')

print(f'Наблюдаемое значение {obs:.6}, p-value {pval:.6}, критическое значение{crit:.6}')
203/26:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг распределён нормально
# H_1: mu_x > mu_y

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних

diff_var = ((nx - 1)*x.var(ddof=1) + (ny - 1)*y.var(ddof=1))/(nx + ny - 2) # дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(diff_var/nx + diff_var/ny)                   # стандартное отклонение

obs = diff/diff_std                                           # наблюдаемое значение
crit = stats.t(df = nx + ny - 2).ppf(1 - alpha)               # критическое значени


obs, pval, _ = ttest_ind(x, y, value=0, alternative='larger')

print(f'Наблюдаемое значение {obs:.6}, p-value {pval:.6}, критическое значение {crit:.6}')
203/27:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг распределён нормально
# H_1: mu_x > mu_y

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних

diff_var = ((nx - 1)*x.var(ddof=1) + (ny - 1)*y.var(ddof=1))/(nx + ny - 2) # дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(diff_var/nx + diff_var/ny)                   # стандартное отклонение

obs = diff/diff_std                                           # наблюдаемое значение
crit = stats.t(df = nx + ny - 2).ppf(1 - alpha)               # критическое значени


obs, pval, _ = ttest_ind(x, y, value=0, alternative='larger')

print(f'Наблюдаемое значение {obs:.6}, p-value {pval:.6}, критическое значение {crit:.6}')
print('Наблюдаемое значение 3.5640 меньше критического 1.73406 => нулевая гипотеза отвергается')
203/28:
df = pd.read_csv('./data/sleep.csv')
df.head()
203/29:
df = pd.read_csv('./data/sleep.csv')
df.head(10)
203/30:
df = pd.read_csv('./data/sleep.csv')
df.head(14)
203/31:
df = pd.read_csv('./data/sleep.csv')
df
203/32:
df = pd.read_csv('./data/sleep.csv')
df.size
203/33:
df = pd.read_csv('./data/sleep.csv')
df.shape
203/34:
df = pd.read_csv('./data/sleep.csv')
df
203/35:
before = df[df[group] == 1].extra
after = df[df[group] == 2].extra
after.head
203/36:
before = df[df['group'] == 1].extra
after = df[df['group'] == 2].extra
after.head
203/37:
before = df[df['group'] == 1].extra
after = df[df['group'] == 2].extra
after.head()
203/38:
before = df[df['group'] == 1].extra
after = df[df['group'] == 2].extra
after
203/39:
before = df[df['group'] == 1].extra
after = df[df['group'] == 2].extra
203/40:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std = x.std(ddof=1)/np.sqrt(n)


tobs1 = (mu - mu_0)/std #
z_crit = stats.norm().ppf(1 - alpha/2)

pval1 = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))
203/41:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std = x.std(ddof=1)/np.sqrt(n)


tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики
z_crit = stats.norm().ppf(1 - alpha/2)  # крит значение статистики

pval1 = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))

print(f'{tobs1:.3} не попадает в ({-z_crit:.3} , {z_crit:.3}) => Нулевая гипотеза отвергается')
print('pval1', pval1)
203/42:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std = x.std(ddof=1)/np.sqrt(n)


tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики
z_crit = stats.norm().ppf(1 - alpha/2)  # крит значение статистики

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'{tobs1:.3} не попадает в ({-z_crit:.3} , {z_crit:.3}) => Нулевая гипотеза отвергается')
print('pval1', pval1)
203/43:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
    mu_0 = 8     # тест мат ожидание
n = before.size
mu = before.mean()
std = x.std(ddof=1)/np.sqrt(n)


tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики
z_crit = stats.norm().ppf(1 - alpha/2)  # крит значение статистики

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'{tobs1:.3} не попадает в ({-z_crit:.3} , {z_crit:.3}) => Нулевая гипотеза отвергается')
print('pval1', pval1)
203/44:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 8     # тест мат ожидание
n = before.size
mu = before.mean()
std = x.std(ddof=1)/np.sqrt(n)


tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики
z_crit = stats.norm().ppf(1 - alpha/2)  # крит значение статистики

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'{tobs1:.3} не попадает в ({-z_crit:.3} , {z_crit:.3}) => Нулевая гипотеза отвергается')
print('pval1', pval1)
203/45:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 8     # тест мат ожидание
n = before.size
mu = before.mean()
std = x.std(ddof=1)/np.sqrt(n)

tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики
z_crit = stats.norm().ppf(1 - alpha/2)  # крит значение статистики

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'{tobs1:.3} не попадает в ({-z_crit:.3} , {z_crit:.3}) => Нулевая гипотеза отвергается')
print('pval1', pval1)
203/46:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std = x.std(ddof=1)/np.sqrt(n)

tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики
z_crit = stats.norm().ppf(1 - alpha/2)  # крит значение статистики

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'{tobs1:.3} не попадает в ({-z_crit:.3} , {z_crit:.3}) => Нулевая гипотеза отвергается')
print('pval1', pval1)
203/47:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std =  np.sqrt(x.std(ddof=1)/n)

tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики
z_crit = stats.norm().ppf(1 - alpha/2)  # крит значение статистики

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'{tobs1:.3} не попадает в ({-z_crit:.3} , {z_crit:.3}) => Нулевая гипотеза отвергается')
print('pval1', pval1)
203/48:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std =  np.sqrt(x.std(ddof=1)/n)

tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики
z_crit = stats.norm().ppf(1 - alpha/2)  # крит значение статистики

pval1 = 2 * (1 - stats.norm().зза(np.abs(tobs1)))

print(f'{tobs1:.3} не попадает в ({-z_crit:.3} , {z_crit:.3}) => Нулевая гипотеза отвергается')
print('pval1', pval1)
203/49:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std =  np.sqrt(x.std(ddof=1)/n)
tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'Наблюдаемое значение статистики {tobs1:.3}')
print('pval1', pval1)
203/50:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std =  x.std(ddof=1)/np.sqrt(n)

tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'Наблюдаемое значение статистики {tobs1:.3}')
print('pval1', pval1)
203/51:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
print(mu)
std =  x.std(ddof=1)/np.sqrt(n)

tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'Наблюдаемое значение статистики {tobs1:.3}')
print('pval1', pval1)
203/52:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
print(mu/std)
std =  x.std(ddof=1)/np.sqrt(n)

tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'Наблюдаемое значение статистики {tobs1:.3}')
print('pval1', pval1)
203/53:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
print(mu/1.325710)
std =  x.std(ddof=1)/np.sqrt(n)

tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'Наблюдаемое значение статистики {tobs1:.3}')
print('pval1', pval1)
203/54:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
print(mu/1.325710)
std =  before.std(ddof=1)/np.sqrt(n)
print('std', std)
tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'Наблюдаемое значение статистики {tobs1:.3}')
print('pval1', pval1)
203/55:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std =  before.std(ddof=1)/np.sqrt(n)
tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'Наблюдаемое значение статистики {tobs1:.3}')
print('pval1', pval1)
203/56:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std =  before.std(ddof=1)/np.sqrt(n)
tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'Наблюдаемое значение статистики {tobs1:.6}')
print('pval1', pval1)
203/57:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std =  before.std(ddof=1)/np.sqrt(n)
tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'Наблюдаемое значение статистики {tobs1:.6}')
print('pval1 ', {pval1:.6})
203/58:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std =  before.std(ddof=1)/np.sqrt(n)
tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'Наблюдаемое значение статистики {tobs1:.6}')
print(а'pval1 {pval1:.6}')
203/59:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std =  before.std(ddof=1)/np.sqrt(n)
tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'Наблюдаемое значение статистики {tobs1:.6}')
print(f'pval1 {pval1:.6}')
203/60:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std =  before.std(ddof=1)/np.sqrt(n)

tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'Наблюдаемое значение {tobs1:.4} больше критического {t_crit:.4} => нулевая гипотеза отвергается')

print(f'Наблюдаемое значение статистики {tobs1:.6}')
print(f'pval1 {pval1:.6}')
203/61:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std =  before.std(ddof=1)/np.sqrt(n)

tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'Наблюдаемое значение {tobs1:.4} меньше критического {t_crit:.4} => нулевая гипотеза yt отвергается')
print(f'pval1 {pval1:.6}')
203/62:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std =  before.std(ddof=1)/np.sqrt(n)

tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'Наблюдаемое значение {tobs1:.4} меньше критического {t_crit:.4} => нулевая гипотеза  t отвергается')
print(f'pval1 {pval1:.6}')
203/63:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std =  before.std(ddof=1)/np.sqrt(n)

tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'Наблюдаемое значение {tobs1:.4} меньше критического {t_crit:.4} => нулевая гипотеза не отвергается')
print(f'pval1 {pval1:.6}')
203/64:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == mu_after до и после приема таблеток студенты спали одинаковое кол-во времени
# H_1: mu_before < mu_after  благодаря таблеткам студенты стали спать больше

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
mu_after = after.mean()
std =  after.std(ddof=1)/np.sqrt(n)

tobs2 = (mu - mu_after)/std   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

pval2 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'Наблюдаемое значение {tobs1:.4} меньше критического {t_crit:.4} => нулевая гипотеза не отвергается')
print(f'pval1 {pval1:.6}')
203/65:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_after - mu_before = 0 до и после приема таблеток студенты спали одинаковое кол-во времени
# H_1: mu_after - mu_before > 0 благодаря таблеткам студенты стали спать больше

d = mu_after - mu_before

alpha = 0.05
d_mean = d.mean()
d_std = d.std(ddof=1)


tobs2 = d.mean()/np.sqrt(d.var(ddof=1)/d.size)   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

pval2 =  2*(1-stats.t.cdf(np.abs(t_obs), d.size-1))

print(f'Наблюдаемое значение {tobs1:.4} меньше критического {t_crit:.4} => нулевая гипотеза не отвергается')
print(f'pval1 {pval1:.6}')
203/66:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_after - mu_before = 0 до и после приема таблеток студенты спали одинаковое кол-во времени
# H_1: mu_after - mu_before > 0 благодаря таблеткам студенты стали спать больше

d = after - before

alpha = 0.05
d_mean = d.mean()
d_std = d.std(ddof=1)


tobs2 = d.mean()/np.sqrt(d.var(ddof=1)/d.size)   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

pval2 =  2*(1-stats.t.cdf(np.abs(t_obs), d.size-1))

print(f'Наблюдаемое значение {tobs1:.4} меньше критического {t_crit:.4} => нулевая гипотеза не отвергается')
print(f'pval1 {pval1:.6}')
203/67:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_after - mu_before = 0 до и после приема таблеток студенты спали одинаковое кол-во времени
# H_1: mu_after - mu_before > 0 благодаря таблеткам студенты стали спать больше

d = after - before

alpha = 0.05
d_mean = d.mean()
d_std = d.std(ddof=1)


tobs2 = d.mean()/np.sqrt(d.var(ddof=1)/d.size)   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

pval2 =  2*(1-stats.t.cdf(np.abs(t_obs), d.size-1))

print(f'Наблюдаемое значение {tobs2:.4} меньше критического {t_crit:.4} => нулевая гипотеза не отвергается')
print(f'pval1 {pval1:.6}')
203/68:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_after - mu_before = 0 до и после приема таблеток студенты спали одинаковое кол-во времени
# H_1: mu_after - mu_before > 0 благодаря таблеткам студенты стали спать больше

d = after - before
print(d)
alpha = 0.05
d_mean = d.mean()
d_std = d.std(ddof=1)


tobs2 = d.mean()/np.sqrt(d.var(ddof=1)/d.size)   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

pval2 =  2*(1-stats.t.cdf(np.abs(t_obs), d.size-1))

print(f'Наблюдаемое значение {tobs2:.4} меньше критического {t_crit:.4} => нулевая гипотеза не отвергается')
print(f'pval1 {pval1:.6}')
203/69:
before = df[df['group'] == 1].extra
after = df[df['group'] == 2].extra
203/70: before
203/71: before - after
203/72: after
203/73: after.head()
203/74: before.head()
203/75: before['extra'] - after['extra']
203/76: before['extra']
203/77: before
203/78: before.iloc[:, 2]
203/79: before.iloc[:, 1]
203/80: before.iloc[:, 0]
203/81: diff = df[df['group'] == 1].extra - df[df['group'] == 2].extra
203/82: diff
203/83: diff = df[df['group'] == 1] - df[df['group'] == 2]
203/84: diff
203/85:
before = df[df['group'] == 1].extra
after = df[df['group'] == 2].extra
203/86: before
203/87: before + after
203/88: c = after - before.loc['Use']
203/89:
after.columns = ['extra']
after.head()
203/90:
after.columns = ['extra']
after.head()
203/91:
after.columns = ['extra']
after.head(10)
203/92:
after.columns = ['extra']
after.head(1, 10)
203/93:
after.columns = ['id','extra']
after.head(10)
203/94:
before = df.head(10)
before
203/95:
before = df.head(10)
after = df.tail(10)
before
203/96:
before = df.head(10)
after = df.tail(10)
after
203/97:
before = df.head(10)
after = df.tail(10)
diff = before.loc['extra'] - after.loc['extra']
diff
203/98:
before = df.head(10)
after = df.tail(10)
diff = before['extra'] - after['extra']
diff
203/99:
before = df.head(10)
after = df.tail(10)
diff = after.subtract(before, fill_value=None) 
diff
203/100:
before = df.head(10)
after = df.tail(10)
diff = after - before.loc['Use']
diff
203/101:
before = df.head(10)
after = df.tail(10)
frames = [after, before]
  
result = pd.concat(frames)
result
203/102:
before = df.head(10)
after = df.tail(10)
diff['extra'] = after['col1'] - before['col2']
203/103:
before = df.head(10)
after = df.tail(10)
diff['extra'] = after['extra'] - before['extra']
203/104: diff
203/105: diff.update(diff[['extra']].sub(df.extra, axis=0))
203/106: diff
203/107: diff.update(diff['extra'].sub(df.extra, axis=0))
203/108: diff.update(after['extra'].sub(before.extra, axis=0))
203/109: diff
203/110: after
203/111: after.extra
203/112: diff = after.sub(before.iloc[:,0],axis=0).dropna()
203/113: diff
203/114: diff = after.sub(before.iloc[:,0],axis=1).dropna()
203/115: diff
203/116: diff
203/117:
before = df.head(10)
after = df.tail(10)
diff['diff'] = df['extra'].after(before['extra'], fill_value=0)
203/118:
before = df.head(10)
after = df.tail(10)
diff['diff'] = after['extra'].after(before['extra'], fill_value=0)
203/119:
before = df.head(10)
after = df.tail(10)
df['diff'] = after['A'].sub(before['B'], fill_value=0)
203/120:
before = df.head(10)
after = df.tail(10)
df['diff'] = after['extra'].sub(before['extra'], fill_value=0)
203/121: df
203/122:
before = df.head(10)
after = df.tail(10)
data = after['extra'].sub(before['extra'], fill_value=0)
203/123: data
203/124:
df = pd.read_csv('./data/sleep.csv')
df
203/125: df[:10]
203/126: df[10:20]
203/127:
before = df[:10]
after = df[10:20]
data = after['extra'].sub(before['extra'], fill_value=0)
203/128: data
203/129: before
203/130: before.size
203/131: before.shape
203/132: data
203/133: before - after
203/134: before.extra - after.extra
203/135: before.extra.sub(after.extra)
203/136:
before = df[:10]
after = df[10:20]
data = after['extra'].sub(before['extra'], fill_value=0)
203/137: data
203/138: before
203/139: after
203/140:
before = df[:10]['extra']
after = df[10:20]['extra']
data = after['extra'].sub(before['extra'], fill_value=0)
203/141:
before['extra'] = df[:10]['extra']
after['extra'] = df[10:20]['extra']
data = after['extra'].sub(before['extra'], fill_value=0)
203/142: data
203/143:
data['before'] = df[:10]['extra']
data['after'] = df[10:20]['extra']
data
203/144:
data['before'] = df[:10]['extra']
data['after'] = df[10:20]['extra']
data.head()
203/145:
df = pd.read_csv('./data/sleep.csv')
df
203/146:
data['before'] = df[:10]['extra']
data['after'] = df[10:20]['extra']
data.head()
203/147:  df[:10]['extra']
203/148: data['rere'] =  df[:10]['extra']
203/149: data
203/150: data['rere'] =  df.head(10)['extra']
203/151: data
203/152: data['rere'] =  df.head(10)['extra'].astype('float')
203/153: data
203/154: df.head(10)['extra']
203/155: df.head(10)['extra'].astype('float')
203/156: df.head(10)['extra'].astype('int')
203/157: df.head(10)['extra'].astype('float')
203/158: df.head(10)['extra'].astype('float') - df.tail(10)['extra'].astype('float')
203/159: df.head(10)['extra'].astype('float').sub(df.tail(10)['extra'].astype('float'), axis='columns')
203/160: df.head(10)['extra'].astype('float').sub(df.tail(10)['extra'].astype('float'))
203/161: data = pd.dataframe()
203/162: data = pd.DataFrame()
203/163: data['before'] = df[:10]['extra']
203/164: data
203/165:
data['before'] = df[:10]['extra']
data['after'] = df[10:20]['extra']
203/166: data
203/167: data = pd.DataFrame()
203/168:
data['before'] = df[:10]['extra']
data['after'] = df[10:20]['extra']
203/169: data
203/170:
data['before'] = df[:10]['extra']
data['after'] = df[10:20]['extra']
df[10:20]['extra']
203/171:
data['before'] = df[:10]['extra']
data['after'] = df[10:20]['extra'].astype('float')
203/172: data
203/173: df[10:20]
203/174:
data['before'] = df[:10]['extra']
data['after'] = df[10:20]['extra']
203/175: df[10:20]
203/176: df[10:20]['extra']
203/177: df[10:20]['extra'].astype('int')
203/178: df[10:20]['extra'].astype('float')
203/179:
data['before'] = df[:10]['extra']
data['after'] = df[10:20]['extra']
203/180: data
203/181:
before['diff'] = df[:10]['extra']
after['diff'] = df[10:20]['extra']
203/182:
before['diff'] = pd.DataFrame(df[:10]['extra'], copy=False)
after['diff'] = pd.DataFrame(df[10:20]['extra'], copy=False)
203/183: after
203/184:
before = pd.DataFrame()
after =pd.DataFrame()
203/185:
before['diff'] = pd.DataFrame(df[:10]['extra'], copy=False)
after['diff'] = pd.DataFrame(df[10:20]['extra'], copy=False)
203/186:
before['diff'] = pd.DataFrame(df[:10]['extra'], copy=False)
after['diff'] = pd.DataFrame(df[10:19]['extra'], copy=False)
203/187:
before['diff'] = pd.DataFrame(df[:10]['extra'], copy=False)
after['diff'] = pd.DataFrame(df[10:]['extra'], copy=False)
203/188:
before['diff'] = pd.DataFrame(df[:10]['extra'], copy=False)
# after['diff'] = pd.DataFrame(df[10:]['extra'], copy=False)
203/189:
before['diff'] = df[:10]['extra']
# after['diff'] = pd.DataFrame(df[10:]['extra'], copy=False)
203/190:
before['diff'] = df[:10]['extra']
before['1212'] = pd.DataFrame(df[10:]['extra'], copy=False)
203/191: before
203/192:
before = pd.concat([df[:10]['extra'], df[10:]['extra']], axis=1, ignore_index=True)
before
203/193:
before['diff'] = df[:10]['extra']
before['1212'] = pd.DataFrame(df[10:]['extra'], copy=False,  ignore_index=True)
203/194:
before = pd.concat([df[:10]['extra'], df[10:]['extra']], axis=1).reset_index() 
before
203/195:
data['before'] = df[:10]['extra']
data['after'] = df[10:20]['extra'].reset_index() 
df[10:20]['extra']
203/196:
data['before'] = df[:10]['extra']
data['after'] = df[10:20]['extra'].reset_index() 
data
203/197:
data['before'] = df[:10]['extra']
data['after'] = 
df[10:20]['extra'].reset_index() 
data
203/198:
data['before'] = df[:10]['extra']
# data['after'] = 
df[10:20]['extra'].reset_index() 
data
203/199:
data['before'] = df[:10]['extra']
# data['after'] = 
data = df[10:20]['extra'].reset_index()
203/200:
before = pd.concat([df[:10]['extra'], df[10:]['extra']], axis=1).reset_index() 
data
203/201:
before = pd.concat([df[:10]['extra'], df[10:]['extra']], axis=1).reset_index() 
data.drop('index')
203/202:
before = pd.concat([df[:10]['extra'], df[10:]['extra']], axis=1).reset_index() 
data.drop('index', inplace=True, axis=1)
203/203: data
203/204:
data['before'] = df[:10]['extra']

data['after'] = df[10:20]['extra'].reset_index().drop('index', inplace=True, axis=1)
203/205: data
203/206:
data['before'] = df[:10]['extra']

data['extra'] = df[10:20]['extra'].reset_index().drop('index', inplace=True, axis=1)
203/207: data
203/208:
data['before'] = df[:10]['extra']

data['after'] = df[10:20]['extra'].reset_index().drop('index', inplace=True, axis=1)
203/209: data
203/210:
data['before'] = df[:10]['extra']

data['after'] = df[10:20]['extra'].reset_index().drop('index', inplace=True, axis=1)
203/211: data
203/212: data
203/213:
data['before'] = df[:10]['extra']
after = df[10:20]['extra'].reset_index().drop('index', inplace=True, axis=1)
data['after'] = after
203/214: data
203/215:
before = pd.concat([df[:10]['extra'], df[10:]['extra']], axis=1).reset_index() 
data.drop('index', inplace=True, axis=1)
203/216: data.drop('index', inplace=True, axis=1)
203/217:
data['before'] = df[:10]['extra']
after = df[10:20]['extra'].reset_index().drop('index', inplace=True, axis=1)
data['after'] = after
203/218: data
203/219: after
203/220: after
203/221:
data['before'] = df[:10]['extra']
after = df[10:20]['extra'].reset_index().drop('index', inplace=True, axis=1)
data['after'] = after
203/222: after
203/223: after.head()
203/224:
data['before'] = df[:10]['extra']

df[10:20]['extra'].reset_index().drop('index', inplace=True, axis=1)
data['after'] = after
203/225: after.head()
203/226: data['before'] = df[:10]['extra']
203/227: data
203/228: data['before'] = df[:10]['extra']
203/229: data
203/230: data
203/231: data = pd.DataFrame()
203/232: data
203/233: data['before'] = df[:10]['extra']
203/234: data
203/235:
after = = pd.DataFrame()
after = df[10:20]['extra'].reset_index().drop('index', inplace=True, axis=1)
after
203/236:
after = pd.DataFrame()
after = df[10:20]['extra'].reset_index().drop('index', inplace=True, axis=1)
after
203/237:
after = pd.DataFrame()
after = df[10:20]['extra'].reset_index()
after
203/238:
after = pd.DataFrame()
after = df[10:20]['extra'].reset_index().drop('index', axis =1)
after
203/239:
after = pd.DataFrame()
after = df[10:20]['extra'].reset_index().drop('index', axis =1)
after.columns = ['after']
203/240: after
203/241:
data['before'] = df[:10]['extra']
data['after'] = after
203/242: data
203/243: data.after - data.before
203/244:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_after - mu_before = 0 до и после приема таблеток студенты спали одинаковое кол-во времени
# H_1: mu_after - mu_before > 0 благодаря таблеткам студенты стали спать больше

d = data.after - data.before
print(d)
alpha = 0.05
d_mean = d.mean()
d_std = d.std(ddof=1)


tobs2 = d.mean()/np.sqrt(d.var(ddof=1)/d.size)   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

pval2 =  2*(1-stats.t.cdf(np.abs(t_obs), d.size-1))

print(f'Наблюдаемое значение {tobs2:.4} меньше критического {t_crit:.4} => нулевая гипотеза не отвергается')
print(f'pval1 {pval1:.6}')
203/245:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_after - mu_before = 0 до и после приема таблеток студенты спали одинаковое кол-во времени
# H_1: mu_after - mu_before > 0 благодаря таблеткам студенты стали спать больше

d = data.after - data.before
alpha = 0.05
d_mean = d.mean()
d_std = d.std(ddof=1)


tobs2 = d.mean()/np.sqrt(d.var(ddof=1)/d.size)   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

pval2 =  2*(1-stats.t.cdf(np.abs(t_obs), d.size-1))

print(f'Наблюдаемое значение {tobs2:.4} больше критического {t_crit:.4} => нулевая гипотеза отвергается')
print(f'pval1 {pval2:.6}')
203/246:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_after - mu_before = 0 до и после приема таблеток студенты спали одинаковое кол-во времени
# H_1: mu_after - mu_before > 0 благодаря таблеткам студенты стали спать больше

d = data.after - data.before
alpha = 0.05
d_mean = d.mean()
d_std = d.std(ddof=1)


tobs2 = d.mean()/np.sqrt(d.var(ddof=1)/d.size)   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

t_obs_check, pval2, _ = stats.ttest_rel(data.after, data.before, alternative='greater')

print(f'Наблюдаемое значение {tobs2:.4} больше критического {t_crit:.4} => нулевая гипотеза отвергается')
print(f'pval1 {pval2:.6}')
203/247:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_after - mu_before = 0 до и после приема таблеток студенты спали одинаковое кол-во времени
# H_1: mu_after - mu_before > 0 благодаря таблеткам студенты стали спать больше

d = data.after - data.before
alpha = 0.05
d_mean = d.mean()
d_std = d.std(ddof=1)


tobs2 = d.mean()/np.sqrt(d.var(ddof=1)/d.size)   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

t_obs_check, pval2 = stats.ttest_rel(data.after, data.before, alternative='greater')

print(f'Наблюдаемое значение {tobs2:.4} больше критического {t_crit:.4} => нулевая гипотеза отвергается')
print(f'pval1 {pval2:.6}')
203/248:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_after - mu_before = 0 до и после приема таблеток студенты спали одинаковое кол-во времени
# H_1: mu_after - mu_before > 0 благодаря таблеткам студенты стали спать больше

d = data.after - data.before
alpha = 0.05
d_mean = d.mean()
d_std = d.std(ddof=1)


tobs2 = d.mean()/np.sqrt(d.var(ddof=1)/d.size)   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

t_obs_check, pval2 = stats.ttest_rel(data.after, data.before, alternative='greater')

print(f'Наблюдаемое значение {tobs2:.4} больше критического {t_crit:.4} => нулевая гипотеза отвергается')
print(f'pval1 {pval2:.6}') 
print(f't_obs_check {t_obs_check}')
203/249:
# проверка того, что задание решено верно
assert np.abs(tobs1 - 1.325710) < 1e-5
assert np.abs(tobs2 - 4.062127) < 1e-5
203/250:
df = pd.read_csv('./data/cats_names.csv', sep='\t')
df.head()
203/251:
df = pd.read_csv('./data/matan.csv', sep='\t')
df.head()
203/252:
killer1 = pd.read_csv("./data/killer_time1.csv").hours_between_kill.values
killer2 = pd.read_csv("./data/killer_time2.csv").hours_between_kill.values
203/253: plt.hist(killer1, bins=20);
203/254: plt.hist(killer2, bins=20);
203/255:
df = pd.read_csv('./data/london_07-09-1940.tsv', sep='\t')
print(df.shape)
df.head()
203/256:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
203/257:
df = pd.read_csv('./data/cats_names.csv', sep='\t')
df.head(17)
203/258:
df = pd.read_csv('./data/cats_names.csv', sep='\t')
df.head(20)
203/259:
df = pd.read_csv('./data/cats_names.csv', sep='\t')
df.head(8)
203/260: df.columns
203/261:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

col_list = ['Ear moving', 'Head moving', 'Tail moving', 'Vocalising', 'Displacement']

# noun4 = df
name = df.loc[(df['stimuli'] == 'Noun 4') & (df[col_list] == 1).any(axis=1)]



# z_obs = ...
# pval = ...
203/262: name
203/263:
df = pd.read_csv('./data/cats_names.csv', sep='\t')
df.head(100)
203/264:
df = pd.read_csv('./data/cats_names.csv', sep='\t')
df.head(30)
203/265: name.shaoe
203/266: name.shape()
203/267: name.shape
203/268:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

col_list = ['Ear moving', 'Head moving', 'Tail moving', 'Vocalising', 'Displacement']

for ind in df.index:
     print(df['Name'][ind], df['Stream'][ind])

noun4 = df.loc[(df['stimuli'] == 'Noun 4') & (df[col_list] == 1).any(axis=1)]
# name = 



# z_obs = ...
# pval = ...
203/269:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

col_list = ['Ear moving', 'Head moving', 'Tail moving', 'Vocalising', 'Displacement']

noun4 = pd.DataFrame()
name = pd.DataFrame()
for ind in df.index:
     if (df['stimuli'][ind] == 'Noun 4') & (df[col_list][ind] == 1).any(axis=1):
            noun4.append(1)
    else: 
        noun4.append(0)

noun4
# name = 



# z_obs = ...
# pval = ...
203/271:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

col_list = ['Ear moving', 'Head moving', 'Tail moving', 'Vocalising', 'Displacement']

noun4 = pd.DataFrame()
name = pd.DataFrame()
for ind in df.index:
     if (df['stimuli'][ind] == 'Noun 4') & (df[col_list][ind] == 1).any(axis=1):
            noun4.append(1)
    else:
        noun4.append(0)

noun4
# name = 



# z_obs = ...
# pval = ...
203/273:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

col_list = ['Ear moving', 'Head moving', 'Tail moving', 'Vocalising', 'Displacement']

noun4 = pd.DataFrame()
name = pd.DataFrame()
for ind in df.index:
         if (df['stimuli'][ind] == 'Noun 4') & (df[col_list][ind] == 1).any(axis=1):
            noun4.append(1)
        else:
            noun4.append(0)

noun4
# name = 



# z_obs = ...
# pval = ...
203/275:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

col_list = ['Ear moving', 'Head moving', 'Tail moving', 'Vocalising', 'Displacement']

noun4 = pd.DataFrame()
name = pd.DataFrame()
for ind in df.index:
        if (df['stimuli'][ind] == 'Noun 4') & (df[col_list][ind] == 1).any(axis=1):
            noun4.append(1)
        else:
            noun4.append(0)

noun4
# name = 



# z_obs = ...
# pval = ...
203/276:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

col_list = ['Ear moving', 'Head moving', 'Tail moving', 'Vocalising', 'Displacement']

noun4 = pd.DataFrame()
name = pd.DataFrame()
for ind in df.index:
        if (df[ind]['stimuli'] == 'Noun 4') & (df[ind][col_list] == 1).any(axis=1):
            noun4.append(1)
        else:
            noun4.append(0)

noun4
# name = 



# z_obs = ...
# pval = ...
203/277:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

col_list = ['Ear moving', 'Head moving', 'Tail moving', 'Vocalising', 'Displacement']

noun4 = pd.DataFrame()
name = pd.DataFrame()
for ind in df.index:
        if (df[ind]['stimuli'] == 'Noun 4') & (df[ind][col_list] == 1).any(axis=1):
            noun4.append(1)
        else:
            noun4.append(0)

noun4
# name = 



# z_obs = ...
# pval = ...
203/278:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

col_list = ['Ear moving', 'Head moving', 'Tail moving', 'Vocalising', 'Displacement']

noun4 = pd.DataFrame()
name = pd.DataFrame()
for ind in df.index:
    print('df[ind]', df[ind])
    if (df[ind]['stimuli'] == 'Noun 4') & (df[ind][col_list] == 1).any(axis=1):
        noun4.append(1)
    else:
        noun4.append(0)

noun4
# name = 



# z_obs = ...
# pval = ...
203/279:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

col_list = ['Ear moving', 'Head moving', 'Tail moving', 'Vocalising', 'Displacement']

noun4 = df.loc[(df['stimuli'] == 'Noun 4') & (df[col_list] == 1).any(axis=1)]
# name = 



# z_obs = ...
# pval = ...
203/280:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

col_list = ['Ear moving', 'Head moving', 'Tail moving', 'Vocalising', 'Displacement']

noun4 = df.loc[(df['stimuli'] == 'Noun 4') & (df[col_list] == 1).any(axis=1)]
# name = 



# z_obs = ...
# pval = ...
noun4
203/281:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

col_list = ['Ear moving', 'Head moving', 'Tail moving', 'Vocalising', 'Displacement']
all_noun4 = df.loc[df['stimuli'] == 'Noun 4']

noun4 = df.loc[(df[col_list] == 1).any(axis=1)]
# name = 



# z_obs = ...
# pval = ...
all_noun4
203/282:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

col_list = ['Ear moving', 'Head moving', 'Tail moving', 'Vocalising', 'Displacement']
all_noun4 = df.loc[df['stimuli'] == 'Noun 4']

noun4 = df.loc[(df[col_list] == 1).any(axis=1)]
all_noun4.loc[all_noun4.loc[(df[col_list] != 1).any(axis=1)], 'val'] = 0  
all_noun4.loc[all_noun4.loc[(df[col_list] == 1).any(axis=1)], 'val'] = 1 
# name = 



# z_obs = ...
# pval = ...
all_noun4
203/283:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

col_list = ['Ear moving', 'Head moving', 'Tail moving', 'Vocalising', 'Displacement']
all_noun4 = df.loc[df['stimuli'] == 'Noun 4']

all_noun4.loc[all_noun4.loc[(df[col_list] != 1).any(axis=1)], 'val'] = 0  
all_noun4.loc[all_noun4.loc[(df[col_list] == 1).any(axis=1)], 'val'] = 1 
# name = 



# z_obs = ...
# pval = ...
all_noun4
203/284:
df = pd.read_csv('./data/cats_names.csv', sep='\t')
df.head(30)
203/285:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

col_list = ['Ear moving', 'Head moving', 'Tail moving', 'Vocalising', 'Displacement']
all_noun4 = df.loc[df['stimuli'] == 'Noun 4']

all_noun4.loc[all_noun4.loc[(all_noun4[col_list] != 1).any(axis=1)], 'val'] = 0  
all_noun4.loc[all_noun4.loc[(all_noun4[col_list] == 1).any(axis=1)], 'val'] = 1 
# name = 



# z_obs = ...
# pval = ...
all_noun4
203/286:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

col_list = ['Ear moving', 'Head moving', 'Tail moving', 'Vocalising', 'Displacement']
all_noun4 = df.loc[df['stimuli'] == 'Noun 4']
all_noun4
# all_noun4.loc[all_noun4.loc[(all_noun4[col_list] != 1).any(axis=1)], 'val'] = 0  
# all_noun4.loc[all_noun4.loc[(all_noun4[col_list] == 1).any(axis=1)], 'val'] = 1 
# name = 



# z_obs = ...
# pval = ...
all_noun4
203/287:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

col_list = ['Ear moving', 'Head moving', 'Tail moving', 'Vocalising', 'Displacement']
all_noun4 = df.loc[df['stimuli'] == 'Noun 4']
noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
# all_noun4.loc[all_noun4.loc[(all_noun4[col_list] != 1).any(axis=1)], 'val'] = 0  
# all_noun4.loc[all_noun4.loc[(all_noun4[col_list] == 1).any(axis=1)], 'val'] = 1 
# name = 



# z_obs = ...
# pval = ...
noun4
203/288:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

col_list = ['Ear moving', 'Head moving', 'Tail moving', 'Vocalising', 'Displacement']
all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
# all_noun4.loc[all_noun4.loc[(all_noun4[col_list] != 1).any(axis=1)], 'val'] = 0  
# all_noun4.loc[all_noun4.loc[(all_noun4[col_list] == 1).any(axis=1)], 'val'] = 1 
# name = 



# z_obs = ...
# pval = ...
noun4
203/289:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)



# z_obs = ...
# pval = ...
noun4
203/290:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)



# z_obs = ...
# pval = ...
all_names
203/291:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)



# z_obs = ...
# pval = ...
name
203/292:
# проверка того, что задание решено верно
assert sum(name) == 14
assert np.abs(z_obs - 1.7888543819998317) < 1e-5
203/293:
# проверка того, что задание решено верно
assert sum(name) == 14
assert np.abs(z_obs - 1.7888543819998317) < 1e-5
203/294:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size



# z_obs = ...
# pval = ...
print('name', name)
print('noun4', noun4)
203/295:
# проверка того, что задание решено верно
assert sum(name) == 14
assert np.abs(z_obs - 1.7888543819998317) < 1e-5
203/296:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size

b



# z_obs = ...
# pval = ...
assert sum(name) == 14
203/297:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size

# b



# z_obs = ...
# pval = ...
assert sum(name) == 14
203/298:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size

# b



# z_obs = ...
# pval = ...
sum(name)
203/299:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = noun4.values[0]
noun4_1 = noun4.values[1]

print('noun4_0', noun4_0)

# z_obs = ...
# pval = ...
203/300:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = noun4.values[0]
noun4_1 = noun4.values[1]

print('noun4_0', noun4_0)
print('noun4_1', noun4_1)

# z_obs = ...
# pval = ...
203/301:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = len(noun4 == 0)
noun4_1 = noun4.values[1]

print('noun4_0', noun4_0)
print('noun4_1', noun4_1)

# z_obs = ...
# pval = ...
203/302:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = len(noun4 == 0)
noun4_1 = len(noun4 == 1)

print('noun4_0', noun4_0)
print('noun4_1', noun4_1)

# z_obs = ...
# pval = ...
203/303:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = len(noun4 == 0)
noun4_1 = len(noun4 == 1)

print('noun4_0', noun4_0)
print('noun4_1', noun4_1)
print('noun4', noun4)

# z_obs = ...
# pval = ...
203/304:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = len(noun4 == 0)
noun4_1 = len(noun4 == 1)

print('noun4_0', noun4_0)
print('noun4_1', noun4_1)
print(noun4)

# z_obs = ...
# pval = ...
203/305:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = len(noun4.values(0))
noun4_1 = len(noun4 == 1)

print('noun4_0', noun4_0)
print('noun4_1', noun4_1)
print(noun4)

# z_obs = ...
# pval = ...
203/306:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = noun4.values(0).size
noun4_1 = len(noun4 == 1)

print('noun4_0', noun4_0)
print('noun4_1', noun4_1)
print(noun4)

# z_obs = ...
# pval = ...
203/307:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = noun4.values(0).shape()
noun4_1 = len(noun4 == 1)

print('noun4_0', noun4_0)
print('noun4_1', noun4_1)
print(noun4)

# z_obs = ...
# pval = ...
203/308:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).astype(int).sum(axis=1)
noun4_1 = len(noun4 == 1)

print('noun4_0', noun4_0)
print('noun4_1', noun4_1)
print(noun4)

# z_obs = ...
# pval = ...
203/309:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).astype(int).sum(axis=0)
noun4_1 = len(noun4 == 1)

print('noun4_0', noun4_0)
print('noun4_1', noun4_1)
print(noun4)

# z_obs = ...
# pval = ...
203/310:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = len(noun4 == 1)

print('noun4_0', noun4_0)
print('noun4_1', noun4_1)
print(noun4)

# z_obs = ...
# pval = ...
203/311:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)

print('noun4_0', noun4_0)
print('noun4_1', noun4_1)
print(noun4)

# z_obs = ...
# pval = ...
203/312:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)

print('noun4_0', noun4_0)
print('noun4_1', noun4_1)
print(noun4.shape())

# z_obs = ...
# pval = ...
203/313:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)

print('noun4_0', noun4_0)
print('noun4_1', noun4_1)
print(noun4.size())

# z_obs = ...
# pval = ...
203/314:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)

print('noun4_0', noun4_0)
print('noun4_1', noun4_1)
print(noun4)

# z_obs = ...
# pval = ...
203/315:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)

name_0 = (name == 0).sum(axis=0)
name_1 = (name == 0).sum(axis=0)

# z_obs = ...
# pval = ...
203/316:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)

name_0 = (name == 0).sum(axis=0)
name_1 = (name == 0).sum(axis=0)
name_1
# z_obs = ...
# pval = ...
203/317:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)

name_0 = (name == 0).sum(axis=0)
name_1 = (name == 1).sum(axis=0)
name_1
# z_obs = ...
# pval = ...
203/318:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)
print(noun4_0, noun4_1)

name_0 = (name == 0).sum(axis=0)
name_1 = (name == 1).sum(axis=0)
print(name_0, name_0)



# z_obs = ...
# pval = ...
203/319:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)
print(noun4_0, noun4_1)

name_0 = (name == 0).sum(axis=0)
name_1 = (name == 1).sum(axis=0)
print(name_0, name_1)



# z_obs = ...
# pval = ...
203/320:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)
print(noun4_0, noun4_1)

name_0 = (name == 0).sum(axis=0)
name_1 = (name == 1).sum(axis=0)
print(name_0, name_1)

print(name)
print(noun)

b = 4
c = 4


# z_obs = ...
# pval = ...
203/321:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)
print(noun4_0, noun4_1)

name_0 = (name == 0).sum(axis=0)
name_1 = (name == 1).sum(axis=0)
print(name_0, name_1)

print(name, noun4)
print()

b = 4
c = 4


# z_obs = ...
# pval = ...
203/322:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)
print(noun4_0, noun4_1)

name_0 = (name == 0).sum(axis=0)
name_1 = (name == 1).sum(axis=0)
print(name_0, name_1)

print(name)
print(noun4)

b = 4
c = 4


# z_obs = ...
# pval = ...
203/323:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)
print(noun4_0, noun4_1)

name_0 = (name == 0).sum(axis=0)
name_1 = (name == 1).sum(axis=0)
print(name_0, name_1)

a = 1
b = 1
c = 5
d = 9

z_obs = (c - b)/np.sqrt((c+b) - (c-b)**2/b)
z_crit = stats.norm().ppf(1 - alpha/2)
p_value = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))
print(f'Наблюдаемое значение {tobs2:.4} больше критического {z_crit:.4} => нулевая гипотеза отвергается')
print('p_value {p_value}')
203/324:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)
print(noun4_0, noun4_1)

name_0 = (name == 0).sum(axis=0)
name_1 = (name == 1).sum(axis=0)
print(name_0, name_1)

a = 1
b = 1
c = 5
d = 9

z_obs = (c - b)/np.sqrt((c+b) - (c-b)**2/n)
z_crit = stats.norm().ppf(1 - alpha/2)
p_value = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))
print(f'Наблюдаемое значение {tobs2:.4} больше критического {z_crit:.4} => нулевая гипотеза отвергается')
print('p_value {p_value}')
203/325:
# проверка того, что задание решено верно
assert sum(name) == 14
assert np.abs(z_obs - 1.7888543819998317) < 1e-5
203/326:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)
print(noun4_0, noun4_1)

name_0 = (name == 0).sum(axis=0)
name_1 = (name == 1).sum(axis=0)
print(name_0, name_1)

a = 1
b = 1
c = 5
d = 9

z_obs = (c - b)/np.sqrt((c+b) - (c-b)**2/n)
z_crit = stats.norm().ppf(1 - alpha/2)
p_value = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))
print(f'Наблюдаемое значение {z_obs:.4} больше критического {z_crit:.4} => нулевая гипотеза отвергается')
print('p_value {p_value}')
203/327:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)
print(noun4_0, noun4_1)

name_0 = (name == 0).sum(axis=0)
name_1 = (name == 1).sum(axis=0)
print(name_0, name_1)

a = 1
b = 1
c = 5
d = 9

z_obs = (c - b)/np.sqrt((c+b) - (c-b)**2/n)
z_crit = stats.norm().ppf(1 - alpha/2)
p_value = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))
print(f'Наблюдаемое значение {z_obs:.6} больше критического {z_crit:.4} => нулевая гипотеза отвергается')
print('p_value {p_value}')
203/328:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)
print(noun4_0, noun4_1)

name_0 = (name == 0).sum(axis=0)
name_1 = (name == 1).sum(axis=0)
print(name_0, name_1)

a = 1
b = 1
c = 5
d = 9

z_obs = (c - b)/np.sqrt((c+b) - (c-b)**2/n)
z_crit = stats.norm().ppf(1 - alpha/2)
p_value = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))
print(f'Наблюдаемое значение {z_obs:.6} меньще критического {z_crit:.4} => нулевая гипотеза не отвергается')
print('p_value {p_value}')
203/329:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 доли не совпадают

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)
print(noun4_0, noun4_1)

name_0 = (name == 0).sum(axis=0)
name_1 = (name == 1).sum(axis=0)
print(name_0, name_1)

a = 1
b = 1
c = 5
d = 9

z_obs = (c - b)/np.sqrt((c+b) - (c-b)**2/n)
z_crit = stats.norm().ppf(1 - alpha/2)
p_value = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))
print(f'Наблюдаемое значение {z_obs:.6} меньще критического {z_crit:.4} => нулевая гипотеза не отвергается')
print(f'p_value {p_value}')
203/330:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

is_angry = df[df['is_angry'] == 1]['target_1']
is_kind = df[df['is_angry'] == 0]['target_1']


pval = ... 
z_obs = ...
203/331:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

angry = df[df['is_angry'] == 1]['target_1']
kind = df[df['is_angry'] == 0]['target_1']


pval = ... 
z_obs = ...
203/332:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

angry = df.loc[df['is_angry'] == 1]['target_1']
kind = df.loc[df['is_angry'] == 0]['target_1']


pval = ... 
z_obs = ...
203/333:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

angry = df[df['is_angry'] == '1']['target_1']
kind = df[df['is_angry'] == '0']['target_1']


pval = ... 
z_obs = ...
203/334: df.is_angry
203/335:
df = pd.read_csv('./data/matan.csv', sep='\t')
df.head()
203/336: df.is_angry
203/337:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

angry = df[df['is_angry'] == '1']['target_1']
kind = df[df['is_angry'] == '0']['target_1']


pval = ... 
z_obs = ...
203/338: angry
203/339: angry.shape
203/340:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

angry = df[df['is_angry'] == '1']size['target_1']
kind = df[df['is_angry'] == '0']['target_1']


pval = ... 
z_obs = ...
203/341: angry.size
203/342: kind.size
203/343:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

angry = df[df['is_angry'] == 1]['target_1']
kind = df[df['is_angry'] == 0]['target_1']


pval = ... 
z_obs = ...
203/344: kind.size
203/345: angry.size
203/346:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

angry = df[df['is_angry'] == 1]['target_1']
kind = df[df['is_angry'] == 0]['target_1']

# H_0: p_angry = p_kind доля отчислений
# H_1: p_angry != p_kind есть различия

alpha = 0.05                                      
n1,n2 = angry.size, kind.size                     
m1,m2 = angry.sum(), kind.sum()                 

p1, p2 = angry.mean(), kind.mean()                 # точеные оценки долей 
diff = p1 - p2                                     # разность долей

P = (m1 + m2)/(n1 + n2)          
diff_std = np.sqrt(P*(1 - P)*(1/n1 + 1/n2))        # стандартное отклонение разности
                                    
z_obs = diff/diff_std                              # наблюдаемое значение статистики 
z_crit = stats.norm.ppf(1 - alpha/2)               # критическое значение статистики

pval =  = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))


print(f'{z_obs:.3} не попадает в ({-z_crit:.6} , {z_crit:.6}) => Нулевая гипотеза отвергается')
203/347:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

angry = df[df['is_angry'] == 1]['target_1']
kind = df[df['is_angry'] == 0]['target_1']

# H_0: p_angry = p_kind доля отчислений
# H_1: p_angry != p_kind есть различия

alpha = 0.05                                      
n1,n2 = angry.size, kind.size                     
m1,m2 = angry.sum(), kind.sum()                 

p1, p2 = angry.mean(), kind.mean()                 # точеные оценки долей 
diff = p1 - p2                                     # разность долей

P = (m1 + m2)/(n1 + n2)          
diff_std = np.sqrt(P*(1 - P)*(1/n1 + 1/n2))        # стандартное отклонение разности
                                    
z_obs = diff/diff_std                              # наблюдаемое значение статистики 
z_crit = stats.norm.ppf(1 - alpha/2)               # критическое значение статистики

pval = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))


print(f'{z_obs:.3} не попадает в ({-z_crit:.6} , {z_crit:.6}) => Нулевая гипотеза отвергается')
203/348:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

angry = df[df['is_angry'] == 1]['target_1']
kind = df[df['is_angry'] == 0]['target_1']

# H_0: p_angry = p_kind доля отчислений
# H_1: p_angry != p_kind есть различия

alpha = 0.05                                      
n1,n2 = angry.size, kind.size                     
m1,m2 = angry.sum(), kind.sum()                 

p1, p2 = angry.mean(), kind.mean()                 # точеные оценки долей 
diff = p1 - p2                                     # разность долей

P = (m1 + m2)/(n1 + n2)          
diff_std = np.sqrt(P*(1 - P)*(1/n1 + 1/n2))        # стандартное отклонение разности
                                    
z_obs = diff/diff_std                              # наблюдаемое значение статистики 
z_crit = stats.norm.ppf(1 - alpha/2)               # критическое значение статистики

pval = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))


print(f'{z_obs:.6} не попадает в ({-z_crit:.6} , {z_crit:.6}) => Нулевая гипотеза отвергается')
203/349:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

angry = df[df['is_angry'] == 1]['target_1']
kind = df[df['is_angry'] == 0]['target_1']

# H_0: p_angry = p_kind доля отчислений
# H_1: p_angry != p_kind есть различия

alpha = 0.01                                    
n1,n2 = angry.size, kind.size                     
m1,m2 = angry.sum(), kind.sum()                 

p1, p2 = angry.mean(), kind.mean()                 # точеные оценки долей 
diff = p1 - p2                                     # разность долей

P = (m1 + m2)/(n1 + n2)          
diff_std = np.sqrt(P*(1 - P)*(1/n1 + 1/n2))        # стандартное отклонение разности
                                    
z_obs = diff/diff_std                              # наблюдаемое значение статистики 
z_crit = stats.norm.ppf(1 - alpha/2)               # критическое значение статистики

pval = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))

print(f'{z_obs:.6} не попадает в ({-z_crit:.6} , {z_crit:.6}) => Нулевая гипотеза отвергается')
203/350:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

angry = df[df['is_angry'] == 1]['target_1']
kind = df[df['is_angry'] == 0]['target_1']

# H_0: p_angry = p_kind доля отчислений для доброго и злого преподавателей равна
# H_1: p_angry != p_kind есть различия

alpha = 0.01                                    
n1,n2 = angry.size, kind.size                     
m1,m2 = angry.sum(), kind.sum()                 

p1, p2 = angry.mean(), kind.mean()                 # точеные оценки долей 
diff = p1 - p2                                     # разность долей

P = (m1 + m2)/(n1 + n2)          
diff_std = np.sqrt(P*(1 - P)*(1/n1 + 1/n2))        # стандартное отклонение разности
                                    
z_obs = diff/diff_std                              # наблюдаемое значение статистики 
z_crit = stats.norm.ppf(1 - alpha/2)               # критическое значение статистики

pval = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))

print(f'{z_obs:.6} попадает в ({-z_crit:.6} , {z_crit:.6}) => Нулевая гипотеза не отвергается')
203/351: n1,n2 = angry.size, kind.size
203/352: angry
203/353: df[df['is_angry'] == 1]['target_1']
203/354: angry
203/355: angry.dropana()
203/356: angry.drop_na()
203/357: angry.dropna()
203/358:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

angry = df[df['is_angry'] == 1]['target_1'].dropna()
kind = df[df['is_angry'] == 0]['target_1'].dropna()

# H_0: p_angry = p_kind доля отчислений для доброго и злого преподавателей равна
# H_1: p_angry != p_kind есть различия

alpha = 0.01                                    
n1,n2 = angry.size, kind.size                     
m1,m2 = angry.sum(), kind.sum()                 

p1, p2 = angry.mean(), kind.mean()                 # точеные оценки долей 
diff = p1 - p2                                     # разность долей

P = (m1 + m2)/(n1 + n2)          
diff_std = np.sqrt(P*(1 - P)*(1/n1 + 1/n2))        # стандартное отклонение разности
                                    
z_obs = diff/diff_std                              # наблюдаемое значение статистики 
z_crit = stats.norm.ppf(1 - alpha/2)               # критическое значение статистики

pval = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))

print(f'{z_obs:.6} попадает в ({-z_crit:.6} , {z_crit:.6}) => Нулевая гипотеза не отвергается')
203/359:
# проверка того, что задание решено верно
assert np.abs(np.abs(z_obs) - 0.29897)  < 1e-5
203/360:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mux = muy бутерброд падает маслом вниз так же часто, как и маслом вверх 
# H_1: mux = muy маслом вниз чаще

n = 200
m = 105


alpha = 0.05                                    
nx, ny = m, n-m

diff = nx/n - ny/n                                # разность средних
diff_std = np.sqrt(women.var(ddof=0)/nx + men.var(ddof=0)/ny)   # стандартное отклонение

z_obs = diff/diff_std                                           # наблюдаемое значение
z_crit = stats.norm.ppf(1 - alpha)                              # критическое значение

# pval = ... 

print(f'Наблюдаемое значение {z_obs:.5} меньше критического {z_crit:.3} => нулевая гипотеза не отвергается')
203/361:
down = pd.DataFrame(0, 200)
down
203/362:
down = np.zeros(shape=200)
down
203/363:
down = np.zeros(shape=200)
down.apply(lamda x: x)
203/364: down = np.zeros(shape=200)
203/365:
down = np.zeros(shape=200)
down
203/366:
down = np.zeros(shape=200)
for idx in enumerate(down):
    if idx < 105:
        down[idx] = 1
doen
203/367:
down = np.zeros(shape=200)
for idx in enumerate(down):
    if idx < 105:
        down[idx] = 1
down
203/368:
down = np.zeros(shape=200)
for idx, j in enumerate(down):
    if idx < 105:
        down[idx] = 1
down
203/369:
down = np.zeros(shape=200)
for idx, j in enumerate(down):
    if idx < 105:
        down[idx] = 1
down = pd.DataFrame(down)
down
203/370:
down = np.zeros(shape=200)
for idx, j in enumerate(down):
    if idx < 105:
        down[idx] = 1
down = pd.DataFrame(down)


up = np.zeros(shape=200)
for idx, j in enumerate(down):
    if idx < 95:
        up[idx] = 1
up = pd.DataFrame(up)
203/371: nx/n
203/372:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mux = muy бутерброд падает маслом вниз так же часто, как и маслом вверх 
# H_1: mux > muy маслом вниз чаще

n = 200
m = 105

down = pd.DataFrame(0, 200)


alpha = 0.05                                    
nx, ny = m, n-m

diff = nx/n - ny/n
diff_std = np.sqrt((1/2*1/2)/nx + (1/2*1/2)/ny)   # стандартное отклонение

z_obs = diff/diff_std                                           # наблюдаемое значение
z_crit = stats.norm.ppf(1 - alpha)                              # критическое значение

# pval = ... 

print(f'Наблюдаемое значение {z_obs:.5} меньше критического {z_crit:.3} => нулевая гипотеза не отвергается')
203/373:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mux = muy бутерброд падает маслом вниз так же часто, как и маслом вверх 
# H_1: mux > muy маслом вниз чаще

n = 200
m = 105


alpha = 0.05                                    
nx, ny = m, n-m

diff = nx/n - ny/n
diff_std = np.sqrt((1/2*1/2)/nx + (1/2*1/2)/ny)   # стандартное отклонение

z_obs = diff/diff_std                                           # наблюдаемое значение
z_crit = stats.norm.ppf(1 - alpha)                              # критическое значение

# pval = ... 

print(f'Наблюдаемое значение {z_obs:.5} меньше критического {z_crit:.3} => нулевая гипотеза не отвергается')
203/374:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mux = muy бутерброд падает маслом вниз так же часто, как и маслом вверх 
# H_1: mux > muy маслом вниз чаще

n = 200
m = 105


alpha = 0.05                                    
nx, ny = m, n-m

diff = nx/n - ny/n
diff_std = np.sqrt((0.475*0.525)/nx + (0.475*0.525)/ny)   # стандартное отклонение

z_obs = diff/diff_std                                           # наблюдаемое значение
z_crit = stats.norm.ppf(1 - alpha)                              # критическое значение

# pval = ... 

print(f'Наблюдаемое значение {z_obs:.5} меньше критического {z_crit:.3} => нулевая гипотеза не отвергается')
203/375:
# проверка того, что задание решено верно
assert np.abs(z_obs - 0.70799) < 1e-5
203/376:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mux = muy бутерброд падает маслом вниз так же часто, как и маслом вверх 
# H_1: mux > muy маслом вниз чаще

n = 200
m = 105


alpha = 0.05                                    
nx, ny = m, n-m

diff = nx/n - ny/n
diff_std = np.sqrt((0.475*0.525)/nx + (0.475*0.525)/ny)   # стандартное отклонение

z_obs = diff/diff_std                                           # наблюдаемое значение
z_crit = stats.norm.ppf(1 - alpha)                              # критическое значение

# pval = ... 

print(f'Наблюдаемое значение {z_obs:.5} меньше критического {z_crit:.3} => нулевая гипотеза не отвергается')
203/377:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mux = muy бутерброд падает маслом вниз так же часто, как и маслом вверх 
# H_1: mux > muy маслом вниз чаще

n = 200
m = 105


alpha = 0.05                                    
nx, ny = m, n-m

diff = nx/n - ny/n
diff_std = np.sqrt((0.475*0.525)/nx + (0.475*0.525)/ny)   # стандартное отклонение

z_obs = diff/diff_std                                           # наблюдаемое значение
z_crit = stats.norm.ppf(1 - alpha)                              # критическое значение

# pval = ... 

print(f'Наблюдаемое значение {z_obs:.3} меньше критического {z_crit:.3} => нулевая гипотеза не отвергается')
203/378:
# проверка того, что задание решено верно
assert np.abs(z_obs - 0.70799) < 1e-5
203/379:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mux = muy бутерброд падает маслом вниз так же часто, как и маслом вверх 
# H_1: mux > muy маслом вниз чаще

n = 200
m = 105


alpha = 0.05                                    
nx, ny = m, n-m

diff = nx/n - ny/n
diff_std = np.sqrt((0.475*0.525)/nx**2 + (0.475*0.525)/ny**2)   # стандартное отклонение

z_obs = diff/diff_std                                           # наблюдаемое значение
z_crit = stats.norm.ppf(1 - alpha)                              # критическое значение

# pval = ... 

print(f'Наблюдаемое значение {z_obs:.3} меньше критического {z_crit:.3} => нулевая гипотеза не отвергается')
203/380:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mux = muy бутерброд падает маслом вниз так же часто, как и маслом вверх 
# H_1: mux > muy маслом вниз чаще

n = 200
m = 105


alpha = 0.05                                    
nx, ny = m, n-m

diff = nx/n - ny/n
diff_std = np.sqrt((0.475*0.525)/nx**2 + (0.475*0.525)/ny**2)   # стандартное отклонение

z_obs = diff/diff_std                                           # наблюдаемое значение
z_crit = stats.norm.ppf(1 - alpha)                              # критическое значение

# pval = ... 

print(f'Наблюдаемое значение {z_obs:.6} меньше критического {z_crit:.3} => нулевая гипотеза не отвергается')
203/381:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mux = muy бутерброд падает маслом вниз так же часто, как и маслом вверх 
# H_1: mux > muy маслом вниз чаще

n = 200
m = 105


alpha = 0.05                                    
nx, ny = m, n-m

diff = nx/n - ny/n
diff_std = np.sqrt((0.5*0.5)/nx**2 + (0.5*0.5)/ny**2)   # стандартное отклонение

z_obs = diff/diff_std                                           # наблюдаемое значение
z_crit = stats.norm.ppf(1 - alpha)                              # критическое значение

# pval = ... 

print(f'Наблюдаемое значение {z_obs:.6} меньше критического {z_crit:.3} => нулевая гипотеза не отвергается')
203/382:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mux = muy бутерброд падает маслом вниз так же часто, как и маслом вверх 
# H_1: mux > muy маслом вниз чаще

n = 200
m = 105


alpha = 0.05                                    
nx, ny = m, n-m

diff = nx/n - ny/n
diff_std = np.sqrt((0.5*0.5)/nx*n + (0.5*0.5)/ny*n)   # стандартное отклонение

z_obs = diff/diff_std                                          # наблюдаемое значение
z_crit = stats.norm.ppf(1 - alpha)                              # критическое значение

# pval = ... 

print(f'Наблюдаемое значение {z_obs:.6} меньше критического {z_crit:.3} => нулевая гипотеза не отвергается')
203/383:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mux = muy бутерброд падает маслом вниз так же часто, как и маслом вверх 
# H_1: mux > muy маслом вниз чаще

n = 200
m = 105


alpha = 0.05                                    
nx, ny = m, n-m

diff = nx/n - ny/n
diff_std = np.sqrt((0.5*0.5)/(nx*n) + (0.5*0.5)/(ny*n))   # стандартное отклонение

z_obs = diff/diff_std                                          # наблюдаемое значение
z_crit = stats.norm.ppf(1 - alpha)                              # критическое значение

# pval = ... 

print(f'Наблюдаемое значение {z_obs:.6} меньше критического {z_crit:.3} => нулевая гипотеза не отвергается')
203/384:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mux = muy бутерброд падает маслом вниз так же часто, как и маслом вверх 
# H_1: mux > muy маслом вниз чаще

n = 200
m = 105


alpha = 0.05                                    
nx, ny = m, n-m

diff = nx/n - ny/n
diff_std = np.sqrt((0.475*0.525)/nx + (0.475*0.525)/ny)   # стандартное отклонение

z_obs = diff/diff_std                                           # наблюдаемое значение
z_crit = stats.norm.ppf(1 - alpha)                              # критическое значение

# pval = ... 

print(f'Наблюдаемое значение {z_obs:.5} меньше критического {z_crit:.3} => нулевая гипотеза не отвергается')
204/1:
import numpy as np
import pandas as pd

from scipy import stats as sts
from scipy import stats
import statsmodels as sts

import seaborn as sns
import matplotlib.pyplot as plt
from statsmodels.stats.weightstats import ttest_ind


plt.style.use('ggplot')
204/2:
df = pd.read_csv('./data/df_vk_wise.csv')[50:]
df.head()
204/3:
mu_with_pr = has_pronouns.mean()
mu_without_pr = has_not_pronouns.mean()

has_pronouns_median = has_pronouns.median()
has_not_pronouns_median = has_not_pronouns.median()

print(f'среднее {mu_with_pr} и медиана {has_pronouns_median} для постов, содержащих местоимения')
print(f'среднее {mu_without_pr} и медиана {has_not_pronouns_median} для постов, НЕ содержащих местоимения')
204/4:
has_pronouns = df[df.I == True]['likes']

sns.histplot(has_pronouns, bins=10, stat='density', kde=True)
204/5:
has_not_pronouns = df[df.I == False]['likes']


sns.histplot(has_not_pronouns, bins=10, stat='density', kde=True)
204/6:
mu_with_pr = has_pronouns.mean()
mu_without_pr = has_not_pronouns.mean()

has_pronouns_median = has_pronouns.median()
has_not_pronouns_median = has_not_pronouns.median()

print(f'среднее {mu_with_pr} и медиана {has_pronouns_median} для постов, содержащих местоимения')
print(f'среднее {mu_without_pr} и медиана {has_not_pronouns_median} для постов, НЕ содержащих местоимения')
204/7:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_with_pr= mu_without_pr те, кто пишут и не пишут местоимения, ставят в среднем одинаковое кол-во лайков
# H_1: mu_with_pr != mu_without_pr

alpha = 0.05                                                  
n_with_pr, n_without_pr = has_pronouns.size, has_not_pronouns.size

diff = mu_with_pr - mu_without_pr # разность средних
diff_std = np.sqrt(has_pronouns.var(ddof=1)/n_with_pr + has_not_pronouns.var(ddof=1)/n_without_pr)   # стандартное отклонение

z_obs = diff/diff_std # наблюдаемое значение статистики 

print(f'Наблюдаемое значение {z_obs:.6}')
204/8:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение
pval1 = 

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5} =>гипотеза H_0 не отвергается')
204/9:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение
# pval1 = 
# 
print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5} =>гипотеза H_0 не отвергается')
204/10:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение
pval1 = stats.chi2().cdf(chi_obs)

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5} =>гипотеза H_0 не отвергается')
print('pval1', pval1)
204/11:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение
pval1 = stats.chi2().cdf(chi_obs,df=(n-1))

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5} =>гипотеза H_0 не отвергается')
print('pval1', pval1)
204/12:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение
pval1 = stats.chi2().cdf(chi_obs, df=(n-1))

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5} =>гипотеза H_0 не отвергается')
print('pval1', pval1)
204/13:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение
pval1 = stats.chi2().cdf(chi_obs, n-1)

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5} =>гипотеза H_0 не отвергается')
print('pval1', pval1)
204/14:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение
pval1 = stats.chi2().cdf(chi_obs, df=(n-1))

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5} =>гипотеза H_0 не отвергается')
print('pval1', pval1)
204/15:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение
pval1 = stats.chi2.cdf(chi_obs, df=(n-1))

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5} =>гипотеза H_0 не отвергается')
print('pval1', pval1)
204/16:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение
pval1 = 1- stats.chi2.cdf(chi_obs, df=(n-1))

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5} =>гипотеза H_0 не отвергается')
print('pval1', pval1)
204/17:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение
pval1 = 1- stats.chi2.cdf(chi_obs, df=(n-1))

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5} => гипотеза H_0 не отвергается')
print('pval1', pval1)
204/18:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var_new = var_old = технологии обладают одинаковой дисперсией
# H_1: var_old > var_new  новая технология обладает меньшей дисперсией

alpha = 0.01
n, m = 100, 100
std_old = 6
std_new = 5

F_obs = 6**2/5**2

left = F_obs * stats.f(n-1, m-1).ppf(alpha/2)
right = F_obs * stats.f(n-1, m-1).ppf(1 - alpha/2)
                                  
pval2 = ...
print('F_obs', F_obs)
print(f'Наблюдаемое значение {F_obs:.5}')

print("Доверительный интервал [{:.5}; {:.5}] ширины {:.5}".format(left, right, right - left))
204/19:
# проверка того, что задание решено верно
assert np.abs(chi_obs - 9.72) < 1e-1
assert np.abs(F_obs - 1.44) < 1e-1
204/20:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var_old = var_new  технологии обладают одинаковой дисперсией
# H_1: var_old > var_new  новая технология обладает меньшей дисперсией

alpha = 0.01
n, m = 100, 100

std_old = 6
std_new = 5

F_obs = 6**2/5**2

f_rv = stats.f(nx - 1, ny - 1) 
F_crit = f_rv.ppf(1 - alpha/2)           # критическое значение
                                  
pval2 = f_rv.cdf(F_obs) 

print(f'Наблюдаемое значение {F_obs:.5} меньше критического {F_crit:.5} => гипотеза H_0 не отвергается')
204/21:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var_old = var_new  технологии обладают одинаковой дисперсией
# H_1: var_old > var_new  новая технология обладает меньшей дисперсией

alpha = 0.01
n, m = 100, 100

std_old = 6
std_new = 5

F_obs = 6**2/5**2

f_rv = stats.f(n - 1, m - 1) 
F_crit = f_rv.ppf(1 - alpha/2)           # критическое значение
                                  
pval2 = f_rv.cdf(F_obs) 

print(f'Наблюдаемое значение {F_obs:.5} меньше критического {F_crit:.5} => гипотеза H_0 не отвергается')
204/22:
# проверка того, что задание решено верно
assert np.abs(chi_obs - 9.72) < 1e-1
assert np.abs(F_obs - 1.44) < 1e-1
204/23:
# проверка того, что задание решено верно
assert np.abs(chi_obs - 9.72) < 1e-1
assert np.abs(F_obs - 1.44) < 1e-1
204/24:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var_old = var_new  технологии обладают одинаковой дисперсией
# H_1: var_old > var_new  новая технология обладает меньшей дисперсией

alpha = 0.01
n, m = 100, 100

std_old = 6
std_new = 5

F_obs = 6**2/5**2

f_rv = stats.f(n - 1, m - 1) 
F_crit = f_rv.ppf(1 - alpha/2)           # критическое значение
                                  
pval2 = f_rv.cdf(F_obs) 

print(f'Наблюдаемое значение {F_obs:.5} меньше критического {F_crit:.5} => гипотеза H_0 не отвергается')
print('pval2', pval2)
204/25:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var_old > var_new  новая технология обладает меньшей дисперсией
# H_1: var_old <= var_new   технологии обладают одинаковой дисперсией или старая техн обладает больше дисп

alpha = 0.01
n, m = 100, 100

std_old = 6
std_new = 5

F_obs = 6**2/5**2

f_rv = stats.f(n - 1, m - 1) 
F_crit = f_rv.ppf(1 - alpha/2)           # критическое значение
                                  
pval2 = f_rv.cdf(F_obs) 

print(f'Наблюдаемое значение {F_obs:.5} меньше критического {F_crit:.5} => гипотеза H_0 не отвергается')
print('pval2', pval2)
204/26:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var_old > var_new  новая технология обладает меньшей дисперсией
# H_1: var_old <= var_new   технологии обладают одинаковой дисперсией или старая техн обладает больше дисп

alpha = 0.01
n, m = 100, 100

std_old = 6
std_new = 5

F_obs = 6**2/5**2

f_rv = stats.f(n - 1, m - 1) 
F_crit = f_rv.ppf(1 - alpha/2)           # критическое значение
                                  
pval2 = 1 - f_rv.cdf(F_obs) 

print(f'Наблюдаемое значение {F_obs:.5} меньше критического {F_crit:.5} => гипотеза H_0 не отвергается')
print('pval2', pval2)
204/27:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var_old > var_new  новая технология обладает меньшей дисперсией
# H_1: var_old <= var_new   технологии обладают одинаковой дисперсией или старая техн обладает больше дисп

alpha = 0.01
n, m = 100, 100

std_old = 6
std_new = 5

F_obs = 6**2/5**2

f_rv = stats.f(n - 1, m - 1) 
F_crit = f_rv.ppf(1 - alpha/2)           # критическое значение
                                  
pval2 = f_rv.cdf(F_obs, n - 1, m - 1) 

print(f'Наблюдаемое значение {F_obs:.5} меньше критического {F_crit:.5} => гипотеза H_0 не отвергается')
print('pval2', pval2)
204/28:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение
pval1 = 1- stats.chi2.cdf(chi_obs, df=(n-1))

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5}, но {pval1} > {alpha} => гипотеза H_0 отвергается')
print('pval1', pval1)
204/29:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение
pval1 = 1- stats.chi2.cdf(chi_obs, df=(n-1))

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5}, но p value{pval1:.5} > {alpha} => гипотеза H_0 отвергается')
print('pval1', pval1)
204/30:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение
pval1 = 1- stats.chi2.cdf(chi_obs, df=(n-1))

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5}, но p value 
    {pval1:.5} > {alpha} => гипотеза H_0 отвергается')
print('pval1', pval1)
204/31:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение
pval1 = 1- stats.chi2.cdf(chi_obs, df=(n-1))

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5}, но p value {pval1:.5} > {alpha} => гипотеза H_0 отвергается')
print('pval1', pval1)
204/32:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение
pval1 = 1- stats.chi2.cdf(chi_obs, df=(n-1))

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5}, но pval1 {pval1:.5} > {alpha} => гипотеза H_0 отвергается')
print('pval1', pval1)
204/33:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
z_crit = stats.norm.ppf(1 - alpha)               # критическое значение статистики

pval =  2 * (1 - stats.norm().cdf(np.abs(z_obs)))


print(f'{z_obs:.3} не попадает в ({-z_crit:.3} , {z_crit:.3}) => Нулевая гипотеза отвергается')
print('pval < alpha', pval)
204/34:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение
pval1 = 1- stats.chi2.cdf(chi_obs, df=(n-1))

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5}, но pval1 {pval1:.5} > {alpha} => гипотеза H_0 отвергается')
print('pval1 > alpha', pval1)
204/35:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var_old > var_new  новая технология обладает меньшей дисперсией
# H_1: var_old <= var_new   технологии обладают одинаковой дисперсией или старая техн обладает больше дисп

alpha = 0.01
n, m = 100, 100

std_old = 6
std_new = 5

F_obs = 6**2/5**2

f_rv = stats.f(n - 1, m - 1) 
F_crit = f_rv.ppf(1 - alpha/2)           # критическое значение
                                  
pval2 = f_rv.cdf(F_obs) 

print(f'Наблюдаемое значение {F_obs:.5} меньше критического {F_crit:.5} => гипотеза H_0 не отвергается')
print('pval2', pval2)
204/36:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение
pval1 = 1- stats.chi2.cdf(chi_obs, df=(n-1))

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5} => гипотеза H_0 отвергается')
print('pval1 > alpha', pval1)
204/37:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var <= 25 партия хорошая и ее можно продавать
# H_1: var > 25 партия плохая и списать в брак

alpha = 0.01
n = 10
s_obs = 27

chi_obs = (n - 1) * s_obs / 25

chi_krit = stats.chi2.ppf(1-alpha, df=(n-1))  # критическое значение
pval1 = 1 - stats.chi2.cdf(chi_obs, df=(n-1))

print(f'Наблюдаемое значение {chi_obs:.5} меньше критического {chi_krit:.5} => гипотеза H_0 не отвергается')
print('pval1 > alpha', pval1)
204/38:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var_old > var_new  новая технология обладает меньшей дисперсией
# H_1: var_old <= var_new   технологии обладают одинаковой дисперсией или старая техн обладает больше дисп

alpha = 0.01
n, m = 100, 100

std_old = 6
std_new = 5

F_obs = 6**2/5**2

f_rv = stats.f(n - 1, m - 1) 
F_crit = f_rv.ppf(1 - alpha/2)           # критическое значение
                                  
pval2 = f_rv.cdf(F_obs) 

print(f'Наблюдаемое значение {F_obs:.5} меньше критического {F_crit:.5} => гипотеза H_0  отвергается')
print('pval2', pval2)
204/39:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var_old > var_new  новая технология обладает меньшей дисперсией
# H_1: var_old <= var_new   технологии обладают одинаковой дисперсией или старая техн обладает больше дисп

alpha = 0.01
n, m = 100, 100

std_old = 6
std_new = 5

F_obs = 6**2/5**2

f_rv = stats.f(n - 1, m - 1) 
F_crit = f_rv.ppf(1 - alpha/2)           # критическое значение
                                  
pval2 = f_rv.cdf(F_obs) 

print(f'Наблюдаемое значение {F_obs:.5} меньше критического {F_crit:.5} => гипотеза H_0 отвергается')
print('pval2', pval2)
204/40:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: var_old > var_new  новая технология обладает меньшей дисперсией
# H_1: var_old <= var_new   технологии обладают одинаковой дисперсией или старая техн обладает больше дисп

alpha = 0.01
n, m = 100, 100

std_old = 6
std_new = 5

F_obs = 6**2/5**2

f_rv = stats.f(n - 1, m - 1) 
F_crit = f_rv.ppf(1 - alpha/2)           # критическое значение
                                  
pval2 = f_rv.cdf(F_obs) 

print(f'Наблюдаемое значение {F_obs:.5} меньше критического {F_crit:.5} => гипотеза H_0 не отвергается')
print('pval2', pval2)
204/41:
df = pd.read_csv('./data/presidents.csv')
df.head()
204/42:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

df = pd.melt(df, id_vars=['year'], value_vars=['Qtr1', 'Qtr2', "Qtr3", "Qtr4"])
df['time'] = df['year'] + df['variable'].str[-1].astype(int)/10

x = df.query('1969<=time<=1972.2')['value'].dropna().values
y = df.query('1972.3<=time<=1974.2')['value'].dropna().values
y
204/43: x.mean(), y.mean()
204/44:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг распределён нормально
# H_1: mu_x > mu_y

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних

diff_var = ((nx - 1)*x.var(ddof=1) + (ny - 1)*y.var(ddof=1))/(nx + ny - 2) # дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(diff_var/nx + diff_var/ny)                   # стандартное отклонение

obs = diff/diff_std                                           # наблюдаемое значение
crit = stats.t(df = nx + ny - 2).ppf(1 - alpha)               # критическое значени


obs, pval, _ = ttest_ind(x, y, value=0, alternative='larger')

print(f'Наблюдаемое значение {obs:.6}, p-value {pval:.6} < alpha')
print('Наблюдаемое значение 3.5640 меньше критического 1.73406 => нулевая гипотеза отвергается')
204/45:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг распределён нормально
# H_1: mu_x > mu_y

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних

diff_var = ((nx - 1)*x.var(ddof=1) + (ny - 1)*y.var(ddof=1))/(nx + ny - 2) # дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(diff_var/nx + diff_var/ny)                   # стандартное отклонение

obs = diff/diff_std                                           # наблюдаемое значение
crit = stats.t(df = nx + ny - 2).ppf(1 - alpha)               # критическое значени


obs, pval, _ = ttest_ind(x, y, value=0, alternative='larger')

print(f'Наблюдаемое значение {obs:.6}, p-value {pval:.4} < alpha')
print('Наблюдаемое значение 3.5640 меньше критического 1.73406 => нулевая гипотеза отвергается')
204/46:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг распределён нормально
# H_1: mu_x > mu_y

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних

diff_var = ((nx - 1)*x.var(ddof=1) + (ny - 1)*y.var(ddof=1))/(nx + ny - 2) # дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(diff_var/nx + diff_var/ny)                   # стандартное отклонение

obs = diff/diff_std                                           # наблюдаемое значение
crit = stats.t(df = nx + ny - 2).ppf(1 - alpha)               # критическое значени


obs, pval, _ = ttest_ind(x, y, value=0, alternative='larger')

print(f'Наблюдаемое значение {obs:.4}, p-value {pval:.4} < alpha')
print('Наблюдаемое значение 3.5640 меньше критического 1.73406 => нулевая гипотеза отвергается')
204/47:
# проверка того, что задание решено верно
assert np.abs(obs - 3.5640741313229793) < 1e-5
204/48:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг до и после скандала не изменился
# H_1: mu_x > mu_y  рейтинг до скандала был выше

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних

diff_var = ((nx - 1)*x.var(ddof=1) + (ny - 1)*y.var(ddof=1))/(nx + ny - 2) # дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(diff_var/nx + diff_var/ny)                   # стандартное отклонение

obs = diff/diff_std                                           # наблюдаемое значение
crit = stats.t(df = nx + ny - 2).ppf(1 - alpha)               # критическое значени


obs, pval, _ = ttest_ind(x, y, value=0, alternative='larger')

print(f'p-value {pval:.4} < alpha')
print(f'Наблюдаемое значение {obs:.4} меньше критического {crit:.4} => нулевая гипотеза отвергается')
204/49:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг до и после скандала не изменился
# H_1: mu_x > mu_y  рейтинг до скандала был выше

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних

diff_var = ((nx - 1)*x.var(ddof=1) + (ny - 1)*y.var(ddof=1))/(nx + ny - 2) # дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(diff_var/nx + diff_var/ny)                   # стандартное отклонение

obs = diff/diff_std                                           # наблюдаемое значение
crit = stats.t(df = nx + ny - 2).ppf(1 - alpha)               # критическое значени


obs, pval, _ = ttest_ind(x, y, value=0, alternative='larger')

print(f'p-value {pval:.4} < alpha => гипотеза отвергается')
print(f'Наблюдаемое значение {obs:.4} меньше критического {crit:.4} => нулевая гипотеза отвергается')
204/50:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_x = mu_y  рейтинг до и после скандала не изменился
# H_1: mu_x > mu_y  рейтинг до скандала был выше

alpha = 0.05                                                  
nx, ny = x.size, y.size

diff = x.mean() - y.mean() # разность средних

diff_var = ((nx - 1)*x.var(ddof=1) + (ny - 1)*y.var(ddof=1))/(nx + ny - 2) # дисперсия рейтинга не изменилась из-за скандала
diff_std = np.sqrt(diff_var/nx + diff_var/ny)                   # стандартное отклонение

obs = diff/diff_std                                           # наблюдаемое значение
crit = stats.t(df = nx + ny - 2).ppf(1 - alpha)               # критическое значени


obs, pval, _ = ttest_ind(x, y, value=0, alternative='larger')

print(f'p-value {pval:.4} < alpha =>  нулевая гипотеза отвергается')
print(f'Наблюдаемое значение {obs:.4} меньше критического {crit:.4} => нулевая гипотеза отвергается')
204/51:
# проверка того, что задание решено верно
assert np.abs(obs - 3.5640741313229793) < 1e-5
204/52:
df = pd.read_csv('./data/sleep.csv')
df
204/53:
before = df[df['group'] == 1].extra
after = df[df['group'] == 2].extra
204/54:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std =  before.std(ddof=1)/np.sqrt(n)

tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'Наблюдаемое значение {tobs1:.4} меньше критического {t_crit:.4} => нулевая гипотеза не отвергается')
print(f'pval1 {pval1:.6}')
204/55:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_before == 0 отклонение от 8 часов равно нулю
# H_1: mu_before != 0 не равно

alpha = 0.05
mu_0 = 0     # тест мат ожидание
n = before.size
mu = before.mean()
std =  before.std(ddof=1)/np.sqrt(n)

tobs1 = (mu - mu_0)/std   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

pval1 = 2 * (1 - stats.norm().cdf(np.abs(tobs1)))

print(f'Наблюдаемое значение {tobs1:.4} меньше критического {t_crit:.4} => нулевая гипотеза не отвергается')
print(f'pval1 {pval1:.6} > alpha')
204/56: data = pd.DataFrame()
204/57:
after = pd.DataFrame()
after = df[10:20]['extra'].reset_index().drop('index', axis =1)
after.columns = ['after']
204/58:
data['before'] = df[:10]['extra']
data['after'] = after
204/59:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_after - mu_before = 0 до и после приема таблеток студенты спали одинаковое кол-во времени
# H_1: mu_after - mu_before > 0 благодаря таблеткам студенты стали спать больше

d = data.after - data.before
alpha = 0.05
d_mean = d.mean()
d_std = d.std(ddof=1)


tobs2 = d.mean()/np.sqrt(d.var(ddof=1)/d.size)   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

t_obs_check, pval2 = stats.ttest_rel(data.after, data.before, alternative='greater')

print(f'Наблюдаемое значение {tobs2:.4} больше критического {t_crit:.4} => нулевая гипотеза отвергается')
print(f'pval1 {pval2:.6}') 
print(f't_obs_check {t_obs_check}')
204/60:
# проверка того, что задание решено верно
assert np.abs(tobs1 - 1.325710) < 1e-5
assert np.abs(tobs2 - 4.062127) < 1e-5
204/61:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_after - mu_before = 0 до и после приема таблеток студенты спали одинаковое кол-во времени
# H_1: mu_after - mu_before > 0 благодаря таблеткам студенты стали спать больше

d = data.after - data.before
alpha = 0.05
d_mean = d.mean()
d_std = d.std(ddof=1)


tobs2 = d.mean()/np.sqrt(d.var(ddof=1)/d.size)   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

t_obs_check, pval2 = stats.ttest_rel(data.after, data.before, alternative='greater')

print(f'Наблюдаемое значение {tobs2:.4} больше критического {t_crit:.4} => нулевая гипотеза отвергается')
print(f'pval1 {pval2:.6} < alpha => нул гипотеза отвергается') 
print(f't_obs_check {t_obs_check}')
204/62:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_after - mu_before = 0 до и после приема таблеток студенты спали одинаковое кол-во времени
# H_1: mu_after - mu_before > 0 благодаря таблеткам студенты стали спать больше

d = data.after - data.before
alpha = 0.05
d_mean = d.mean()
d_std = d.std(ddof=1)


tobs2 = d.mean()/np.sqrt(d.var(ddof=1)/d.size)   # наблюдаемое значение статистики
t_crit = stats.t(n - 1).ppf(1 - alpha)  # критическое значение

t_obs_check, pval2 = stats.ttest_rel(data.after, data.before, alternative='greater')

print(f'Наблюдаемое значение {tobs2:.4} больше критического {t_crit:.4} => нулевая гипотеза отвергается')
print(f'pval1 {pval2:.6} < alpha => нул гипотеза отвергается') 
print(f't_obs_check {t_obs_check:.4}')
204/63:
df = pd.read_csv('./data/cats_names.csv', sep='\t')
df.head(30)
204/64:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 есть различия

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)
print(noun4_0, noun4_1)

name_0 = (name == 0).sum(axis=0)
name_1 = (name == 1).sum(axis=0)
print(name_0, name_1)

a = 1
b = 1
c = 5
d = 9

z_obs = (c - b)/np.sqrt((c+b) - (c-b)**2/n)
z_crit = stats.norm().ppf(1 - alpha/2)
p_value = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))
print(f'Наблюдаемое значение {z_obs:.6} меньще критического {z_crit:.4} => нулевая гипотеза не отвергается')
print(f'p_value {p_value}')
204/65:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p1=p2 доля откликов на имя и на слово одинаковая
# H_1: p1 != p2 есть различия

all_noun4 = df.loc[df['stimuli'] == 'Noun 4'].reset_index()
all_names = df.loc[df['stimuli'] == 'Test Cat\'s Name'].reset_index()

noun4 = all_noun4['Total Score'].apply(lambda x: 1 if x > 0 else 0)
name = all_names['Total Score'].apply(lambda x: 1 if x > 0 else 0)

n = name.size
noun4_0 = (noun4 == 0).sum(axis=0)
noun4_1 = (noun4 == 1).sum(axis=0)
print(noun4_0, noun4_1)

name_0 = (name == 0).sum(axis=0)
name_1 = (name == 1).sum(axis=0)
print(name_0, name_1)

a = 1
b = 1
c = 5
d = 9

z_obs = (c - b)/np.sqrt((c+b) - (c-b)**2/n)
z_crit = stats.norm().ppf(1 - alpha/2)
p_value = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))
print(f'Наблюдаемое значение {z_obs:.6} попадает в ({-z_crit:.3} , {z_crit:.3}) => нулевая гипотеза не отвергается')
print(f'p_value {p_value} > alpha')
204/66:
# проверка того, что задание решено верно
assert sum(name) == 14
assert np.abs(z_obs - 1.7888543819998317) < 1e-5
204/67:
df = pd.read_csv('./data/matan.csv', sep='\t')
df.head()
204/68:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

angry = df[df['is_angry'] == 1]['target_1'].dropna()
kind = df[df['is_angry'] == 0]['target_1'].dropna()

# H_0: p_angry = p_kind доля отчислений для доброго и злого преподавателей равна
# H_1: p_angry != p_kind есть различия

alpha = 0.01                                    
n1,n2 = angry.size, kind.size                     
m1,m2 = angry.sum(), kind.sum()                 

p1, p2 = angry.mean(), kind.mean()                 # точеные оценки долей 
diff = p1 - p2                                     # разность долей

P = (m1 + m2)/(n1 + n2)          
diff_std = np.sqrt(P*(1 - P)*(1/n1 + 1/n2))        # стандартное отклонение разности
                                    
z_obs = diff/diff_std                              # наблюдаемое значение статистики 
z_crit = stats.norm.ppf(1 - alpha/2)               # критическое значение статистики

pval = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))

print(f'{z_obs:.6} попадает в ({-z_crit:.6} , {z_crit:.6}) => Нулевая гипотеза не отвергается')
print(f'pval {p_value} > alpha')
204/69:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

angry = df[df['is_angry'] == 1]['target_1'].dropna()
kind = df[df['is_angry'] == 0]['target_1'].dropna()

# H_0: p_angry = p_kind доля отчислений для доброго и злого преподавателей равна
# H_1: p_angry != p_kind есть различия

alpha = 0.01                                    
n1,n2 = angry.size, kind.size                     
m1,m2 = angry.sum(), kind.sum()                 

p1, p2 = angry.mean(), kind.mean()                 # точеные оценки долей 
diff = p1 - p2                                     # разность долей

P = (m1 + m2)/(n1 + n2)          
diff_std = np.sqrt(P*(1 - P)*(1/n1 + 1/n2))        # стандартное отклонение разности
                                    
z_obs = diff/diff_std                              # наблюдаемое значение статистики 
z_crit = stats.norm.ppf(1 - alpha/2)               # критическое значение статистики

pval = 2 * (1 - stats.norm().cdf(np.abs(z_obs)))

print(f'{z_obs:.6} попадает в ({-z_crit:.6} , {z_crit:.6}) => Нулевая гипотеза не отвергается')
print(f'pval {pval} > alpha')
204/70:
# проверка того, что задание решено верно
assert np.abs(np.abs(z_obs) - 0.29897)  < 1e-5
204/71:
killer1 = pd.read_csv("./data/killer_time1.csv").hours_between_kill.values
killer2 = pd.read_csv("./data/killer_time2.csv").hours_between_kill.values
204/72:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
205/1:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p = 0.5 бутерброд падает маслом вниз так же часто, как и маслом вверх 
# H_1: p != 0.5 маслом вниз чаще

n = 200
m = 105


alpha = 0.05
mean = m/n

z_obs =  (mean-p0) / (p0*(1-p0)/n)**0.5 
z_crit = stats.norm.ppf(1 - alpha)                              # критическое значение

pval = 2 * (1 - stats.norm().cdf(np.abs(z_obs))) 


print(f'Наблюдаемое значение {z_obs:.5} меньше критического {z_crit:.3} => нулевая гипотеза не отвергается')
print('pval', pval)
205/2:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p = 0.5 бутерброд падает маслом вниз так же часто, как и маслом вверх 
# H_1: p != 0.5 маслом вниз чаще

p0 = 0.5
n = 200
m = 105


alpha = 0.05
mean = m/n

z_obs =  (mean-p0) / (p0*(1-p0)/n)**0.5 
z_crit = stats.norm.ppf(1 - alpha)                              # критическое значение

pval = 2 * (1 - stats.norm().cdf(np.abs(z_obs))) 


print(f'Наблюдаемое значение {z_obs:.5} меньше критического {z_crit:.3} => нулевая гипотеза не отвергается')
print('pval', pval)
205/3:
import numpy as np
import pandas as pd

from scipy import stats as sts
from scipy import stats
import statsmodels as sts

import seaborn as sns
import matplotlib.pyplot as plt
from statsmodels.stats.weightstats import ttest_ind


plt.style.use('ggplot')
205/4:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p = 0.5 бутерброд падает маслом вниз так же часто, как и маслом вверх 
# H_1: p != 0.5 маслом вниз чаще

p0 = 0.5
n = 200
m = 105


alpha = 0.05
mean = m/n

z_obs =  (mean-p0) / (p0*(1-p0)/n)**0.5 
z_crit = stats.norm.ppf(1 - alpha)                              # критическое значение

pval = 2 * (1 - stats.norm().cdf(np.abs(z_obs))) 


print(f'Наблюдаемое значение {z_obs:.5} меньше критического {z_crit:.3} => нулевая гипотеза не отвергается')
print('pval', pval)
205/5:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p = 0.5 бутерброд падает маслом вниз так же часто, как и маслом вверх 
# H_1: p != 0.5 маслом вниз чаще

p0 = 0.5
n = 200
m = 105


alpha = 0.05
mean = m/n

z_obs =  (mean-p0) / (p0*(1-p0)/n)**0.5 
z_crit = stats.norm.ppf(1 - alpha)                              # критическое значение

pval = 2 * (1 - stats.norm().cdf(np.abs(z_obs))) 


print(f'Наблюдаемое значение {z_obs:.5} меньше критического {z_crit:.3} => нулевая гипотеза не отвергается')
print('pval > alpha', pval)
205/6:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
z_crit = stats.norm.ppf(1 - alpha)               # критическое значение статистики

pval =  2 * (1 - stats.norm().cdf(np.abs(z_obs)))


print(f'{z_obs:.3} не попадает в ({-z_crit:.3} , {z_crit:.3}) => Нулевая гипотеза отвергается')
print('pval < alpha => Нулевая гипотеза отвергается', pval)
205/7:
df = pd.read_csv('./data/df_vk_wise.csv')[50:]
df.head()
205/8:
has_pronouns = df[df.I == True]['likes']

sns.histplot(has_pronouns, bins=10, stat='density', kde=True)
205/9:
has_not_pronouns = df[df.I == False]['likes']


sns.histplot(has_not_pronouns, bins=10, stat='density', kde=True)
205/10:
mu_with_pr = has_pronouns.mean()
mu_without_pr = has_not_pronouns.mean()

has_pronouns_median = has_pronouns.median()
has_not_pronouns_median = has_not_pronouns.median()

print(f'среднее {mu_with_pr} и медиана {has_pronouns_median} для постов, содержащих местоимения')
print(f'среднее {mu_without_pr} и медиана {has_not_pronouns_median} для постов, НЕ содержащих местоимения')
205/11:
likes_mean = df['likes'].mean()
likes_median = df['likes'].median()
print(f'среднее {likes_mean} и медиана {likes_median} для всех постов')
205/12:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: mu_with_pr= mu_without_pr те, кто пишут и не пишут местоимения, ставят в среднем одинаковое кол-во лайков
# H_1: mu_with_pr != mu_without_pr

alpha = 0.05                                                  
n_with_pr, n_without_pr = has_pronouns.size, has_not_pronouns.size

diff = mu_with_pr - mu_without_pr # разность средних
diff_std = np.sqrt(has_pronouns.var(ddof=1)/n_with_pr + has_not_pronouns.var(ddof=1)/n_without_pr)   # стандартное отклонение

z_obs = diff/diff_std # наблюдаемое значение статистики 

print(f'Наблюдаемое значение {z_obs:.6}')
205/13:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
z_crit = stats.norm.ppf(1 - alpha)               # критическое значение статистики

pval =  2 * (1 - stats.norm().cdf(np.abs(z_obs)))


print(f'{z_obs:.3} не попадает в ({-z_crit:.3} , {z_crit:.3}) => Нулевая гипотеза отвергается')
print('pval > alpha => Нулевая гипотеза отвергается', pval)
205/14:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
z_crit = stats.norm.ppf(1 - alpha)               # критическое значение статистики

pval =  2 * (1 - stats.norm().cdf(np.abs(z_obs)))


print(f'{z_obs:.3} не попадает в ({-z_crit:.3} , {z_crit:.3}) => Нулевая гипотеза отвергается')
print('pval < alpha => Нулевая гипотеза отвергается', pval)
205/15:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: p = 0.5 бутерброд падает маслом вниз так же часто, как и маслом вверх 
# H_1: p != 0.5 маслом вниз чаще

p0 = 0.5
n = 200
m = 105


alpha = 0.05
mean = m/n

z_obs =  (mean-p0) / (p0*(1-p0)/n)**0.5 
z_crit = stats.norm.ppf(1 - alpha)                              # критическое значение

pval = 2 * (1 - stats.norm().cdf(np.abs(z_obs))) 


print(f'Наблюдаемое значение {z_obs:.5} меньше критического {z_crit:.3} => нулевая гипотеза не отвергается')
print('pval > alpha', pval)
205/16:
# проверка того, что задание решено верно
assert np.abs(z_obs - 0.707) < 1e-3
205/17:
killer1 = pd.read_csv("./data/killer_time1.csv").hours_between_kill.values
killer2 = pd.read_csv("./data/killer_time2.csv").hours_between_kill.values
205/18: plt.hist(killer1, bins=20);
205/19: plt.hist(killer2, bins=20);
205/20: killer1.head()
205/21: killer1
205/22:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: F1 = F2 одинаковое распределение у выборок
# H_0: F1 != F2 из разных распределений

scipy.stats.ks_2samp(killer1, killer2, alternative='two-sided')
205/23:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: F1 = F2 одинаковое распределение у выборок
# H_0: F1 != F2 из разных распределений

stats.ks_2samp(killer1, killer2, alternative='two-sided')
205/24:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: F1 = F2 одинаковое распределение у выборок
# H_0: F1 != F2 из разных распределений

statistic, pvalue = stats.ks_2samp(killer1, killer2, alternative='two-sided')
print(f'pval {pval} > alpha 0.05 => Нулевая гипотеза не отвергается')
205/25:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: F1 = F2 одинаковое распределение у выборок
# H_0: F1 != F2 из разных распределений

statistic, pvalue = stats.ks_2samp(killer1, killer2, alternative='two-sided')
print(f'pval {pval:.5} > alpha 0.05 => Нулевая гипотеза не отвергается')
205/26:
# проверка того, что задание решено верно
assert pvalue1 > 0.5
205/27:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: F1 = F2 одинаковое распределение у выборок
# H_0: F1 != F2 из разных распределений

statistic, pvalue1 = stats.ks_2samp(killer1, killer2, alternative='two-sided')
print(f'pval {pvalue1:.5} > alpha 0.05 => Нулевая гипотеза не отвергается')
205/28:
# проверка того, что задание решено верно
assert pvalue1 > 0.5
205/29:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# H_0: F1 = F2 одинаковое распределение у выборок
# H_0: F1 != F2 из разных распределений

statistic, pvalue1 = stats.ks_2samp(killer1, killer2, alternative='two-sided')
print(f'pvalue1 {pvalue1:.5} > alpha 0.05 => Нулевая гипотеза не отвергается')
205/30:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below


# H_0: F1 имеет expon(𝜆=0.026)
# H_1: F1 не имеет эксп распределения

lambd = 0.026
statistic, pvalue2 = stats.kstest(x, 'expon', args=(0, lambd))
print(f'pvalue1 {pvalue2:.5} > alpha 0.05 => Нулевая гипотеза не отвергается')
205/31:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below


# H_0: F1 имеет expon(𝜆=0.026)
# H_1: F1 не имеет эксп распределения

lambd = 0.026
statistic, pvalue2 = stats.kstest(killer1, 'expon', args=(0, lambd))
print(f'pvalue1 {pvalue2:.5} > alpha 0.05 => Нулевая гипотеза не отвергается')
205/32:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below


# H_0: F1 имеет expon(𝜆=0.026)
# H_1: F1 не имеет эксп распределения

lambd = 0.026
statistic, pvalue2 = stats.kstest(killer1, 'expon', args=(lambd, killer1.mean()))
print(f'pvalue1 {pvalue2:.5} > alpha 0.05 => Нулевая гипотеза не отвергается')
205/33:
x = pd.read_csv('./data/mouses_mirror.txt', header = None)[0].values
plt.hist(x, density=True);
205/34: x
205/35:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below


# H_0: F1 имеет expon(𝜆=0.026)
# H_1: F1 не имеет эксп распределения

lambd = 0.026
statistic, pvalue2 = stats.kstest(killer1, 'expon', args=(lambd, killer1.mean()))
print(f'pvalue2 {pvalue2:.5} > alpha 0.05 => Нулевая гипотеза не отвергается')
205/36:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# Критерий знаков принадлежит семейству непараметрических критериев, то есть он не использует никаких данных о характере распределении

# H_0: Med(X) = 0.5  мышкам безразлично в какой комнате проводить
# H_1: Med(X) > 0.5

med_0 = 0.5

stat_T, pvalue_1 = sign_test(x, mu0=med_0)
print(f'pvalue_1 {pvalue_1:.5} < alpha 0.05 => гипотеза отвергается на уровне значимости 5%')
205/37:
import numpy as np
import pandas as pd

from scipy import stats as sts
from scipy import stats
import statsmodels as sts

import seaborn as sns
import matplotlib.pyplot as plt
from statsmodels.stats.weightstats import ttest_ind
from statsmodels.stats.descriptivestats import sign_test


plt.style.use('ggplot')
205/38:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# Критерий знаков принадлежит семейству непараметрических критериев, то есть он не использует никаких данных о характере распределении

# H_0: Med(X) = 0.5  мышкам безразлично в какой комнате проводить
# H_1: Med(X) > 0.5

med_0 = 0.5

stat_T, pvalue_1 = sign_test(x, mu0=med_0)
print(f'pvalue_1 {pvalue_1:.5} < alpha 0.05 => гипотеза отвергается на уровне значимости 5%')
205/39:
# проверка того, что задание решено верно
assert pvalue_1 < 0.05
assert pvalue_2 > 0.05
assert pvalue_3 > 0.05
205/40:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

stat_T, pvalue_2 = stats.wilcoxon(x)
print(f'pvalue_2 {pvalue_2:.5} > alpha 0.05 => гипотеза не отвергается на уровне значимости 5%')
205/41: x
205/42:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

stat_T, pvalue_2 = stats.wilcoxon(x)
print(f'pvalue_2 {pvalue_2:.5} > alpha 0.05 => гипотеза не отвергается на уровне значимости 5%')
205/43:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

stat_T, pvalue_2 = stats.wilcoxon(xб  mu0=med_0)
print(f'pvalue_2 {pvalue_2:.5} > alpha 0.05 => гипотеза не отвергается на уровне значимости 5%')
205/44:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

stat_T, pvalue_2 = stats.wilcoxon(x, mu0=med_0)
print(f'pvalue_2 {pvalue_2:.5} > alpha 0.05 => гипотеза не отвергается на уровне значимости 5%')
205/45:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

stat_T, pvalue_2 = stats.wilcoxon(x)
print(f'pvalue_2 {pvalue_2:.5} > alpha 0.05 => гипотеза не отвергается на уровне значимости 5%')
205/46:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

stat_T, pvalue_2 = stats.wilcoxon(x, alternative='greater')
print(f'pvalue_2 {pvalue_2:.5} > alpha 0.05 => гипотеза не отвергается на уровне значимости 5%')
205/47:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

stat_T, pvalue_2 = stats.wilcoxon(x, alternative='less')
print(f'pvalue_2 {pvalue_2:.5} > alpha 0.05 => гипотеза не отвергается на уровне значимости 5%')
205/48:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

stat_T, pvalue_2 = stats.wilcoxon(x, alternative='less')
print('stat_T', stat_T)
print(f'pvalue_2 {pvalue_2:.5} > alpha 0.05 => гипотеза не отвергается на уровне значимости 5%')
205/49:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

# Критерий знаков принадлежит семейству непараметрических критериев, то есть он не использует никаких данных о характере распределении

# H_0: Med(X) = 0.5  мышкам безразлично в какой комнате проводить
# H_1: Med(X) != 0.5

med_0 = 0.5

stat_T, pvalue_1 = sign_test(x, mu0=med_0)
print('stat_T', stat_T)
print(f'pvalue_1 {pvalue_1:.5} < alpha 0.05 => гипотеза отвергается на уровне значимости 5%')
205/50: x.mean()
205/51:
from statsmodels.stats.weightstats import ztest,zconfint

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z_obs, pvalue_3 = ztest(x, med_0=5, alternative='larger')

print(f"Наблюдаемое значение: {z_obs:.7}") 
print(f"P-значение: {p_val:.3}")
205/52:
from statsmodels.stats.weightstats import ztest,zconfint

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z_obs, pvalue_3 = ztest(x, mu_0=med_0, alternative='less')

print(f"Наблюдаемое значение: {z_obs:.7}") 
print(f"P-значение: {p_val:.3}")
205/53:
from statsmodels.stats.weightstats import ztest,zconfint

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z_obs, pvalue_3 = ztest(x, value=med_0, alternative='less')

print(f"Наблюдаемое значение: {z_obs:.7}") 
print(f"P-значение: {p_val:.3}")
205/54:
from statsmodels.stats.weightstats import ztest,zconfint

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z_obs, pvalue_3 = ztest(x, value=med_0, alternative='less')

print(f"Наблюдаемое значение: {z_obs:.7}") 
print(f"P-значение: {pvalue_3:.3}")
205/55:
from statsmodels.stats.weightstats import ztest,zconfint

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z_obs, pvalue_3 = ztest(x, value=med_0, alternative='less')

# print(f"Наблюдаемое значение: {z_obs:.7}") 
print(f"P-значение: {pvalue_3:.3}")
205/56:
from statsmodels.stats.weightstats import ztest,zconfint

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z_obs, pvalue_3 = ztest(x, value=med_0)

# print(f"Наблюдаемое значение: {z_obs:.7}") 
print(f"P-значение: {pvalue_3:.3}")
205/57:
from statsmodels.stats.weightstats import ztest,zconfint

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z_obs, pvalue_3 = ztest(x, value=med_0, alternative='smaller')

# print(f"Наблюдаемое значение: {z_obs:.7}") 
print(f"P-значение: {pvalue_3:.3}")
205/58:
from statsmodels.stats.weightstats import ztest,zconfint

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z_obs, pvalue_3 = ztest(x, value=med_0, alternative='smaller')

print(f"Наблюдаемое значение: {z_obs:.7}") 
print(f"P-значение: {pvalue_3:.3}")
205/59:
from statsmodels.stats.weightstats import ztest,zconfint

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z_obs, pvalue_3 = ztest(x, value=med_0, alternative='smaller')

print(f"Наблюдаемое значение: {z_obs:.7}") 
print(f"P-значение: {pvalue_3:.3} > alpha 0.05")
205/60:
# проверка того, что задание решено верно
assert pvalue_1 < 0.05
assert pvalue_2 > 0.05
assert pvalue_3 > 0.05
205/61:
df = pd.read_csv('./data/london_07-09-1940.tsv', sep='\t')
print(df.shape)
df.head()
205/62:
import numpy as np
import pandas as pd

from scipy import stats as sts
from scipy import stats
import statsmodels as sts

import seaborn as sns
import matplotlib.pyplot as plt
from statsmodels.stats.weightstats import ttest_ind
from statsmodels.stats.descriptivestats import sign_test
from scipy.stats import chisquare

plt.style.use('ggplot')
205/63:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
observed = np.array([20, 120, 40, 20])
expected_prob = np.array([1/4]*4)

# pvalue = ... 

chisquare(observed_cnts, f_exp=n*expected_prob)
205/64:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
observed = np.array([20, 120, 40, 20])
expected_prob = np.array([1/4]*4)

# pvalue = ... 

chisquare(observed, f_exp=n*expected_prob)
205/65:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
observed = np.array([20, 120, 40, 20])
expected_prob = np.array([1/4]*4)
n= 200
# pvalue = ... 

chisquare(observed, f_exp=n*expected_prob)
205/66:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
observed = np.array([20, 120, 40, 20])
expected_prob = np.array([1/4]*4)
n= 200
# pvalue = ... 

chisquare(observed, f_exp=n*expected_prob)
205/67:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
observed = np.array([20, 20, 120, 40])
n= 200
p = observed/n
print(p)
# pvalue = ... 

chisquare(observed, f_exp=n*expected_prob)
205/68:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
observed = np.array([20, 20, 120, 40])
n= 200
p = observed/n
expected_prob = np.array([0, 0, 0.5, 0.5])
print(p)
# pvalue = ... 

chisquare(observed, f_exp=n*expected_prob)
205/69:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
n = 200
observed = np.array([20, 20, 120, 40])
p = observed/n

expected_prob = np.array([0.1, 0.1, 0.1, 0.9])
print(p)
# pvalue = ... 

chisquare(observed, f_exp=n*expected_prob)
205/70:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
n = 200
observed = np.array([20, 20, 120, 40])
p = observed/n

expected_prob = np.array([0.1, 0.1, 0.1, 0.7])
print(p)
# pvalue = ... 

chisquare(observed, f_exp=n*expected_prob)
205/71:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
n = 200
observed = np.array([20, 20, 120, 40])
p = observed/n

expected_prob = np.array([0.5, 0.5, 0.5, 0.5])
print(p)
# pvalue = ... 

chisquare(observed, f_exp=n*expected_prob)
205/72:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
n = 200
observed = np.array([20, 20, 120, 40])
p = observed/n

expected_prob = np.array([0.7, 0.1, 0.1, 0.1])
print(p)
# pvalue = ... 

chisquare(observed, f_exp=n*expected_prob)
205/73:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
n = 200
observed = np.array([20, 20, 120, 40])
p = observed/n

expected_prob = np.array([0.6, 0.2, 0.1, 0.1])
print(p)
# pvalue = ... 

chisquare(observed, f_exp=n*expected_prob)
205/74:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
n = 200
sample = np.array([20, 20, 120, 40])
r = sample.corr().iloc[0,1]

t = r * np.sqrt((n-2)/(1-r**2))
pval = 2*(1-stats.t.cdf(np.abs(t), n-2))
205/75: stats.pearsonr([20, 120], [40, 20])
205/76: stats.pearsonr([20, 40], [120, 20])
205/77: stats.pearsonr([20, 40], [120, 20])
206/1:
import numpy as np
import pandas as pd

from scipy import stats as sts
from scipy import stats
import statsmodels as sts

import seaborn as sns
import matplotlib.pyplot as plt
from statsmodels.stats.weightstats import ttest_ind
from statsmodels.stats.descriptivestats import sign_test
from scipy.stats import chisquare

plt.style.use('ggplot')
206/2: stats.pearsonr([20/200, 40/200], [120/200, 20/200])
206/3: stats.pearsonr([20/200, 40/200], [120/200, 20/200])
206/4:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
n = 200
sample = np.array([20, 20, 120, 40])
r = sample.corr().iloc[0,1]

t = r * np.sqrt((n-2)/(1-r**2))
pval = 2*(1-stats.t.cdf(np.abs(t), n-2))
206/5:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
n = 200
sample = np.array([20, 20, 120, 40])
expected_prob = np.array([1/4]*4)

chisquare(observed_cnts, f_exp=n*expected_prob)
206/6:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
n = 200
sample = np.array([20, 20, 120, 40])
expected_prob = np.array([1/4]*4)

chisquare(sample, f_exp=n*expected_prob)
206/7:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
n = 200
sample = np.array([20, 20, 120, 40])
expected_prob = np.array([1/4]*4)

print('expected_prob', expected_prob)

chisquare(sample, f_exp=n*expected_prob)
206/8:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
n = 200
sample = np.array([20, 120, 40, 20])
expected_prob = np.array([1/4]*4)

print('expected_prob', expected_prob)

chisquare(sample, f_exp=n*expected_prob)
206/9:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
n = 200
sample = np.array([20/200, 120/200, 40/200, 20/200])
expected_prob = np.array([1/4]*4)

print('sample', sample)
print('expected_prob', expected_prob)

chisquare(sample, f_exp=n*expected_prob)
206/10:
df = pd.DataFrame([20, 40],[120, 20]]
df.columns = ["drink","nodrink"]
df.index = ["pass", "fail"]
df
206/11:
df = pd.DataFrame([20, 40],[120, 20])
df.columns = ["drink","nodrink"]
df.index = ["pass", "fail"]
df
206/12:
df = pd.DataFrame([[20, 40],[120, 20]])
df.columns = ["drink","nodrink"]
df.index = ["pass", "fail"]
df
206/13:
df = pd.DataFrame([[20, 120],[40, 20]])
df.columns = ["drink","nodrink"]
df.index = ["pass", "fail"]
df
206/14:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
from scipy.stats import chi2_contingency
chi, pvalue, df_, expected = chi2_contingency(df.values)
206/15:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
from scipy.stats import chi2_contingency
chi, pvalue, df_, expected = chi2_contingency(df.values)
print('chi, pvalue, df_, expected', chi, pvalue, df_, expected)
206/16:
# проверка того, что задание решено верно
assert pvalue < 0.05
206/17: pvalue
206/18: '{:f}'.format(pvalue)
206/19: '{:10}'.format(pvalue)
206/20: '{:9}'.format(pvalue)
206/21: '{:f}'.format(pvalue)
206/22:
df = pd.DataFrame([[20, 120],[40, 20]])
df.columns = ["pass","fail"]
df.index = ["drink", "nodrink"]
df
206/23:
df = pd.DataFrame([[20, 120],[40, 20]])
df.columns = ["pass","fail"]
df.index = ["drink", "nodrink"]
df
206/24:
df = pd.DataFrame([[20, 40],[120, 20]])
df.columns = ["pass","fail"]
df.index = ["drink", "nodrink"]
df
206/25:
df = pd.DataFrame([[20, 40],[120, 20]])
df.columns = ["pass","fail"]
df.index = ["drink", "nodrink"]
df
206/26:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
from scipy.stats import chi2_contingency
chi, pvalue, df_, expected = chi2_contingency(df.values)
print('chi, pvalue, df_, expected', chi, pvalue, df_, expected)
206/27:
print(f"P-значение: {pvalue:.3} < alpha 0.05 => гипотеза о влиянии энергетика")
'{:f}'.format(pvalue)
206/28:
# проверка того, что задание решено верно
assert pvalue < 0.05
206/29:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below
from scipy.stats import chi2_contingency
# тестируес гипотезу о том, что 2 категориальных фактора не зависимы друг от друга

chi, pvalue, df_, expected = chi2_contingency(df.values)
print('chi, pvalue, df_, expected', chi, pvalue, df_, expected)
206/30:
df = pd.read_csv('./data/london_07-09-1940.tsv', sep='\t')
print(df.shape)
df.head()
206/31: plt.scatter(df.x, df.y);
206/32:
binx = np.linspace(df.x.min(), df.x.max(), 31)
biny = np.linspace(df.y.min(), df.y.max(), 31)

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

ret = stats.binned_statistic_2d(binx, biny) 

sns.heatmap(ret.statistic);
206/33:
binx = np.linspace(df.x.min(), df.x.max(), 31)
biny = np.linspace(df.y.min(), df.y.max(), 31)

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

ret = stats.binned_statistic_2d(df.x, df.y,None,'count',bins=[binx, biny]) 

sns.heatmap(ret.statistic);
206/34:
binx = np.linspace(df.x.min(), df.x.max(), 31)
biny = np.linspace(df.y.min(), df.y.max(), 31)

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

ret = stats.binned_statistic_2d(df.x, df.y,None,'count',bins=[binx, biny]) 

import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(10,10))         # Sample figsize in inches
sns.heatmap(ret.statistic, annot=True, linewidths=.5, ax=ax)

# sns.heatmap(ret.statistic);
206/35:
binx = np.linspace(df.x.min(), df.x.max(), 31)
biny = np.linspace(df.y.min(), df.y.max(), 31)

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

ret = stats.binned_statistic_2d(df.x, df.y,None,'count',bins=[binx, biny]) 

import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(10,10))         # Sample figsize in inches
sns.heatmap(ret.statistic, annot=True, linewidths=.5, ax=ax)
fig.show()
# sns.heatmap(ret.statistic);
206/36:
binx = np.linspace(df.x.min(), df.x.max(), 31)
biny = np.linspace(df.y.min(), df.y.max(), 31)

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

ret = stats.binned_statistic_2d(df.x, df.y,None,'count',bins=[binx, biny]) 

import matplotlib.pyplot as plt

 plt.figure(figsize=(16,5))        # Sample figsize in inches
# sns.heatmap(ret.statistic, annot=True, linewidths=.5, ax=ax)
# fig.show()
# sns.heatmap(ret.statistic);
206/37:
binx = np.linspace(df.x.min(), df.x.max(), 31)
biny = np.linspace(df.y.min(), df.y.max(), 31)

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

ret = stats.binned_statistic_2d(df.x, df.y,None,'count',bins=[binx, biny]) 

import matplotlib.pyplot as plt

 plt.figure(figsize=(16,5))        # Sample figsize in inches
# sns.heatmap(ret.statistic, annot=True, linewidths=.5, ax=ax)
# fig.show()
sns.heatmap(ret.statistic);
206/38:
binx = np.linspace(df.x.min(), df.x.max(), 31)
biny = np.linspace(df.y.min(), df.y.max(), 31)

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

ret = stats.binned_statistic_2d(df.x, df.y,None,'count',bins=[binx, biny]) 

import matplotlib.pyplot as plt

plt.figure(figsize=(16,5))        # Sample figsize in inches
# sns.heatmap(ret.statistic, annot=True, linewidths=.5, ax=ax)
# fig.show()
sns.heatmap(ret.statistic);
206/39:
binx = np.linspace(df.x.min(), df.x.max(), 31)
biny = np.linspace(df.y.min(), df.y.max(), 31)

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

ret = stats.binned_statistic_2d(df.x, df.y,None,'count',bins=[binx, biny]) 

import matplotlib.pyplot as plt

plt.figure(figsize=(16,16))        # Sample figsize in inches
# sns.heatmap(ret.statistic, annot=True, linewidths=.5, ax=ax)
# fig.show()
sns.heatmap(ret.statistic);
206/40:
binx = np.linspace(df.x.min(), df.x.max(), 31)
biny = np.linspace(df.y.min(), df.y.max(), 31)

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

ret = stats.binned_statistic_2d(df.x, df.y,None,'count',bins=[binx, biny]) 

import matplotlib.pyplot as plt

plt.figure(figsize=(16,16));
sns.heatmap(ret.statistic);
206/41:
binx = np.linspace(df.x.min(), df.x.max(), 31)
biny = np.linspace(df.y.min(), df.y.max(), 31)

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

ret = stats.binned_statistic_2d(df.x, df.y,None,'count',bins=[binx, biny]) 

import matplotlib.pyplot as plt

# plt.figure(figsize=(1,16));
sns.heatmap(ret.statistic);
206/42:
binx = np.linspace(df.x.min(), df.x.max(), 31)
biny = np.linspace(df.y.min(), df.y.max(), 31)

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

ret = stats.binned_statistic_2d(df.x, df.y,None,'count',bins=[binx, biny]) 

import matplotlib.pyplot as plt

plt.figure(figsize=(10, 8));
sns.heatmap(ret.statistic);
206/43:
binx = np.linspace(df.x.min(), df.x.max(), 31)
biny = np.linspace(df.y.min(), df.y.max(), 31)

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

ret = stats.binned_statistic_2d(df.x, df.y,None,'count',bins=[binx, biny]) 

import matplotlib.pyplot as plt

# plt.figure(figsize=(10, 8));
sns.heatmap(ret.statistic);
206/44:
binx = np.linspace(df.x.min(), df.x.max(), 31)
biny = np.linspace(df.y.min(), df.y.max(), 31)

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

ret = stats.binned_statistic_2d(df.x, df.y,None,'count',bins=[binx, biny]) 

import matplotlib.pyplot as plt

plt.figure(figsize=(10, 8));
sns.heatmap(ret.statistic);
206/45:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = np.array([ret.x_edge, ret.y_edge])
z
206/46:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=z, x='Happiness Score', bins=9, kde=True);
206/47:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=z,bins=9, kde=True);
206/48:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=z, bins=9, kde=True);
z
206/49:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=z, bins=9, kde=True);
ret.x_edge
206/50:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=z, bins=9, kde=True);
ret.statistic
206/51:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=ret.statistic, bins=9, kde=True);
ret.statistic
206/52:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=ret.statistic, bins=9, kde=True);
# ret.statistic
206/53:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z =pd.concat([ret.x_edge, x_eur], axis=0, keys=['x', 'y'])
# np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=ret.statistic, bins=9, kde=True);
# ret.statistic
206/54:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z =pd.concat([ret.x_edge, ret.y_edge], axis=0, keys=['x', 'y'])
# np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=z, bins=9, kde=True);
# ret.statistic
206/55:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = pd.concat([pd.DataFrame(ret.x_edge), pd.DataFrame(ret.y_edge)], axis=0, keys=['x', 'y'])
# np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=z, bins=9, kde=True);
# ret.statistic
206/56:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = pd.concat([pd.DataFrame(ret.x_edge), pd.DataFrame(ret.y_edge)], axis=0, keys=['x', 'y'])
# np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=z, bins=9, kde=True);
z
206/57:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = pd.concat([pd.DataFrame(ret.x_edge), pd.DataFrame(ret.y_edge)], axis=1, keys=['x', 'y'])
# np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=z, bins=9, kde=True);
z
206/58:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = pd.concat([pd.DataFrame(ret.x_edge), pd.DataFrame(ret.y_edge)], axis=1, keys=['x', 'y']).reset_index()
# np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=z, bins=9, kde=True);
z
206/59:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = pd.concat([pd.DataFrame(ret.x_edge).reset_index(), pd.DataFrame(ret.y_edge).reset_index()], axis=1, keys=['x', 'y'])
# np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=z, bins=9, kde=True);
z
206/60:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = pd.concat([pd.DataFrame(ret.x_edge)[1], pd.DataFrame(ret.y_edge)], axis=1, keys=['x', 'y'])
# np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=z, bins=9, kde=True);
z
206/61:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = ret.statistic
# np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=z, bins=9, kde=True);
z
206/62:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = ret.statistic
# np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=z kde=True);
206/63:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = ret.statistic
# np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=z);
206/64:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = ret.statistic
# np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=zб  kde=True,);
206/65:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = ret.statistic
# np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=z,  kde=True);
206/66:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = ret.statistic
# np.array([ret.x_edge, ret.y_edge])
sns.histplot(data=z,  kde=False);
206/67:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = ret.statistic
# sns.histplot(data=z, kde=False);
ret.binnumber
206/68:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = ret.binnumber
sns.histplot(data=z, kde=False);
# ret.binnumber
206/69:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = ret.binnumber
sns.histplot(data=z, kde=True);
# ret.binnumber
206/70:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = ret.binnumber
sns.histplot(data=z, bins=3, kde=True);
# ret.binnumber
206/71:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = ret.binnumber
sns.histplot(data=z, kde=True);
# ret.binnumber
206/72:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = ret.binnumber
sns.histplot(data=z, kde=True);
207/1:
import numpy as np
import pandas as pd

from scipy import stats as sts
from scipy import stats
import statsmodels as sts

import seaborn as sns
import matplotlib.pyplot as plt
from statsmodels.stats.weightstats import ttest_ind
from statsmodels.stats.descriptivestats import sign_test
from scipy.stats import chisquare

plt.style.use('ggplot')
207/2:
df = pd.read_csv('./data/london_07-09-1940.tsv', sep='\t')
print(df.shape)
df.head()
207/3: plt.scatter(df.x, df.y);
207/4:
binx = np.linspace(df.x.min(), df.x.max(), 31)
biny = np.linspace(df.y.min(), df.y.max(), 31)

### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

ret = stats.binned_statistic_2d(df.x, df.y,None,'count',bins=[binx, biny]) 

import matplotlib.pyplot as plt

plt.figure(figsize=(10, 8));
sns.heatmap(ret.statistic);
207/5:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = ret.binnumber
sns.histplot(data=z, kde=True);
207/6:
qs = z
E_ = []
O_ = []

for i in range(len(qs)-1):
    a,b = qs[i], qs[i+1]
    prob = stats.expon.cdf(b, scale=scale_mle) - stats.expon.cdf(a, scale=scale_mle)
    E = n*prob # expected
    O = sum([a<x<=b for x in X]) # observed
    
    print(f'P({a:.3f} ≤ X < {b:.3f}) \t= {prob:.3f}, \t Expected={E:.1f}, \t Observed={O}')
    
    E_.append(E)
    O_.append(O)

E_ = np.array(E_)
O_ = np.array(O_)

assert O_.sum() == n
207/7:
qs = z
z_mean = z.mean()

E_ = []
O_ = []

for i in range(len(qs)-1):
    a,b = qs[i], qs[i+1]
    prob = stats.expon.cdf(b, scale=z_mean) - stats.expon.cdf(a, scale=z_mean)
    E = n*prob # expected
    O = sum([a<x<=b for x in X]) # observed
    
    print(f'P({a:.3f} ≤ X < {b:.3f}) \t= {prob:.3f}, \t Expected={E:.1f}, \t Observed={O}')
    
    E_.append(E)
    O_.append(O)

E_ = np.array(E_)
O_ = np.array(O_)

assert O_.sum() == n
207/8:
qs = z
z_mean = z.mean()
s = len(z)

E_ = []
O_ = []

for i in range(len(qs)-1):
    a,b = qs[i], qs[i+1]
    prob = stats.expon.cdf(b, scale=z_mean) - stats.expon.cdf(a, scale=z_mean)
    E = n*prob # expected
    O = sum([a<x<=b for x in X]) # observed
    
    print(f'P({a:.3f} ≤ X < {b:.3f}) \t= {prob:.3f}, \t Expected={E:.1f}, \t Observed={O}')
    
    E_.append(E)
    O_.append(O)

E_ = np.array(E_)
O_ = np.array(O_)

assert O_.sum() == n
207/9:
qs = z
z_mean = z.mean()
n = len(z)

E_ = []
O_ = []

for i in range(len(qs)-1):
    a,b = qs[i], qs[i+1]
    prob = stats.expon.cdf(b, scale=z_mean) - stats.expon.cdf(a, scale=z_mean)
    E = n*prob # expected
    O = sum([a<x<=b for x in X]) # observed
    
    print(f'P({a:.3f} ≤ X < {b:.3f}) \t= {prob:.3f}, \t Expected={E:.1f}, \t Observed={O}')
    
    E_.append(E)
    O_.append(O)

E_ = np.array(E_)
O_ = np.array(O_)

assert O_.sum() == n
207/10:
qs = z
z_mean = z.mean()
n = len(z)

E_ = []
O_ = []

for i in range(len(qs)-1):
    a,b = qs[i], qs[i+1]
    prob = stats.expon.cdf(b, scale=z_mean) - stats.expon.cdf(a, scale=z_mean)
    E = n*prob # expected
    O = sum([a<x<=b for x in z]) # observed
    
    print(f'P({a:.3f} ≤ X < {b:.3f}) \t= {prob:.3f}, \t Expected={E:.1f}, \t Observed={O}')
    
    E_.append(E)
    O_.append(O)

E_ = np.array(E_)
O_ = np.array(O_)

assert O_.sum() == n
207/11:
qs = z
z_mean = z.mean()
n = len(z)

E_ = []
O_ = []

for i in range(len(qs)-1):
    a,b = qs[i], qs[i+1]
    prob = stats.expon.cdf(b, scale=z_mean) - stats.expon.cdf(a, scale=z_mean)
    E = n*prob # expected
    O = sum([a<x<=b for x in z]) # observed
    
#     print(f'P({a:.3f} ≤ X < {b:.3f}) \t= {prob:.3f}, \t Expected={E:.1f}, \t Observed={O}')
    
    E_.append(E)
    O_.append(O)

E_ = np.array(E_)
O_ = np.array(O_)

assert O_.sum() == n
207/12:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below


# T = 
chisquare(O_, f_exp=E_, ddof=1)
207/13:
X = np.array(z)
scale_mle = X.mean()
n = X.size

sns.histplot(X, stat='density', label='empirical', bins=10, kde=True);

xs = np.arange(X.min(),X.max(),0.1)
plt.plot(xs, stats.expon.pdf(xs, scale=scale_mle), 'red', label='theoretical');
plt.legend()
plt.show()
207/14:
import numpy as np
import pandas as pd

from scipy import stats as sts
from scipy import stats
import statsmodels as sts

import seaborn as sns
import matplotlib.pyplot as plt
from statsmodels.stats.weightstats import ttest_ind
from statsmodels.stats.descriptivestats import sign_test
from scipy.stats import chisquare
from scipy.stats import poisson


plt.style.use('ggplot')
207/15:

z_mean = z.mean()
z_size = z.size
expected_prob = np.array([poisson.pmf([0,1,2,3,4,5,6], z_mean)])
207/16:

z_mean = z.mean()
z_size = z.size
expected_prob = np.array([poisson.pmf([0,1,2,3,4,5,6], z_mean)])
expected_prob
207/17:

z_mean = z.mean()
z_size = z.size
expected_prob = np.array([poisson.pmf([0,1,2,3,4,5,6], z_mean)])
z_size
207/18:

z_mean = z.mean()
z_size = z.size
expected_prob = np.array([for x in z poisson.cdf(k, z.mean()]))
z_size
207/19:
# poisson.cdf(k, z.mean())
z_mean = z.mean()
z_size = z.size
expected_prob = np.array([x for x in z ]))
expected_prob
207/20:
# poisson.cdf(k, z.mean())
z_mean = z.mean()
z_size = z.size
expected_prob = np.array([x for x in z ])
expected_prob
207/21: z
207/22:
# poisson.cdf(k, z.mean())
z_mean = z.mean()
z_size = z.size
expected_prob = np.array([poisson.cdf(k, z_mean) for k in z ])
expected_prob
207/23:
z_mean = z.mean()
z_size = z.size
expected_prob = np.array([poisson.cdf(k, z_mean) for k in z ])
207/24:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z_mean = z.mean()
n = z.size

T = np.sum((z - n*expected_prob)**2 / (n*expected_prob))


chisquare(observed_cnts, f_exp=n*expected_prob)
207/25:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z_mean = z.mean()
n = z.size

T = np.sum((z - n*expected_prob)**2 / (n*expected_prob))


chisquare(z, f_exp=n*expected_prob)
207/26: 1 - stats.chi2.cdf(T, df=n-1)
207/27:
# проверка того, что задание решено верно
assert T > 6000
207/28: T
207/29: '{:f}'.format(T)
207/30:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z_mean = z.mean()
n = z.size

T, pvalue = np.sum((z - n*expected_prob)**2 / (n*expected_prob))


chisquare(z, f_exp=n*expected_prob)
207/31:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z_mean = z.mean()
n = z.size

T = np.sum((z - n*expected_prob)**2 / (n*expected_prob))


chisquare(z, f_exp=n*expected_prob)
207/32:
# проверка того, что задание решено верно
assert T > 6000
207/33:
chi2_crit = stats.chi2.ppf(0.95, df=n-1)
chi2_crit
207/34:
z_mean = z.mean()
expected_prob = np.array([poisson.cdf(k, z_mean) for k in z ])
expected_prob
207/35:
z_mean = z.mean()
expected_prob = np.array([poisson.cdf(k, z_mean) for k in z ])

'{:f}'.format(4.23908887e-008)
207/36: T
207/37:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z_mean = z.mean()
n = z.size

T = np.sum((z - n*expected_prob)**2 / (n*expected_prob))

T_krit, pval = chisquare(z, f_exp=n*expected_prob)
207/38: T > T_krit
207/39: T < T_krit
207/40: T < T_krit
207/41: T < T_krit
207/42: T > T_krit
207/43:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z_mean = z.mean()
n = z.size

T = np.sum((z - n*expected_prob)**2 / (n*expected_prob))

T_krit, pval = chisquare(z, f_exp=n*expected_prob)
print(T_krit)
207/44:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z_mean = z.mean()
n = z.size

T = np.sum((z - n*expected_prob)**2 / (n*expected_prob))

T_krit, pval = chisquare(z, f_exp=n*expected_prob)
print(T_krit, )T
207/45:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z_mean = z.mean()
n = z.size

T = np.sum((z - n*expected_prob)**2 / (n*expected_prob))

T_krit, pval = chisquare(z, f_exp=n*expected_prob)
print(T_krit, T)
207/46: T = T_krit
207/47:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z_mean = z.mean()
n = z.size

df = n - 1 - 1

T = np.sum((z - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit


T_krit, pval = chisquare(z, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/48: z
207/49:
u, c = np.unique(z, return_counts=True)
dup = u[c > 1]
207/50:
u, c = np.unique(z, return_counts=True)
dup = u[c > 1]
dup
207/51:
u, c = np.unique(z, return_counts=True)
dup = u[c > 1]
u
207/52:
u, c = np.unique(z, return_counts=True)
dup = u[c > 1]
c
207/53:
u, c = np.unique(z, return_counts=True)
dup = u[c > 1]
c
207/54:
u, c = np.unique(z, return_counts=True)
dup = u[c > 1]
u
207/55: c
207/56:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = ret.binnumber
sns.histplot(data=c, kde=True);
207/57:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = ret.binnumber
u, c = np.unique(z, return_counts=True)

sns.histplot(data=c, kde=True);
207/58: u
207/59:
# Chi-square approach bins
# Use quintiles of the hypothetical Poisson
df = pd.DataFrame(z,columns=['counts'])
df['quantile'] = poisson.cdf(obs.mean(),obs)
df['quin'] = np.floor(df['quantile']/0.2)

obs_counts = df['quin'].value_counts()
exp_counts = len(obs)/5
chi_stat = ((obs_counts - exp_counts)**2/exp_counts).sum()
207/60:
# Chi-square approach bins
# Use quintiles of the hypothetical Poisson
obs = z
df = pd.DataFrame(obs,columns=['counts'])
df['quantile'] = poisson.cdf(obs.mean(),obs)
df['quin'] = np.floor(df['quantile']/0.2)

obs_counts = df['quin'].value_counts()
exp_counts = len(obs)/5
chi_stat = ((obs_counts - exp_counts)**2/exp_counts).sum()
207/61:
# Chi-square approach bins
# Use quintiles of the hypothetical Poisson
obs = z
df = pd.DataFrame(obs,columns=['counts'])
df['quantile'] = poisson.cdf(obs.mean(),obs)
df['quin'] = np.floor(df['quantile']/0.2)

obs_counts = df['quin'].value_counts()
exp_counts = len(obs)/5
chi_stat = ((obs_counts - exp_counts)**2/exp_counts).sum()

chi_stat
207/62:
# Chi-square approach bins
# Use quintiles of the hypothetical Poisson
obs = z
df = pd.DataFrame(obs,columns=['counts'])
df['quantile'] = poisson.cdf(obs.mean(),obs)
df['quin'] = np.floor(df['quantile']/0.2)

obs_counts = df['quin'].value_counts()
exp_counts = len(obs)/5
chi_stat = ((obs_counts - exp_counts)**2/exp_counts).sum()

df
207/63: u.size
207/64: z.size
207/65:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = ret.binnumber
s, v = np.unique(z, return_counts=True)

sns.histplot(data=s, kde=True);
207/66:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

z = ret.binnumber
s, v = np.unique(z, return_counts=True)

sns.histplot(data=v, kde=True);
207/67: z.size
207/68: v
207/69: s
207/70:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

mu = z.mean()
n = s.size
expected_prob = np.array([poisson.cdf(k, mu) for k in v])

print(expected_prob)

# df = n - 1 - 1

T = np.sum((z - n*expected_prob)**2 / (n*expected_prob))

# chi2_crit = stats.chi2.ppf(0.95, df)
# chi2_crit


T_krit, pval = chisquare(z, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/71:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

mu = z.mean()
n = s.size
expected_prob = np.array([poisson.cdf(k, mu) for k in v])

# print(expected_prob)

# df = n - 1 - 1

T = np.sum((z - n*expected_prob)**2 / (n*expected_prob))

# chi2_crit = stats.chi2.ppf(0.95, df)
# chi2_crit


T_krit, pval = chisquare(z, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/72:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

mu = z.mean()
n = s.size
expected_prob = np.array([poisson.cdf(k, mu) for k in v])

# print(expected_prob)

# df = n - 1 - 1

T = np.sum((v - n*expected_prob)**2 / (n*expected_prob))

# chi2_crit = stats.chi2.ppf(0.95, df)
# chi2_crit


T_krit, pval = chisquare(z, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/73:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

mu = z.mean()
n = s.size
expected_prob = np.array([poisson.cdf(k, mu) for k in v])

# print(expected_prob)

# df = n - 1 - 1

T = np.sum((v - n*expected_prob)**2 / (n*expected_prob))

# chi2_crit = stats.chi2.ppf(0.95, df)
# chi2_crit


T_krit, pval = chisquare(v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/74:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

mu = z.mean()
n = s.size
expected_prob = np.array([poisson.cdf(k, mu) for k in v])

# print(expected_prob)

# df = n - 1 - 1

T = np.sum((v - n*expected_prob)**2 / (n*expected_prob))

# chi2_crit = stats.chi2.ppf(0.95, df)
# chi2_crit


T_krit, pval = chisquare(v, f_exp=n*expected_prob)
print(T_krit, T)
# print(chi2_crit)
207/75:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

mu = z.mean()
n = s.size
expected_prob = np.array([poisson.cdf(k, mu) for k in v])


df = n - 1 - 1

T = np.sum((v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit


T_krit, pval = chisquare(v, f_exp=n*expected_prob)
print(T_krit, T)
# print(chi2_crit)
207/76:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

mu = z.mean()
n = s.size
expected_prob = np.array([poisson.cdf(k, mu) for k in v])


df = n - 1 - 1

T = np.sum((v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit


T_krit, pval = chisquare(v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/77:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

mu = z.mean()
n = s.size
expected_prob = np.array([poisson.cdf(k, mu) for k in v])
print('mu', mu)

df = n - 1 - 1

T = np.sum((v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit


T_krit, pval = chisquare(v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/78:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

mu = sum(s + v)/n
n = s.size
expected_prob = np.array([poisson.cdf(k, mu) for k in v])
print('mu', mu)

df = n - 1 - 1

T = np.sum((v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit


T_krit, pval = chisquare(v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/79:
# проверка того, что задание решено верно
assert T > 6000
207/80:
T > chi2_crit
# отвергаем гипотезу о равновероятности числе в числе пи
207/81: v
207/82:
for ixd, value in enumerate(v):
    print(idx)
207/83:
for ixd, value in numpy.ndenumerate(v):
    print(idx)
207/84:
for ixd, value in np.ndenumerate(v):
    print(idx)
207/85:
for ixd, value in np.ndenumerate(v):
    print(idx)
207/86:
for ixd, value in np.ndenumerate(v):
    print(idx)
207/87:
for idx, value in np.ndenumerate(v):
    print(idx)
207/88:
for idx, value in np.ndenumerate(v):
    print(value)
207/89:
reduced_v = np.array([])
reduced_s = np.array([])
for idx, value in np.ndenumerate(v):
    if value > 8:
        np.append(reduced_v, value)
        np.append(reduced_s, s[ids])
207/90:
reduced_v = np.array([])
reduced_s = np.array([])
for idx, value in np.ndenumerate(v):
    if value > 8:
        np.append(reduced_v, value)
        np.append(reduced_s, s[idx])
207/91: reduced_v
207/92: reduced_s
207/93:
reduced_v = np.array()
reduced_s = np.array()
for idx, value in np.ndenumerate(v):
    if value > 8:
        np.append(reduced_v, value)
        np.append(reduced_s, s[idx])
207/94:
reduced_v = np.array([])
reduced_s = np.array([])
for idx, value in np.ndenumerate(v):
    if value > 8:
        np.append(reduced_v, value)
        np.append(reduced_s, s[idx])
207/95:
reduced_v = np.array([])
reduced_s = np.array([])
for idx, value in np.ndenumerate(v):
    if value > 8:
        print(value)
        np.append(reduced_v, value)
        np.append(reduced_s, s[idx])
207/96:
reduced_v = np.array([])
reduced_s = np.array([])
for idx, value in np.ndenumerate(v):
    if value > 8:
        print(s[idx])
        np.append(reduced_v, value)
        np.append(reduced_s, s[idx])
207/97:
reduced_v = np.array([])
reduced_s = np.array([])
for idx, value in np.ndenumerate(v):
    if value > 8:
        np.append(reduced_v, value)
        np.append(reduced_s, s[idx])
207/98: reduced_s
207/99:
reduced_v = np.array([])
reduced_s = np.array([])
for idx, value in np.ndenumerate(v):
    if value > 8:
        np.append(reduced_v, value, axis=0)
        np.append(reduced_s, s[idx])
207/100:
reduced_v = np.array([])
reduced_s = np.array([])
for idx, value in np.ndenumerate(v):
    if value > 8:
        np.append(reduced_v, value, axis=1)
        np.append(reduced_s, s[idx])
207/101:
reduced_v = np.array([])
reduced_s = np.array([])
for idx, value in np.ndenumerate(v):
    if value > 8:
        np.append(reduced_v, value)
        np.append(reduced_s, s[idx])
207/102: reduced_s
207/103:
reduced_v = []
reduced_s =[]
for idx, value in np.ndenumerate(v):
    if value > 8:
        reduced_v.append(value)
        reduced_s.append(s[idx])
207/104: reduced_s
207/105: np.array(reduced_s)
207/106:
np.array(reduced_s)
np.array(reduced_v)
207/107:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = sum(reduced_s + reduced_v)/n

expected_prob = np.array([poisson.cdf(k, mu) for k in v])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/108:
np.array(reduced_s)
np.array(reduced_v)
207/109:
np.array(reduced_s)
np.array(reduced_v).size
207/110:
reduced_s = np.array(reduced_s)
reduced_v = np.array(reduced_v)
207/111:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = sum(reduced_s + reduced_v)/n

expected_prob = np.array([poisson.cdf(k, mu) for k in v])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/112:
reduced_s = np.array(reduced_s)
reduced_v = np.array(reduced_v)
print(reduced_v.size)
print(reduced_s.size)
207/113:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = sum(reduced_s + reduced_v)/n

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_v])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/114:
T > chi2_crit
# отвергаем гипотезу о распределении
207/115:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_v])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/116:
reduced_s = np.array(reduced_s)
reduced_v = np.array(reduced_v)
print(reduced_v.size)
print(reduced_s.size)
print(v.size)
207/117:
s, v = np.unique(z, return_counts=True)
s
207/118:
s, v = np.unique(z, return_counts=True)
v
207/119:
s, v = np.unique(z, return_counts=True)
v.size()
207/120:
s, v = np.unique(z, return_counts=True)
v.size
207/121:
s, v = np.unique(z, return_counts=True)
v
207/122:
s, v = np.unique(z, return_counts=True)
s
207/123:
reduced_v = []
reduced_s =[]
for idx, value in np.ndenumerate(v):
    if value <= 8:
        reduced_v.append(value)
        reduced_s.append(s[idx])
207/124:
reduced_s = np.array(reduced_s)
reduced_v = np.array(reduced_v)
print(reduced_v.size)
print(reduced_s.size)
print(v.size)
207/125:
reduced_s = np.array(reduced_s)
reduced_v = np.array(reduced_v)
print(reduced_v.size)
print(reduced_s.size)
print(s)
207/126:
reduced_s = np.array(reduced_s)
reduced_v = np.array(reduced_v)
print(reduced_v.size)
print(reduced_s.size)
print(v)
207/127:
reduced_s = np.array(reduced_s)
reduced_v = np.array(reduced_v)
print(reduced_v.size)
print(reduced_s.size)
print(reduced_v)
207/128:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_v])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/129:
# проверка того, что задание решено верно
assert T > 6000
207/130: '{:f}'.format(T)
207/131:
reduced_v = []
reduced_s = []
remainder = []
for idx, value in np.ndenumerate(v):
    if value <= 8:
        reduced_v.append(value)
        reduced_s.append(s[idx])
    else
        remainder.append(s[idx])
207/132:
reduced_v = []
reduced_s = []
remainder = []
for idx, value in np.ndenumerate(v):
    if value <= 8:
        reduced_v.append(value)
        reduced_s.append(s[idx])
    else:
        remainder.append(s[idx])
207/133:
reduced_s = np.array(reduced_s)
reduced_v = np.array(reduced_v)
reduced_v.append(9)
print(reduced_v.size)
print(reduced_s.size)
print(reduced_v)
207/134:
reduced_s = np.array(reduced_s)
reduced_v = np.array(reduced_v)
np.append(reduced_v, 9)
print(reduced_v.size)
print(reduced_s.size)
print(reduced_v)
207/135:
reduced_s = np.array(reduced_s)
reduced_v = np.array(reduced_v)
np.append(reduced_v, [9])
print(reduced_v.size)
print(reduced_s.size)
print(reduced_v)
207/136:
# reduced_s = np.array(reduced_s)
# reduced_v = np.array(reduced_v)

# print(reduced_v.size)
# print(reduced_s.size)
# print(reduced_v)

print(remainder)
207/137:
# reduced_s = np.array(reduced_s)
# reduced_v = np.array(reduced_v)

# print(reduced_v.size)
# print(reduced_s.size)
# print(reduced_v)

print(sum(remainder))
207/138:
reduced_v = []
reduced_s = []
remainder = []
for idx, value in np.ndenumerate(v):
    if value <= 8:
        reduced_v.append(value)
        reduced_s.append(s[idx])
    else:
        remainder.append(s[idx])

reduced_v.append(9)
reduced_s.append(sum(remainder))
207/139:
reduced_s = np.array(reduced_s)
reduced_v = np.array(reduced_v)

print(reduced_v.size)
print(reduced_s.size)
print(reduced_v)
207/140:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_v.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_v])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/141:
T > chi2_crit
# отвергаем гипотезу о распределении Пуасоона
207/142: '{:f}'.format(T)
207/143:
# проверка того, что задание решено верно
assert T > 6000
207/144:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_v.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_s])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/145:
reduced_v = []
reduced_s = []
remainder = []
for idx, value in np.ndenumerate(v):
    if value <= 8:
        reduced_v.append(value)
        reduced_s.append(s[idx])
    else:
        remainder.append(s[idx])

reduced_v.append(9)
reduced_s.append
207/146:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_v.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_v])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/147:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_v.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_v])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/148:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_v])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/149:
reduced_s = np.array(reduced_s)
reduced_v = np.array(reduced_v)

print(reduced_v.size)
print(reduced_s.size)
print(reduced_v)
207/150:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_v])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/151:
reduced_v = []
reduced_s = []
remainder = []
for idx, value in np.ndenumerate(v):
    if value <= 8:
        reduced_v.append(value)
        reduced_s.append(s[idx])
    else:
        remainder.append(s[idx])

reduced_v.append(9)
reduced_s.append(sum(remainder))
207/152:
reduced_s = np.array(reduced_s)
reduced_v = np.array(reduced_v)

print(reduced_v.size)
print(reduced_s.size)
print(reduced_v)
207/153:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_v])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/154:
T > chi2_crit
# отвергаем гипотезу о распределении Пуасоона и низкоточной стрельбе
207/155:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
207/156:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
207/157: df[['before', 'After']].hist(bins=15, figsize=(15,4));
207/158: df['before', 'After'].hist(bins=15, figsize=(15,4));
207/159: df['before'].hist(bins=15, figsize=(15,4));
207/160:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
207/161: df['before'].hist(bins=15, figsize=(15,4));
207/162:

sns.histplot(df.before, stat='density', kde=True)
207/163: df['Before', 'After'].hist(bins=15, figsize=(15,4));
207/164: df[['Before', 'After']].hist(bins=15, figsize=(15,4));
207/165: df[['Before', 'After']].hist(bins=10, figsize=(15,4));
207/166:
# Проверим на нормальность каждую выборку критерием Пирсона, тк у нас дискретное рапределение

# Н_0: выборка из норм распредления
# Н_1 не принадлежит норм распределению

scipy.stats.norm(loc=100, scale=12)
207/167:
import numpy as np
import pandas as pd

from scipy import stats as sts
from scipy import stats
import statsmodels as sts

import seaborn as sns
import matplotlib.pyplot as plt
from statsmodels.stats.weightstats import ttest_ind
from statsmodels.stats.descriptivestats import sign_test
from scipy.stats import chisquare
from scipy.stats import poisson


plt.style.use('ggplot')
207/168:
# Проверим на нормальность каждую выборку критерием Пирсона, тк у нас дискретное рапределение

# Н_0: выборка из норм распредления
# Н_1 не принадлежит норм распределению

scipy.stats.norm(loc=100, scale=12)
207/169:
# Проверим на нормальность каждую выборку критерием Пирсона, тк у нас дискретное рапределение

# Н_0: выборка из норм распредления
# Н_1 не принадлежит норм распределению

stats.norm(loc=100, scale=12)
207/170:
# Проверим на нормальность каждую выборку критерием Пирсона, тк у нас дискретное рапределение

# Н_0: выборка из норм распредления
# Н_1 не принадлежит норм распределению

res = stats.norm(loc=100, scale=12)
print(res)
207/171:
# Проверим на нормальность каждую выборку критерием Пирсона, тк у нас дискретное рапределение

# Н_0: выборка из норм распредления
# Н_1 не принадлежит норм распределению

scipy.stats.norm.cdf(113,100,12)
207/172:
# Проверим на нормальность каждую выборку критерием Пирсона, тк у нас дискретное рапределение

# Н_0: выборка из норм распредления
# Н_1 не принадлежит норм распределению

stats.norm.cdf(113,100,12)
207/173: poisson.cdf(k, mu)
207/174: poisson.cdf(0, 0.527)
207/175:
s, v = np.unique(z, return_counts=True)
s
207/176: s
207/177:
reduced_s = np.array(reduced_s)
reduced_v = np.array(reduced_v)

print(reduced_v.size)
print(reduced_s.size)
s, reduced_v = np.unique(reduced_v, return_counts=True)
print(reduced_v)
207/178:
s, v = np.unique(z, return_counts=True)
s
207/179:
reduced_v = []
reduced_s = []
remainder = []
for idx, value in np.ndenumerate(v):
    if value <= 8:
        reduced_v.append(value)
        reduced_s.append(s[idx])
    else:
        remainder.append(s[idx])

reduced_v.append(9)
reduced_s.append(sum(remainder))
207/180:
reduced_s = np.array(reduced_s)
reduced_v = np.array(reduced_v)

print(reduced_v.size)
print(reduced_s.size)
s, reduced_v = np.unique(reduced_v, return_counts=True)
print(reduced_v)
207/181:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_v])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/182:
s, v = np.unique(z, return_counts=True)
s
207/183:
reduced_v = []
reduced_s = []
remainder = []
for idx, value in np.ndenumerate(v):
    if value <= 8:
        reduced_v.append(value)
        reduced_s.append(s[idx])
    else:
        remainder.append(s[idx])

reduced_v.append(9)
reduced_s.append(sum(remainder))
207/184:
reduced_s = np.array(reduced_s)
reduced_v = np.array(reduced_v)

print(reduced_v.size)
print(reduced_s.size)
print(reduced_v)
207/185:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_v])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/186:
reduced_s = np.array(reduced_s)
reduced_v = np.array(reduced_v)

print(reduced_v.size)
print(reduced_s.size)
print(reduced_v)
print(reduced_s)
207/187:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_s])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/188:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_s])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/189:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_v])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/190: df[['Before', 'After']].hist(bins=20, figsize=(15,4));
207/191:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
207/192: df[['Before', 'After']].hist(bins=20, figsize=(15,4));
207/193:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_s])
df = n - 1 - 1

T = np.sum((reduced_s - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/194:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_s])
df = n - 1 - 1

T = np.sum((reduced_s - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_s, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/195:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_v])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/196:
reduced_s = np.array(reduced_s)
reduced_v = np.array(reduced_v)

print(reduced_v.size)
print(reduced_s.size)
print(reduced_v)
print(reduced_s)
207/197:
# Проверим на нормальность каждую выборку критерием Пирсона, тк у нас дискретное рапределение

# Н_0: выборка из норм распредления
# Н_1 не принадлежит норм распределению

s, v = np.unique(df.Before, return_counts=True)

n = df.Before.size
mu = df.Before.mean()
std = df.Before.var(ddof=1)

expected_prob = np.array([stats.norm.cdf(loc=mu,scale=std, k)for k in v])

df = n - 2 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/198:
# Проверим на нормальность каждую выборку критерием Пирсона, тк у нас дискретное рапределение

# Н_0: выборка из норм распредления
# Н_1 не принадлежит норм распределению

s, v = np.unique(df.Before, return_counts=True)

n = df.Before.size
mu = df.Before.mean()
std = df.Before.var(ddof=1)

expected_prob = np.array([stats.norm.cdf(mu,std,k) for k in v])

df = n - 2 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/199: s, v = np.unique(df.Before, return_counts=True)
207/200: df.Before
207/201: df.Before
207/202:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
207/203: df[['Before', 'After']].hist(bins=20, figsize=(15,4));
207/204: s, v = np.unique(df.Before, return_counts=True)
207/205:
# Проверим на нормальность каждую выборку критерием Пирсона, тк у нас дискретное рапределение

# Н_0: выборка из норм распредления
# Н_1 не принадлежит норм распределению

s, v = np.unique(df.Before, return_counts=True)

n = df.Before.size
mu = df.Before.mean()
std = df.Before.var(ddof=1)

expected_prob = np.array([stats.norm.cdf( mu,std,k) for k in v])

df = n - 2 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/206:
# Проверим на нормальность каждую выборку критерием Пирсона, тк у нас дискретное рапределение

# Н_0: выборка из норм распредления
# Н_1 не принадлежит норм распределению

s, v = np.unique(df.Before, return_counts=True)

n = df.Before.size
mu = df.Before.mean()
std = df.Before.var(ddof=1)

expected_prob = np.array([stats.norm.cdf( mu,std,k) for k in v])

df = n - 2 - 1

T = np.sum((v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/207:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
207/208: df[['Before', 'After']].hist(bins=20, figsize=(15,4));
207/209:
# Проверим на нормальность каждую выборку критерием Пирсона, тк у нас дискретное рапределение

# Н_0: выборка из норм распредления
# Н_1 не принадлежит норм распределению

s, v = np.unique(df.Before, return_counts=True)

n = df.Before.size
mu = df.Before.mean()
std = df.Before.var(ddof=1)

expected_prob = np.array([stats.norm.cdf( mu,std,k) for k in v])

df = n - 2 - 1

T = np.sum((v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/210:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
207/211:
# Проверим на нормальность каждую выборку критерием Пирсона, тк у нас дискретное рапределение

# Н_0: выборка из норм распредления
# Н_1 не принадлежит норм распределению

s, v = np.unique(df.Before, return_counts=True)

n = df.Before.size
mu = df.Before.mean()
std = df.Before.var(ddof=1)

expected_prob = np.array([stats.norm.cdf( mu,std,k) for k in v])

df = n - 2 - 1

T = np.sum((v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/212: df[['Before', 'After']].hist(bins=20,  stat='density' figsize=(15,4));
207/213: df[['Before', 'After']].hist(bins=20,  stat='density', figsize=(15,4));
207/214:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
207/215: df[['Before', 'After']].hist(bins=20,  stat='density', figsize=(15,4));
207/216: df[['Before', 'After']].hist(bins=20,  figsize=(15,4));
207/217:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_v])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
print('pval', pval)
207/218:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_v])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/219:
### ╰( ͡° ͜ʖ ͡° )つ▬▬ι═══════  bzzzzzzzzzz
# your code below

n = reduced_s.size
mu = z.mean()

expected_prob = np.array([poisson.cdf(k, mu) for k in reduced_v])
df = n - 1 - 1

T = np.sum((reduced_v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(reduced_v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
207/220:
T > chi2_crit
# отвергаем гипотезу о распределении Пуасоона и низкоточной стрельбе
207/221:
# проверка того, что задание решено верно
assert T > 6000
207/222:
# Проверим на нормальность каждую выборку критерием Пирсона, тк у нас дискретное рапределение

# Н_0: выборка из норм распредления
# Н_1 не принадлежит норм распределению

s, v = np.unique(df.Before, return_counts=True)

n = df.Before.size
mu = df.Before.mean()
std = df.Before.var(ddof=1)

expected_prob = np.array([stats.norm.cdf( mu,std,k) for k in v])

df = n - 2 - 1

T = np.sum((v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(v, f_exp=n*expected_prob)
print(T_krit, T)
print(chi2_crit)
print('pval', pval)
207/223:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
207/224:
# Проверим на нормальность первую выборку критерием Пирсона, тк у нас дискретное рапределение

# Н_0: выборка из норм распредления
# Н_1 не принадлежит норм распределению

s, v = np.unique(df.Before, return_counts=True)

n = df.Before.size
mu = df.Before.mean()
std = df.Before.var(ddof=1)

expected_prob = np.array([stats.norm.cdf( mu,std,k) for k in v])

df = n - 2 - 1

T = np.sum((v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(v, f_exp=n*expected_prob)
print(f'T {T} > chi2_crit {chi2_crit} => отвергаем гипотезу о нормальном распределении')
print('pval', pval)
207/225:
# Проверим на нормальность первую выборку критерием Пирсона, тк у нас дискретное рапределение

# Н_0: выборка из норм распредления
# Н_1 не принадлежит норм распределению

s, v = np.unique(df.Before, return_counts=True)

n = df.Before.size
mu = df.Before.mean()
std = df.Before.var(ddof=1)

expected_prob = np.array([stats.norm.cdf( mu,std,k) for k in v])

df = n - 2 - 1

T = np.sum((v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(v, f_exp=n*expected_prob)
print(f'T {T:.3} > chi2_crit {chi2_crit:.3} => отвергаем гипотезу о нормальном распределении')
print('pval', pval)
207/226:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
207/227:
# Проверим на нормальность первую выборку критерием Пирсона, тк у нас дискретное рапределение

# Н_0: выборка из норм распредления
# Н_1 не принадлежит норм распределению

s, v = np.unique(df.Before, return_counts=True)

n = df.Before.size
mu = df.Before.mean()
std = df.Before.var(ddof=1)

expected_prob = np.array([stats.norm.cdf( mu,std,k) for k in v])

df = n - 2 - 1

T = np.sum((v - n*expected_prob)**2 / (n*expected_prob))

chi2_crit = stats.chi2.ppf(0.95, df)
chi2_crit

T_krit, pval = chisquare(v, f_exp=n*expected_prob)
print(f'T {T:.3} > chi2_crit {chi2_crit:.3} => отвергаем гипотезу о нормальном распределении')
print('pval', pval)
207/228: v
207/229: df.describe()
207/230:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
207/231: df.describe()
207/232: sns.histplot(data=df, stat='density');
207/233:
# Ответим, на вопрос, была ли эффективна терапия
# Выборки связные, поэтому используем Критерий знаков и Уилкоксона

# H_0: P(After > Before) = 0.5
# H_1 P(After > Before) != 0.5

x = df.After
y = df.Before
_, pvalue = sign_test(x, y)
print(pvalue)
print('Гипотеза об о том, что уровень счастья не изменился, не отвергается.')'
207/234:
# Ответим, на вопрос, была ли эффективна терапия
# Выборки связные, поэтому используем Критерий знаков и Уилкоксона

# H_0: P(After > Before) = 0.5
# H_1 P(After > Before) != 0.5

x = df.After
y = df.Before
_, pvalue = sign_test(x, y)
print(pvalue)
print('Гипотеза об о том, что уровень счастья не изменился, не отвергается.')
207/235:
# Ответим, на вопрос, была ли эффективна терапия
# Выборки связные, поэтому используем Критерий знаков и Уилкоксона

# H_0: P(After > Before) = 0.5 в среднем терапия была неэффективна
# H_1 P(After > Before) > 0.5

x = df.After
y = df.Before
T_krit, pvalue = sign_test(x, y)
print(T_krit)
print(f'pvalue {pvalue} > 0.05 => гипотеза о том, что терапия была неэффективна,  не отвергается.')
207/236:
# Ответим, на вопрос, была ли эффективна терапия
# Выборки связные, поэтому используем Критерий знаков и Уилкоксона

# H_0: P(After > Before) = 0.5 в среднем терапия была неэффективна
# H_1 P(After > Before) > 0.5

x = df.After
y = df.Before
_, pvalue = sign_test(x, y)
print(f'pvalue {pvalue} > 0.05 => гипотеза о том, что терапия была неэффективна,  не отвергается.')
207/237:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
207/238:
# Ответим, на вопрос, была ли эффективна терапия
# Выборки связные, поэтому используем Критерий знаков и Уилкоксона

# H_0: P(After > Before) = 0.5 в среднем терапия была неэффективна
# H_1 P(After > Before) > 0.5

x = df.After
y = df.Before
_, pvalue = sign_test(x, y)
print(f'pvalue {pvalue} > 0.05 => гипотеза о том, что терапия была неэффективна,  не отвергается.')
207/239:
# Ответим, на вопрос, была ли эффективна терапия
# Выборки связные, поэтому используем Критерий знаков и Уилкоксона

# H_0: P(After > Before) = 0.5 в среднем терапия была неэффективна
# H_1 P(After > Before) > 0.5

x = df.After
y = df.Before
_, pvalue = sign_test(x, y)
print(f'pvalue {pvalue} > 0.05 => гипотеза о том, что терапия была неэффективна, не отвергается.')
207/240:
# H_0: Med(After - Before) = 0.5
# H_1 P(After > Before) != 0.5

stats.wilcoxon(x, y)
207/241:
# H_0: Med(After - Before) = 0.5
# H_1 P(After > Before) != 0.5

T, pvalue = stats.wilcoxon(x, y)
print(f'pvalue {pvalue} > 0.05 => гипотеза о том, что терапия была неэффективна, не отвергается.')
207/242:
df = pd.read_csv('./data/methylphenidate.txt', sep=' ')
df.head()
207/243: df[['EC', 'AE']].hist(bins=15, figsize=(15,4));
207/244: df[['Placebo', 'Methylphenidate']].hist(bins=15, figsize=(15,4));
207/245: df.describe()
207/246:
df = pd.read_csv('./data/seattle.txt', sep='\t')
df.head()
207/247:
df = pd.read_csv('./data/seattle.txt', sep='\t')
df.head(10)
207/248:
df = pd.read_csv('./data/seattle.txt', sep='\t')
df.head(100)
207/249:
df = pd.read_csv('./data/mtcars.csv', index_col=0)
df.head()
207/250: df[['Placebo', 'Methylphenidate']].hist(bins=25, figsize=(15,4));
207/251:
df = pd.read_csv('./data/methylphenidate.txt', sep=' ')
df.head()
207/252: df[['Placebo', 'Methylphenidate']].hist(bins=25, figsize=(15,4));
207/253:
# Ответим, на вопрос, была ли эффективна терапия
# Выборки связные, поэтому используем Критерий знаков и Уилкоксона

# H_0: P(Methylphenidate > Placebo) = 0.5 в среднем терапия эффекта не наблюдалось
# H_1 P(Methylphenidate > Placebo) != 0.5

x = df.Methylphenidate
y = df.Placebo
_, pvalue = sign_test(x, y)
print(f'pvalue {pvalue} > 0.05 => гипотеза о том, что терапия была неэффективна, не отвергается.')
207/254:
# H_0: Med(After - Before) = 0.5
# H_1 P(After > Before) != 0.5

T, pvalue = stats.wilcoxon(x, y)
print(f'pvalue {pvalue} > 0.05 => гипотеза о том, что терапия была неэффективна, не отвергается.')
207/255:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
207/256:
# Проверим гипотезу об однородности выборок
# посмотрим, что выдаст нам тест
from scipy.stats import chi2_contingency
chi, pvalue, df_, expected = chi2_contingency(df.values)

print(pvalue)
207/257:
df = pd.read_csv('./data/methylphenidate.txt', sep=' ')
df.head()
207/258:
# Ответим, на вопрос, была ли эффективна терапия
# Выборки связные, поэтому используем Критерий знаков и Уилкоксона

# H_0: P(Methylphenidate > Placebo) = 0.5 в среднем эффекта не наблюдалось
# H_1 P(Methylphenidate > Placebo) != 0.5

x = df.Methylphenidate
y = df.Placebo
_, pvalue = sign_test(x, y)
print(f'pvalue {pvalue} > 0.05 => гипотеза о том, что эффекта не наблюдалось, не отвергается.')
207/259:
# H_0: Med(After - Before) = 0.5
# H_1 P(After > Before) != 0.5

T, pvalue = stats.wilcoxon(x, y)
print(f'pvalue {pvalue} > 0.05 => гипотеза о том, что терапия была неэффективна, не отвергается.')
207/260:
# H_0: Med(After - Before) = 0.5
# H_1 P(After > Before) != 0.5

T, pvalue = stats.wilcoxon(x, y)
print(f'pvalue {pvalue} < 0.05 => гипотеза о том, что терапия была эффективна, не отвергается.')
207/261:
# Проверим гипотезу об однородности выборок
# посмотрим, что выдаст нам тест
from scipy.stats import chi2_contingency
chi, pvalue, df_, expected = chi2_contingency(df.values)

print(f'pvalue {pvalue} > 0.05 => гипотеза об однородности выборок не отвергается')
207/262: sns.histplot(data=df, stat='density');
207/263:
df = pd.read_csv('./data/methylphenidate.txt', sep=' ')
df.head()
207/264:
# Ответим, на вопрос, была ли эффективна терапия
# Выборки связные, поэтому используем Критерий знаков и Уилкоксона

# H_0: P(Methylphenidate > Placebo) = 0.5 в среднем эффекта не наблюдалось
# H_1 P(Methylphenidate > Placebo) != 0.5

x = df.Methylphenidate
y = df.Placebo
_, pvalue = sign_test(x, y)
print(f'pvalue {pvalue} > 0.05 => гипотеза о том, что эффекта не наблюдалось, не отвергается.')
207/265:
# H_0: Med(After - Before) = 0
# H_1 Med(After - Before) != 0

T, pvalue = stats.wilcoxon(x, y)
print(f'pvalue {pvalue} < 0.05 => гипотеза о том, что терапия была эффективна, не отвергается.')
207/266:
# Проверим гипотезу об однородности выборок
# посмотрим, что выдаст нам тест
from scipy.stats import chi2_contingency
chi, pvalue, df_, expected = chi2_contingency(df.values)

print(f'pvalue {pvalue} > 0.05 => гипотеза об однородности выборок не отвергается')
207/267: sns.boxplot(data=df);
207/268:
# Ответим, на вопрос, была ли эффективна терапия
# Выборки связные, поэтому используем Критерий знаков и Уилкоксона

# H_0: P(Methylphenidate > Placebo) = 0.5 в среднем эффекта не наблюдалось
# H_1 P(Methylphenidate > Placebo) != 0.5

x = df.Methylphenidate
y = df.Placebo
_, pvalue = sign_test(x, y)
print(f'pvalue {pvalue} > 0.05 => гипотеза о том, что эффекта не наблюдалось, отвергается.')
207/269:
# H_0: Med(After - Before) = 0
# H_1 Med(After - Before) != 0

T, pvalue = stats.wilcoxon(x, y)
print(f'pvalue {pvalue} < 0.05 => гипотеза о том, что эффекта не наблюдалось, не отвергается.')
207/270:
# H_0: Med(After - Before) = 0
# H_1 Med(After - Before) != 0

T, pvalue = stats.wilcoxon(x, y)
print(f'pvalue {pvalue} < 0.05 => гипотеза о том, что эффекта не наблюдалось, отвергается.')
207/271: sns.boxplot(data=df);
207/272:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
207/273:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
207/274: sns.boxplot(data=df);
207/275:
sns.boxplot(data=df);
# Из графиков видно, что медиана второго графика больше, чем у первого. Так у второго графика больше дисперсия, чем у первого
207/276:
df = pd.read_csv('./data/methylphenidate.txt', sep=' ')
df.head()
207/277:
sns.boxplot(data=df);
# Из графиков видно, что медиана второго графика больше, чем у первого. Так у второго графика больше дисперсия, чем у первого
207/278:
df = pd.read_csv('./data/seattle.txt', sep='\t')
df.head(100)
208/1:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
208/2:
import numpy as np
import pandas as pd

from scipy import stats as sts
from scipy import stats
import statsmodels as sts

import seaborn as sns
import matplotlib.pyplot as plt
from statsmodels.stats.weightstats import ttest_ind
from statsmodels.stats.descriptivestats import sign_test
from scipy.stats import chisquare
from scipy.stats import poisson


plt.style.use('ggplot')
208/3:
df = pd.read_csv('./data/seattle.txt', sep='\t')
df.head()
208/4: df_2001 = df[df.Year = 2001]
208/5: df_2001 = df[df.Year == 2001]
208/6: df_2001
208/7:
df_2001 = df[df.Year == 2001].reset_index()
df_2002 = df[df.Year == 2002].reset_index()
208/8: df_2001
208/9: df_2001
208/10:
df_2001 = df[df.Year == 2001].reset_index(drop=True)
df_2002 = df[df.Year == 2002].reset_index(drop=True)
208/11: df_2001
208/12:
df = pd.read_csv('./data/anorexia.txt', sep='\t')
df.head()
208/13: df.describe()
   1: %history -g -f history.txt
